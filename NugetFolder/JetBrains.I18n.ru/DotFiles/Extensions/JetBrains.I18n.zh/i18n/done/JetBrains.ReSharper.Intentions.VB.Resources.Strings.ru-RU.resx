<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ToCollectionReturn_Text" xml:space="preserve">
    <value>转换为集合返回</value>
  </data>
  <data name="ToConst_Text" xml:space="preserve">
    <value>转换为 const</value>
  </data>
  <data name="Reference_AndUseMethod__Text" xml:space="preserve">
    <value>引用 '{0}' 并使用方法 '{1}'</value>
  </data>
  <data name="RemoveIteratorModifier_Text" xml:space="preserve">
    <value>移除 'Iterator' 修饰符</value>
  </data>
  <data name="SpecifyStringComparison_Text" xml:space="preserve">
    <value>指定字符串比较</value>
  </data>
  <data name="CanBeNull_Text" xml:space="preserve">
    <value>可以为 null</value>
  </data>
  <data name="CreateNestedDelegate__Text" xml:space="preserve">
    <value>创建嵌套委托 '{0}'</value>
  </data>
  <data name="CreateLocalVariable__Text" xml:space="preserve">
    <value>创建局部变量 '{0}'</value>
  </data>
  <data name="ToAutoPropertyWithPrivateSetter_Text" xml:space="preserve">
    <value>转换为带 private setter 的自动属性</value>
  </data>
  <data name="RemoveUnusedLabel_Text" xml:space="preserve">
    <value>移除未使用的标签</value>
  </data>
  <data name="Make__NonReadonly_Text" xml:space="preserve">
    <value>将{0} '{1}' 设为非只读</value>
  </data>
  <data name="CreateParameter_InContaining__Text" xml:space="preserve">
    <value>在包含{1}中创建形参 '{0}'</value>
  </data>
  <data name="CompareADifferenceWithEpsilon_Text" xml:space="preserve">
    <value>比较与 Epsilon 的差异</value>
  </data>
  <data name="ReplaceExpressionWith__Text" xml:space="preserve">
    <value>将表达式替换为 '{0}'</value>
  </data>
  <data name="RemoveThenKeyword_Text" xml:space="preserve">
    <value>移除 'Then' 关键字</value>
  </data>
  <data name="FixFloatingPointNumbersComparing__Text" xml:space="preserve">
    <value>修正浮点数比较。{0}</value>
  </data>
  <data name="CreateConstructor__Text" xml:space="preserve">
    <value>创建构造函数 {0}</value>
  </data>
  <data name="ConvertToSelectCaseStatement_Text" xml:space="preserve">
    <value>转换为 'Select Case' 语句</value>
  </data>
  <data name="AddAsyncModifier_Text" xml:space="preserve">
    <value>添加 'Async' 修饰符</value>
  </data>
  <data name="RethrowException_Text" xml:space="preserve">
    <value>再次抛出异常</value>
  </data>
  <data name="CreateMustInherit___Text" xml:space="preserve">
    <value>创建 MustInherit {1} '{0}'</value>
  </data>
  <data name="CreateParameter_InContaining_AndUpdate_Text" xml:space="preserve">
    <value>在包含{1}中创建形参 '{0}' 并更新层次结构</value>
  </data>
  <data name="AddOverloads_Text" xml:space="preserve">
    <value>添加 “Overloads”</value>
  </data>
  <data name="EnumerateToArray_Text" xml:space="preserve">
    <value>枚举到数组</value>
  </data>
  <data name="ToSub_Text" xml:space="preserve">
    <value>转换为 Sub</value>
  </data>
  <data name="Create_AccessorFor__Text" xml:space="preserve">
    <value>为 '{1}' 创建 {0} 访问器</value>
  </data>
  <data name="RemoveParentheses_Text" xml:space="preserve">
    <value>移除圆括号</value>
  </data>
  <data name="CreateOverloadWithoutParameter_Text" xml:space="preserve">
    <value>创建不带形参的重载</value>
  </data>
  <data name="SetReturnTypeTo__Text" xml:space="preserve">
    <value>将返回值类型设置为 {0}</value>
  </data>
  <data name="DisableAndRestoreWithComments_Text" xml:space="preserve">
    <value>使用注释禁用和还原</value>
  </data>
  <data name="NotNull_Text" xml:space="preserve">
    <value>非 null</value>
  </data>
  <data name="SafelyCast_To__Text" xml:space="preserve">
    <value>将 {0} 安全地转换为 {1}</value>
  </data>
  <data name="ImplementMemberIn_Text" xml:space="preserve">
    <value>从中实现成员</value>
  </data>
  <data name="CreateDelegate__Text" xml:space="preserve">
    <value>创建委托 '{0}'</value>
  </data>
  <data name="GenerateRelationalMembers_Text" xml:space="preserve">
    <value>生成关系成员</value>
  </data>
  <data name="IterateCollectionViaForEach_Text" xml:space="preserve">
    <value>通过 'For Each' 迭代集合</value>
  </data>
  <data name="ToFunction_Text" xml:space="preserve">
    <value>转换为函数</value>
  </data>
  <data name="SplitIntoSeparateDeclarations_Text" xml:space="preserve">
    <value>拆分为单独的声明</value>
  </data>
  <data name="AddOf_Text" xml:space="preserve">
    <value>添加 '(Of )'</value>
  </data>
  <data name="SimplifyConditionalOperator_Text" xml:space="preserve">
    <value>简化条件运算符</value>
  </data>
  <data name="ToAutomaticProperty_Text" xml:space="preserve">
    <value>转换为自动属性</value>
  </data>
  <data name="Add_ConstraintTo_Of__Text" xml:space="preserve">
    <value>将 '{0}' 约束添加到{3} {4} 的{1} {2}</value>
  </data>
  <data name="AwaitExpression_Text" xml:space="preserve">
    <value>Await 表达式</value>
  </data>
  <data name="FailedToImportMethod_Text" xml:space="preserve">
    <value>无法导入方法</value>
  </data>
  <data name="CreateField__Text" xml:space="preserve">
    <value>创建字段 '{0}'</value>
  </data>
  <data name="SplitString_Text" xml:space="preserve">
    <value>拆分字符串</value>
  </data>
  <data name="RemoveRedundantQualifier_Text" xml:space="preserve">
    <value>移除冗余的限定符</value>
  </data>
  <data name="MakeProperty_WriteOnly_Text" xml:space="preserve">
    <value>将属性 '{0}' 设为只写</value>
  </data>
  <data name="ToImplicitlyTyped_Text" xml:space="preserve">
    <value>转换为隐式类型化</value>
  </data>
  <data name="CreateEvent__Text" xml:space="preserve">
    <value>创建事件 {0}</value>
  </data>
  <data name="ReverseAssignment_Text" xml:space="preserve">
    <value>反转赋值</value>
  </data>
  <data name="CreateOverloadWithoutSelectedParameters_Text" xml:space="preserve">
    <value>创建不带所选形参的重载</value>
  </data>
  <data name="ReplaceIfWithBranch_Text" xml:space="preserve">
    <value>将 'If' 替换为分支</value>
  </data>
  <data name="MergeTwoIfS_Text" xml:space="preserve">
    <value>合并两条 'if'</value>
  </data>
  <data name="CreateMustInheritDefaultProperty__Text" xml:space="preserve">
    <value>创建 MustInherit 默认属性</value>
  </data>
  <data name="RemoveRedundantImports_Text" xml:space="preserve">
    <value>移除冗余的 'imports'</value>
  </data>
  <data name="CreateProperty__Text" xml:space="preserve">
    <value>创建属性 '{0}'</value>
  </data>
  <data name="UseMethod_Text" xml:space="preserve">
    <value>使用方法</value>
  </data>
  <data name="DisableWithPreprocessorDirective_Text" xml:space="preserve">
    <value>使用预处理程序指令禁用</value>
  </data>
  <data name="ImportNamespace_Text" xml:space="preserve">
    <value>导入命名空间</value>
  </data>
  <data name="CorrectSharedAccess_Text" xml:space="preserve">
    <value>正确的共享访问</value>
  </data>
  <data name="ReplaceWith___Call_Text" xml:space="preserve">
    <value>替换为 {0}{1}.{2}(...) 调用</value>
  </data>
  <data name="RemoveReturnValue_Text" xml:space="preserve">
    <value>移除返回值</value>
  </data>
  <data name="MakeProperty_ReadOnly_Text" xml:space="preserve">
    <value>将属性 '{0}' 设为只读</value>
  </data>
  <data name="RemoveCaseBranch_Text" xml:space="preserve">
    <value>移除 case 分支</value>
  </data>
  <data name="RemoveValueParameter_Text" xml:space="preserve">
    <value>移除 'value' 形参</value>
  </data>
  <data name="ReplaceWithImplements_Text" xml:space="preserve">
    <value>替换为 Implements</value>
  </data>
  <data name="CreateMustInheritOverloadFor___Text" xml:space="preserve">
    <value>为{1} '{0}' 创建 MustInherit 重载</value>
  </data>
  <data name="RemoveAwait_Text" xml:space="preserve">
    <value>移除 'Await'</value>
  </data>
  <data name="MoveReturnValueBeforeReturnStatement_Text" xml:space="preserve">
    <value>将返回值移动到返回语句之前</value>
  </data>
  <data name="EnumerateWithMethodAsArrayInternal_Text" xml:space="preserve">
    <value>使用方法 AsArray 枚举 [Internal]</value>
  </data>
  <data name="RemoveRedundantParentheses_Text" xml:space="preserve">
    <value>移除冗余圆括号</value>
  </data>
  <data name="OverrideMemberIn_Text" xml:space="preserve">
    <value>重写此处的成员</value>
  </data>
  <data name="CreateEnumMember__Text" xml:space="preserve">
    <value>创建枚举成员 '{0}'</value>
  </data>
  <data name="RemoveAllValueParameters_Text" xml:space="preserve">
    <value>移除所有 'value' 形参</value>
  </data>
  <data name="AddShadows_Text" xml:space="preserve">
    <value>添加 “Shadows”</value>
  </data>
  <data name="GenerateEqualityMembers_Text" xml:space="preserve">
    <value>生成相等成员</value>
  </data>
  <data name="ImplementInDerivedClasses_Text" xml:space="preserve">
    <value>在派生类中实现</value>
  </data>
  <data name="CastTo__Text" xml:space="preserve">
    <value>转换为 {1}</value>
  </data>
  <data name="JoinDeclarationAndAssignment_Text" xml:space="preserve">
    <value>联接声明和赋值</value>
  </data>
  <data name="UseMethod__Text" xml:space="preserve">
    <value>使用方法'{0}'</value>
  </data>
  <data name="CastSecondOperandTo__Text" xml:space="preserve">
    <value>将第二个操作数转换为 '{0}'</value>
  </data>
  <data name="ConvertPartOfBodyIntoLINQExpression_Text" xml:space="preserve">
    <value>将部分主体转换为 LINQ 表达式</value>
  </data>
  <data name="RemoveByValModifiers_Text" xml:space="preserve">
    <value>移除 'ByVal' 修饰符</value>
  </data>
  <data name="Cast_To__Text" xml:space="preserve">
    <value>将{0}转换为{1}</value>
  </data>
  <data name="SafelyCastTo__Text" xml:space="preserve">
    <value>安全地转换为 {1}</value>
  </data>
  <data name="ConvertToFor_Text" xml:space="preserve">
    <value>转换为 For</value>
  </data>
  <data name="AddIteratorModifier_Text" xml:space="preserve">
    <value>添加 'Iterator' 修饰符</value>
  </data>
  <data name="ReplaceByOperatorTypeOfIsInvocation_Text" xml:space="preserve">
    <value>替换为运算符 'TypeOf ... Is ...' 调用</value>
  </data>
  <data name="InvokeAsExtensionMethod_Text" xml:space="preserve">
    <value>作为扩展方法调用</value>
  </data>
  <data name="RemoveRedundantQualifiers_Text" xml:space="preserve">
    <value>移除冗余限定符</value>
  </data>
  <data name="Create___Text" xml:space="preserve">
    <value>创建{1} '{0}'</value>
  </data>
  <data name="ReplaceIIfWithBranch_Text" xml:space="preserve">
    <value>将 'IIf' 替换为分支</value>
  </data>
  <data name="InvertIf_Text" xml:space="preserve">
    <value>反转 'If'</value>
  </data>
  <data name="CreateReadOnlyProperty__Text" xml:space="preserve">
    <value>创建只读属性 '{0}'</value>
  </data>
  <data name="ConvertIntoLINQExpression_Text" xml:space="preserve">
    <value>转换为 LINQ 表达式</value>
  </data>
  <data name="RenameFileToMatchTypeName_Text" xml:space="preserve">
    <value>重命名文件以匹配类型名称</value>
  </data>
  <data name="ImportNamespace__Text" xml:space="preserve">
    <value>导入命名空间 '{0}'</value>
  </data>
  <data name="ToImplicitlyTypedVariables_Text" xml:space="preserve">
    <value>转换为隐式类型化变量</value>
  </data>
  <data name="MakeSuffixUppercase_Text" xml:space="preserve">
    <value>将后缀设为大写</value>
  </data>
  <data name="RemoveAttribute_Text" xml:space="preserve">
    <value>移除特性</value>
  </data>
  <data name="SpecifyType_Text" xml:space="preserve">
    <value>指定类型</value>
  </data>
  <data name="SplitDeclarationAndAssignment_Text" xml:space="preserve">
    <value>拆分声明和赋值</value>
  </data>
  <data name="MoveToAnotherFileToMatchTypeName_Text" xml:space="preserve">
    <value>移至另一个文件以匹配类型名称</value>
  </data>
  <data name="InsertInferredTypeArguments_Text" xml:space="preserve">
    <value>插入推断的类型实参</value>
  </data>
  <data name="CreateNested___Text" xml:space="preserve">
    <value>创建嵌套{1} '{0}'</value>
  </data>
  <data name="IntroduceVariable_Text" xml:space="preserve">
    <value>引入变量</value>
  </data>
  <data name="GenerateDisposePattern_Text" xml:space="preserve">
    <value>生成处置模式</value>
  </data>
  <data name="CreateDefaultProperty_Text" xml:space="preserve">
    <value>创建默认属性</value>
  </data>
  <data name="ImplementMembers_Text" xml:space="preserve">
    <value>实现成员</value>
  </data>
  <data name="DisableOnceWithComment_Text" xml:space="preserve">
    <value>使用注释禁用一次</value>
  </data>
  <data name="CreateMustOverrideProperty__Text" xml:space="preserve">
    <value>创建 MustOverride 属性 '{0}'</value>
  </data>
  <data name="AddCallKeyword_Text" xml:space="preserve">
    <value>添加 'Call' 关键字</value>
  </data>
  <data name="ToPropertyWithBackingField_Text" xml:space="preserve">
    <value>转换为带支持字段的属性</value>
  </data>
  <data name="CreateOverloadFor___Text" xml:space="preserve">
    <value>为{1} '{0}' 创建重载</value>
  </data>
  <data name="OverrideInDerivedClasses_Text" xml:space="preserve">
    <value>在派生类中重写</value>
  </data>
  <data name="RemoveThenKeywords_Text" xml:space="preserve">
    <value>移除 'Then' 关键字</value>
  </data>
  <data name="ToAutoProperty_Text" xml:space="preserve">
    <value>转换为自动属性</value>
  </data>
  <data name="RemoveByValModifier_Text" xml:space="preserve">
    <value>移除 'ByVal' 修饰符</value>
  </data>
  <data name="Create_AccessorFor_InBase_Text" xml:space="preserve">
    <value>为基中的 '{1}' 创建 {0} 访问器</value>
  </data>
  <data name="EnumerateWithMethodAsListInternal_Text" xml:space="preserve">
    <value>使用方法 AsList 枚举 [Internal]</value>
  </data>
  <data name="ReplaceWithInherits_Text" xml:space="preserve">
    <value>替换为 Inherits</value>
  </data>
  <data name="Remove_Modifier_Text" xml:space="preserve">
    <value>移除 '{0}' 修饰符</value>
  </data>
  <data name="ChangeFunctionIntoSub_Text" xml:space="preserve">
    <value>将 Function 更改为 Sub</value>
  </data>
  <data name="SurroundWithWith_Text" xml:space="preserve">
    <value>使用 'With' 包围</value>
  </data>
  <data name="SplitIntoTwoIfS_Text" xml:space="preserve">
    <value>拆分为两个 'If'</value>
  </data>
  <data name="AddAnotherAccessor_Text" xml:space="preserve">
    <value>添加另一个访问器</value>
  </data>
  <data name="RemoveExpression_Text" xml:space="preserve">
    <value>移除表达式</value>
  </data>
  <data name="ReverseAssignments_Text" xml:space="preserve">
    <value>反转赋值</value>
  </data>
  <data name="RemoveUnreachableCode_Text" xml:space="preserve">
    <value>移除无法访问的代码</value>
  </data>
  <data name="Create_AccessorFor_InInterface_Text" xml:space="preserve">
    <value>为接口中的 '{1}' 创建 {0} 访问器</value>
  </data>
  <data name="_WillConflictWith__Text" xml:space="preserve">
    <value>{0} 将与 {1} 冲突</value>
  </data>
  <data name="RemoveRedundantImportsInFile_Text" xml:space="preserve">
    <value>移除文件中冗余的 'imports'</value>
  </data>
  <data name="FailedToImportType_Text" xml:space="preserve">
    <value>无法导入类型</value>
  </data>
  <data name="MergeTryCatchFinallyStatements_Text" xml:space="preserve">
    <value>合并 try-catch-finally 语句</value>
  </data>
  <data name="RemoveTypeArguments_Text" xml:space="preserve">
    <value>移除类型实参</value>
  </data>
  <data name="EnumerateToList_Text" xml:space="preserve">
    <value>枚举到列表</value>
  </data>
  <data name="RemoveAsyncModifier_Text" xml:space="preserve">
    <value>移除 'Async' 修饰符</value>
  </data>
  <data name="RemoveExplicitArraySizeSpecification_Text" xml:space="preserve">
    <value>移除显式数组大小规范</value>
  </data>
  <data name="WrapTypeNameWithGetType_Text" xml:space="preserve">
    <value>使用 GetType() 包装类型名称</value>
  </data>
  <data name="Reference_AndImportNamespace__Text" xml:space="preserve">
    <value>引用 '{0}' 并导入命名空间 '{1}'</value>
  </data>
  <data name="CouldnTConvertIteratorWithoutAnyReachable_Text" xml:space="preserve">
    <value>无法转换没有任何可到达出口的迭代器</value>
  </data>
  <data name="ReplaceWithDim__TryCast__If_IsNotNothing_Text" xml:space="preserve">
    <value>替换为 'Dim {0}{3} = TryCast({1}, {2}) If ({0} IsNot Nothing) ... EndIf'</value>
  </data>
  <data name="RemoveRedundantCast_Text" xml:space="preserve">
    <value>移除冗余转换</value>
  </data>
  <data name="AddOtherAccessors_Text" xml:space="preserve">
    <value>添加其他访问器</value>
  </data>
</root>
