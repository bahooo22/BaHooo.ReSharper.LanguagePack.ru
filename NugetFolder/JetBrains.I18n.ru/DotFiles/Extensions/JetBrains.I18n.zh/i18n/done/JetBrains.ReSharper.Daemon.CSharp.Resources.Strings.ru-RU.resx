<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="FunctionBodyIsTooComplexToAnalyze" xml:space="preserve">
    <value>函数体太复杂，无法分析</value>
  </data>
  <data name="UseStringIsNullOrEmpty" xml:space="preserve">
    <value>使用 'String.IsNullOrEmpty'</value>
  </data>
  <data name="AparamsParameterMustBeTheLastParameterInAFormalParameterListMessage4" xml:space="preserve">
    <value>'params' 形参必须为形参列表中的最后一个形参</value>
  </data>
  <data name="InvalidFixedSizeBufferLengthMessage" xml:space="preserve">
    <value>固定大小缓冲区的长度必须大于零</value>
  </data>
  <data name="GlobalUsingDirectiveIsNotRequiredByTheCodeAndCanBeSafelyRemoved" xml:space="preserve">
    <value>代码不需要 global using 指令，可以将其安全地移除</value>
  </data>
  <data name="RedundantAlwaysMatchSubpatternMessage" xml:space="preserve">
    <value>始终匹配的子模式冗余</value>
  </data>
  <data name="NullabilityMismatchInReturnTypeOnInterceptorMessage" xml:space="preserve">
    <value>拦截器方法 '{0}' 的返回值类型中的引用类型为 null 性与可拦截方法 '{1}' 不匹配</value>
  </data>
  <data name="Decrement_Text" xml:space="preserve">
    <value>减量</value>
  </data>
  <data name="TypeSystemIndexIsNotResolvedMessage" xml:space="preserve">
    <value>类型 'System.Index' 未被解析</value>
  </data>
  <data name="UseWithExpressionToCopyStruct" xml:space="preserve">
    <value>使用 'with' 表达式复制结构</value>
  </data>
  <data name="voidMethodIsAnnotatedByPureAttribute26" xml:space="preserve">
    <value>使用 [Pure] 特性注解 'void' 方法毫无意义</value>
  </data>
  <data name="_13OrGreater_Text" xml:space="preserve">
    <value>13.0 或更高</value>
  </data>
  <data name="CannotApplyOperatorToOperandsOfTypeReadOnlySpanOfByteMessage" xml:space="preserve">
    <value>不能将运算符 '{0}' 应用于非 UTF-8 表示的 '{1}' 和 '{2}' 类型的操作数</value>
  </data>
  <data name="CompilerWarning_CS1572_Title" xml:space="preserve">
    <value>XML 注释中有 param 标记，但是没有该名称的参数</value>
  </data>
  <data name="InterfaceCannotDeclareABodyMessage" xml:space="preserve">
    <value>interface {0}不能声明主体</value>
  </data>
  <data name="LambdaExpressionExplicitParameterTypeSpecificationIsRedundant" xml:space="preserve">
    <value>lambda 表达式显式形参类型规范冗余</value>
  </data>
  <data name="IteratorCannotContainreturnStatementMessage" xml:space="preserve">
    <value>迭代器不能包含 'return' 语句</value>
  </data>
  <data name="SimplifyNestedMemberAccessInAPatternByUsingTheCExtendedPropertyPatternsSyntax" xml:space="preserve">
    <value>使用 C# 10 扩展属性模式语法简化模式中的嵌套成员访问</value>
  </data>
  <data name="ConvertSingleExtensionMethodDescription" xml:space="preserve">
    <value>建议将单个经典扩展方法转换为 C# 14 扩展块</value>
  </data>
  <data name="Field_Text" xml:space="preserve">
    <value>字段</value>
  </data>
  <data name="CannotChooseMethodFromMethodGroupNCandidatesAreMessage" xml:space="preserve">
    <value>不能从方法组中选择方法。 
候选项为:{0}</value>
  </data>
  <data name="UseNullCheckPatternInsteadOfATypeCheckSucceedingOnAnyNotNullValue" xml:space="preserve">
    <value>在任何非 null 值之后使用 null 检查模式而非类型检查</value>
  </data>
  <data name="TailRecursiveCallCanBeReplacedWithLoopMessage" xml:space="preserve">
    <value>尾递归调用可被替换为循环</value>
  </data>
  <data name="NotDisposedResourceTitle" xml:space="preserve">
    <value>使用 [MustDisposeResource] 注解的方法的返回值永远不会被处置</value>
  </data>
  <data name="_12OrGreater_Text" xml:space="preserve">
    <value>12.0 或更高</value>
  </data>
  <data name="RedundantExplicitDelegateCreationMessage" xml:space="preserve">
    <value>冗余的显式委托创建</value>
  </data>
  <data name="CSharpFormatterHighlightingProvider_InternalConfigurableSeverityItems_Incorrect_number_of_blank_lines_near_braces" xml:space="preserve">
    <value>大括号附近的空行数不正确</value>
  </data>
  <data name="TheReturnTypeOfIncrementDecrementOperatorMustBeOfContainingTypeMessage" xml:space="preserve">
    <value>递增/递减运算符的返回值类型必须为包含类型</value>
  </data>
  <data name="AdefaultLiteralCannotBeUsedAsAConstituentValueOfADynamicallyBoundOperationMessage" xml:space="preserve">
    <value>'default' 字面量不能用作动态绑定运算的组成值</value>
  </data>
  <data name="FixedPointerMayLeakOutsideOfFixedStatementMessage" xml:space="preserve">
    <value>不能在匿名方法、lambda 表达式或查询表达式内使用固定的局部 '{0}'</value>
  </data>
  <data name="CompilerWarning_CS8360_Title" xml:space="preserve">
    <value>筛选器表达式是常量 “false”。 </value>
  </data>
  <data name="RefAssignValEscapeWiderWarningMessage" xml:space="preserve">
    <value>这会将 '{1}' 引用赋给 '{0}'，但 '{1}' 的值转义作用域比 '{0}' 宽，允许通过转义作用域比 '{1}' 更窄的值的 '{0}' 进行赋值</value>
  </data>
  <data name="RemoveRedundantParentheses_Caption" xml:space="preserve">
    <value>移除冗余圆括号</value>
  </data>
  <data name="ParameterNameDiffersInPartialMemberDeclaration" xml:space="preserve">
    <value>形参名称在分部成员声明之间不同</value>
  </data>
  <data name="DoesNotImplementInterfaceMessage" xml:space="preserve">
    <value>{0} '{1}' 不实现接口 '{2}'</value>
  </data>
  <data name="AThrowExpressionIsNotAllowedInThisContextMessage" xml:space="preserve">
    <value>此上下文中不允许使用 throw 表达式</value>
  </data>
  <data name="PossiblyWrongStringComparisonWithSpans" xml:space="preserve">
    <value>可能存在错误的字符串比较: 只有指向同一内存位置时，跨度才相等</value>
  </data>
  <data name="CodeCleanupTask_ArrangeNamespaces" xml:space="preserve">
    <value>排列命名空间(文件作用域与块作用域)</value>
  </data>
  <data name="CannotCreateAnArrayInitializerWhenSizeIsNotConstantMessage" xml:space="preserve">
    <value>大小不恒定时不能创建数组初始值设定项</value>
  </data>
  <data name="AnOutDeconstructionVariableCannotBeDeclaredAsARefLocalMessage" xml:space="preserve">
    <value>out/析构变量不能被声明为 ref 局部变量</value>
  </data>
  <data name="IsCultureSpecific_Text" xml:space="preserve">
    <value>{0}为区域性特定</value>
  </data>
  <data name="LoopCanBeConvertedIntoLINQExpression" xml:space="preserve">
    <value>循环可以转换为 LINQ 表达式</value>
  </data>
  <data name="ConvertSeriesOfIfStatementsToSingleSwitch" xml:space="preserve">
    <value>将一系列 'if' 语句转换为单条 'switch'</value>
  </data>
  <data name="RedundantWithCancellationDescription" xml:space="preserve">
    <value>'WithCancellation()' 调用冗余，因为指定的取消令牌已应用于异步流</value>
  </data>
  <data name="AccessorMustDeclareABodyBecauseIsNotMarkedAsAbstractExternOrPartialMessage" xml:space="preserve">
    <value>访问器必须声明主体，因为{0}未被标记为 'abstract'、'extern' 或 'partial'</value>
  </data>
  <data name="OptionalParamValueMismatchMessage" xml:space="preserve">
    <value>形参 {0} 在 lambda 中具有默认值 '{1}'，但在目标委托类型中为 '{2}'</value>
  </data>
  <data name="UnsafeContextDeclarationIsRedundant" xml:space="preserve">
    <value>unsafe 上下文声明冗余</value>
  </data>
  <data name="MethodInvocationIsSkippedPartialMessage" xml:space="preserve">
    <value>方法 '{0}' 调用被跳过。编译器将不会生成方法调用，因为该方法是没有实现的{1}方法。</value>
  </data>
  <data name="EntityFramework_UnlimitedStringLengthHighlighting_ToolTip_Text" xml:space="preserve">
    <value>由于字符串长度不受限，可能会出现性能问题</value>
  </data>
  <data name="TypeCheckForNullableTypeInisExpressionIsEqualToUnderlyingTypeCheck" xml:space="preserve">
    <value>'is' 表达式中可以为 null 的类型的类型检查等于基础类型检查</value>
  </data>
  <data name="ThereIsBaseMemberThatHasConflictingNullnessAnnotation" xml:space="preserve">
    <value>存在具有冲突的为 null 性注解的基成员</value>
  </data>
  <data name="ExplicitArgumentPassedToParameterWithCallerInfoAttributeMessage" xml:space="preserve">
    <value>显式实参被传递给具有调用方信息特性的形参</value>
  </data>
  <data name="PropertyInInterfaceCannotHaveInitializerMessage" xml:space="preserve">
    <value>接口中的实例属性不能具有初始值设定项</value>
  </data>
  <data name="DuplicateAssignmentOfMemberMessage" xml:space="preserve">
    <value>重复的成员 '{0}' 赋值</value>
  </data>
  <data name="UseOfdefaultLiteralIsNotValidInThisContextMessage" xml:space="preserve">
    <value>'default' 字面量的使用在此上下文中无效</value>
  </data>
  <data name="UseNameofForDependencyPropertyDescription" xml:space="preserve">
    <value>注册 DependencyProperty 时使用 'nameof(ClrProperty)' 而不是硬编码名称。</value>
  </data>
  <data name="CompilerWarning_CS3002_Title" xml:space="preserve">
    <value>返回类型不符合 CLS</value>
  </data>
  <data name="MakeConstructorInAbstractClassProtected1" xml:space="preserve">
    <value>将 abstract 类中的构造函数设为 protected</value>
  </data>
  <data name="CompilerWarning_CS8513_Title" xml:space="preserve">
    <value>请勿使用 "_" 引用 is-type 表达式中的类型。</value>
  </data>
  <data name="TurnOnInferredDiscardNamesInlayHint_Text" xml:space="preserve">
    <value>显示舍弃值的推断名称</value>
  </data>
  <data name="BothContextCallMessage" xml:space="preserve">
    <value>{0} 从两种 CQRS 上下文调用</value>
  </data>
  <data name="InterpolatedStringHandlerArgumentAttributeArgumentsCannotReferToTheParameterTheAttributeIsUsedOnMessage" xml:space="preserve">
    <value>[InterpolatedStringHandlerArgumentAttribute] 实参不能引用使用该特性的形参</value>
  </data>
  <data name="CannotBeOfTypevoidMessage" xml:space="preserve">
    <value>{0}不能为 'void' 类型</value>
  </data>
  <data name="ConstraintsForOverrideAndExplicitInterfaceImplementationMethodsAreInheritedFromTheBaseMethodSoTheyCannotBeSpecifiedDirectlyExceptForEitherAClassStructOrADefaultConstraintMessage" xml:space="preserve">
    <value>除 'class'、'struct' 和 'default' 约束外，重写和显式接口实现方法的约束继承自基方法，因此不能直接指定</value>
  </data>
  <data name="ConflictMultipleCqrsAttributeMessage" xml:space="preserve">
    <value>冲突的 CQRS 特性。仅允许使用一个 CQRS 特性来明确地标识该实体。</value>
  </data>
  <data name="UserDefinedOperatorMustBeDeclaredPublicMessage" xml:space="preserve">
    <value>用户定义的运算符必须被声明为 public</value>
  </data>
  <data name="DuplicatedChainedIfBodiesTitle" xml:space="preserve">
    <value>重复的链式 'if' 分支</value>
  </data>
  <data name="ComparisonToIntegralConstantIsUselessTheConstantIsOutsideTheRangeOfTypeMessage" xml:space="preserve">
    <value>与整数常量比较无意义；该常量不在“{0}”类型的范围之内</value>
  </data>
  <data name="UseFormatSpecifierInInterpolatedStrings" xml:space="preserve">
    <value>在内插字符串中使用格式说明符</value>
  </data>
  <data name="AccessToAStaticMemberOfATypeViaADerivedTypeMessage" xml:space="preserve">
    <value>通过派生类型访问某一类型的 static 成员</value>
  </data>
  <data name="UseUtf8StringLiteralForParamsMessage" xml:space="preserve">
    <value>字节数组可被转换为 UTF-8 字符串字面量</value>
  </data>
  <data name="IndexerHasParameterSButIsInvokedWithArgumentSMessage" xml:space="preserve">
    <value>索引器具有 {0} 个形参，但使用 {1} 个实参调用</value>
  </data>
  <data name="ReferenceToThisIsImmutableInReadonlyMember_Text" xml:space="preserve">
    <value>对 '{0}' 的引用在{2}的 '{1}' 成员中不可变。</value>
  </data>
  <data name="CompilerWarning_CS9091_Title" xml:space="preserve">
    <value>这会按引用返回本地，但它不是 ref 本地</value>
  </data>
  <data name="ASuppressedNullableWarningMightHideAnUnderlyingProblemSuchAsANullableValueThatWasThoughToBeAlreadyHandledThisMightBeAResultOfARefactoringIntroducingNullableValuesOnExecutionPathsWhereTheyWerentAllowed" xml:space="preserve">
    <value>禁止的可以为 null 警告可能会隐藏底层问题，例如被认为已经处理的可以为 null 的值。这可能是由于在不允许具有可以为 null 的值的执行路径上引入了可以为 null 的值的重构引起的。</value>
  </data>
  <data name="EventInInterfaceCannotHaveInitializerMessage" xml:space="preserve">
    <value>接口中的事件不能有初始值设定项</value>
  </data>
  <data name="ExpectedAMethodMessage" xml:space="preserve">
    <value>应为方法{0}</value>
  </data>
  <data name="UseWithExpressionToCopyRecord" xml:space="preserve">
    <value>使用 'with' 表达式复制记录</value>
  </data>
  <data name="DuplicateConstructorConstraintMessage" xml:space="preserve">
    <value>重复的构造函数约束</value>
  </data>
  <data name="CodeBody_Text" xml:space="preserve">
    <value>代码主体</value>
  </data>
  <data name="BaseTypeRequiredAttributeSupportsOnlyClassesAndInterfaces" xml:space="preserve">
    <value>BaseTypeRequired 特性仅支持类和接口</value>
  </data>
  <data name="UseCompilerSupportedAttributesFromSystemDiagnosticsCodeAnalysisNamespaceToOverrideAnnotationsForNullableReferenceTypes" xml:space="preserve">
    <value>使用来自 System.Diagnostics.CodeAnalysis 命名空间的编译器支持的特性来重写可以为 null 的引用类型的注解</value>
  </data>
  <data name="AByValueReturnCannotBeUsedInThatReturnsMessage" xml:space="preserve">
    <value>按值返回值不能在按引用返回的{0}中使用</value>
  </data>
  <data name="IsNotAValidNamedAttributeArgumentBecauseItHasTypeWhichIsNotAValidAttributeParameterTypeMessage" xml:space="preserve">
    <value>'{0}' 不是有效的命名特性实参，因为它具有类型 '{1}'，这不是有效的特性形参类型</value>
  </data>
  <data name="UnscopedRefAttributeInterfaceImplementationMessage" xml:space="preserve">
    <value>'UnscopedRefAttribute' 不能应用于接口实现，因为实现的成员 '{0}' 没有此特性</value>
  </data>
  <data name="CompilerWarning_CS9113_Title" xml:space="preserve">
    <value>参数未读。</value>
  </data>
  <data name="SomeValuesOfTheEnumAreNotProcessedInsideswitchStatementAndAreHandledViaDefaultSection" xml:space="preserve">
    <value>枚举的某些值未在 'switch' 语句内处理，而是通过 default 部分进行处理</value>
  </data>
  <data name="MultipleExpressionsAreNotAllowedInusingStatementMessage" xml:space="preserve">
    <value>'using' 语句中不允许使用多个表达式</value>
  </data>
  <data name="PassingAsArgumentMayCauseARuntimeExceptionBecauseItIsAFieldOfAMarshalByReferenceClassMessage" xml:space="preserve">
    <value>将 '{0}' 作为 '{1}' 实参传递可能导致运行时异常，因为它是引用封送类的字段</value>
  </data>
  <data name="UsePreferredStyleOfnewExpressionWhenCreatedTypeIsEvident" xml:space="preserve">
    <value>当创建的类型明确时，使用首选的 'new' 表达式样式</value>
  </data>
  <data name="TernaryExpressionContainstrueOrfalseInResultBranchForExamplepreConditionTrueElseBranchConditionThenBranchTruePre" xml:space="preserve">
    <value>三元表达式在结果分支中包含 'true' 或 'false'，例如
          &lt;pre&gt;
            condition ? true : elseBranch
            condition ? thenBranch : true
          &lt;/pre&gt;</value>
  </data>
  <data name="CompilerWarning_CS8645_Title" xml:space="preserve">
    <value>接口已在接口列表中列出，引用类型具有不同的 Null 性。</value>
  </data>
  <data name="TheAsOperatorMustBeUsedWithAReferenceOrNullableTypeIsANonNullableValueTypeMessage" xml:space="preserve">
    <value>as 运算符必须与引用或可以为 null 的类型一起使用('{0}' 是不可以为 null 的值类型)</value>
  </data>
  <data name="ReturnValueOfMethodAnnotatedWithMustUseReturnValueAttributeIsNotUsed" xml:space="preserve">
    <value>使用 [{0}] 特性注解的方法的返回值未使用</value>
  </data>
  <data name="LocalFunctionDeclaration_Text" xml:space="preserve">
    <value>局部函数声明</value>
  </data>
  <data name="CompilerWarning_CS0657_Title" xml:space="preserve">
    <value>不是此声明的有效特性位置</value>
  </data>
  <data name="CompilerWarning_CS1957_Title" xml:space="preserve">
    <value>成员在运行时使用多个重写候选项重写基成员</value>
  </data>
  <data name="RefReturnNonByRefParameterWarningMessage" xml:space="preserve">
    <value>这会通过引用返回{0} '{1}'，但它不是 ref 形参</value>
  </data>
  <data name="ParameterHidesMemberTitle" xml:space="preserve">
    <value>形参会隐藏成员</value>
  </data>
  <data name="ExplicitArgumentPassedToParameterWithCallerInfoAttribute" xml:space="preserve">
    <value>显式实参被传递给具有调用方信息特性的形参</value>
  </data>
  <data name="QualifierThisIsRedundantMessage" xml:space="preserve">
    <value>限定符 '{0}.' 冗余</value>
  </data>
  <data name="RefReturnNonByRefParameterMemberWarningMessage" xml:space="preserve">
    <value>这会通过引用返回不是 'ref' 也不是 'out' 形参的{0} '{1}' 的成员</value>
  </data>
  <data name="CompilerWarning_CS3018_Title" xml:space="preserve">
    <value>类型是不符合 CLS 的类型的成员，因此不能将其标记为符合 CLS</value>
  </data>
  <data name="addOrremoveExpectedMessage" xml:space="preserve">
    <value>应为 'and' 或 'remove'</value>
  </data>
  <data name="CompilerWarning_CS9258_Title" xml:space="preserve">
    <value>'field' 关键字绑定到属性的合成支持字段</value>
  </data>
  <data name="CompilerWarning_CS4024_Title" xml:space="preserve">
    <value>CallerLineNumberAttribute 将不起任何作用，因为它适用于不允许可选参数的上下文中使用的成员</value>
  </data>
  <data name="MergeCastWithTypeCheckMessage" xml:space="preserve">
    <value>将转换与类型检查合并</value>
  </data>
  <data name="DuplicateNullSuppressionOperatorMessage" xml:space="preserve">
    <value>Null 抑制运算符("!")重复</value>
  </data>
  <data name="WinRTStructShouldContainAtLeastOnePublicFieldMessage" xml:space="preserve">
    <value>WinRT 结构应至少包含一个 public 字段</value>
  </data>
  <data name="UseBracesToSeparatewhileStatementBody" xml:space="preserve">
    <value>使用大括号分隔 'while' 语句体</value>
  </data>
  <data name="CSharpFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_operator_symbols" xml:space="preserve">
    <value>运算符符号周围</value>
  </data>
  <data name="AnExpressionTreeLambdaMayNotContainConditionalAccessExpressionMessage" xml:space="preserve">
    <value>表达式树 lambda 不能包含条件访问表达式</value>
  </data>
  <data name="CannotChangeReturnTypeWhenOverriding_Text" xml:space="preserve">
    <value>重写{0} '{1}' 时不能更改返回值类型</value>
  </data>
  <data name="RefReadOnlyWrongOrderingMessage" xml:space="preserve">
    <value>'readonly' 修饰符必须在 'ref' 之后指定</value>
  </data>
  <data name="UseBracesToSeparatelockStatementBody" xml:space="preserve">
    <value>使用大括号分隔 'lock' 语句体</value>
  </data>
  <data name="CompilerWarning_CS1635_Title" xml:space="preserve">
    <value>警告已全局禁用，无法还原</value>
  </data>
  <data name="SemicolonAfterDeclarationIsRedundantMessage" xml:space="preserve">
    <value>{0}声明后的分号冗余</value>
  </data>
  <data name="RedundantTypeArgumentsOfMethod" xml:space="preserve">
    <value>方法的冗余类型实参</value>
  </data>
  <data name="ImplicitlyTypedArrayShouldHaveInitializerMessage" xml:space="preserve">
    <value>隐式类型化数组应具有初始值设定项</value>
  </data>
  <data name="TheModifierIsNotValidForInterfaceMemberDeclarationOnlynewIsValidMessage" xml:space="preserve">
    <value>修饰符 '{0}' 对接口成员声明无效。仅 'new' 有效。</value>
  </data>
  <data name="CompilerWarning_CS3005_Title" xml:space="preserve">
    <value>仅大小写不同的标识符不符合 CLS</value>
  </data>
  <data name="OnlyReplaceReadonlyFieldsDescription" xml:space="preserve">
    <value>不要替换可变字段以避免引入可变主构造函数形参</value>
  </data>
  <data name="AddOrRemoveExplicitTypeSpecificationInnewExpressionWhenTypeIsNotEvidentFromTheUsage" xml:space="preserve">
    <value>在无法从用法明显看出类型时，在 'new' 表达式中添加或移除显式类型规范</value>
  </data>
  <data name="RedundantCheckBeforeAssignmentMessage" xml:space="preserve">
    <value>赋值前的检查冗余</value>
  </data>
  <data name="FeatureIsNotAvailablePleaseUseLanguageVersionMessage" xml:space="preserve">
    <value>功能 '{0}' 不可用。请使用语言版本 {1}。</value>
  </data>
  <data name="CodeCleanupTask_AddMissingParentheses" xml:space="preserve">
    <value>添加圆括号以显式指定运算优先级</value>
  </data>
  <data name="CannotDefineOperatorWithNameMessage" xml:space="preserve">
    <value>不能定义名为 '{0}' 的运算符</value>
  </data>
  <data name="CantLiftConditionalAccessExpressionTypeToNullableTypeMessage" xml:space="preserve">
    <value>无法将条件访问表达式类型 '{0}' 提升为可以为 null 的类型</value>
  </data>
  <data name="CompilerWarning_CS0436_Title" xml:space="preserve">
    <value>类型与导入类型冲突</value>
  </data>
  <data name="CompilerWarning_CS1710_Title" xml:space="preserve">
    <value>XML 注释中有重复的 typeparam 标记</value>
  </data>
  <data name="MakeConstructorInAbstractClassProtected" xml:space="preserve">
    <value>将 abstract 类中的构造函数设为 protected</value>
  </data>
  <data name="NullabilityOfReferenceTypesInValueOfTypeDoesntMatchTargetTypeMessage" xml:space="preserve">
    <value>'{0}' 类型的值中引用类型的为 null 性与目标类型 '{1}' 不匹配</value>
  </data>
  <data name="CanReplaceCastWithLambdaReturnTypeTitle" xml:space="preserve">
    <value>转换表达式可被替换为 lambda 返回值类型</value>
  </data>
  <data name="AWithoutSetterOrInaccessibleSetterCannotBeAssignedToMessage" xml:space="preserve">
    <value>不能给没有 setter 或 setter 不能访问的{0}赋值</value>
  </data>
  <data name="YouMustProvideAnInitializerInAfixedStatementDeclarationMessage" xml:space="preserve">
    <value>必须在 'fixed' 语句声明中提供初始值设定项</value>
  </data>
  <data name="TheReturnTypeOfAnAsyncMethodMustBeMessage" xml:space="preserve">
    <value>'async' 方法的返回值类型必须为 {0}</value>
  </data>
  <data name="CompilerWarning_CS1616_Title" xml:space="preserve">
    <value>选项重写源文件或添加的模块中给出的特性</value>
  </data>
  <data name="TheUsingAliasAppearedPreviouslyInThisNamespaceMessage" xml:space="preserve">
    <value>using 别名“{0}”以前在此命名空间中出现过</value>
  </data>
  <data name="AusingStaticDirectiveCannotBeUsedToDeclareAnAliasMessage" xml:space="preserve">
    <value>“using static”指令不能用于声明别名</value>
  </data>
  <data name="thisQualifierCanBeSafelyAddedRemovedWithoutChangingCodeSemantics" xml:space="preserve">
    <value>可以安全地添加/移除 'this.' 限定符而不更改代码语义</value>
  </data>
  <data name="CannotUseInStaticMemberMessage" xml:space="preserve">
    <value>不能在 static 成员中使用 '{0}'</value>
  </data>
  <data name="ConvertToExtensionBlockTitle" xml:space="preserve">
    <value>将扩展方法转换为扩展块</value>
  </data>
  <data name="TheAssignmentTargetMustBeAnAssignableVariablePropertyOrIndexerMessage" xml:space="preserve">
    <value>{0}赋值目标必须为可赋值的变量、属性或索引器</value>
  </data>
  <data name="Struct_Text" xml:space="preserve">
    <value>struct</value>
  </data>
  <data name="ConvertToUsingDeclaration" xml:space="preserve">
    <value>转换为 'using' 声明</value>
  </data>
  <data name="DoesNotPerformAnArithmeticOverflowCheckMessage" xml:space="preserve">
    <value>{0}未执行算术溢出检查</value>
  </data>
  <data name="UseCompilerSupportedNullableAttributes" xml:space="preserve">
    <value>使用编译器支持的可以为 null 的特性</value>
  </data>
  <data name="RedundantExplicitSizeSpecificationInArrayCreation" xml:space="preserve">
    <value>数组创建中存在冗余的显式大小规范</value>
  </data>
  <data name="PatternStyle_CategoryText" xml:space="preserve">
    <value>模式</value>
  </data>
  <data name="ifStatementCanBeReWrittenAsExpression" xml:space="preserve">
    <value>'if' 语句可被重写为 '??' 表达式</value>
  </data>
  <data name="TypeCannotBeUsedInSpreadElement" xml:space="preserve">
    <value>只有类型 '{0}' 实现 'IEnumerable' 或 'IEnumerable&lt;T&gt;'，或者具有合适的 'GetEnumerator' 方法(返回值类型具有 'Current' 属性和 'MoveNext' 方法)时，才能在展开元素中使用</value>
  </data>
  <data name="UsingStackallocInsideLoop" xml:space="preserve">
    <value>在循环内使用 stackalloc</value>
  </data>
  <data name="ReturnValueOfMustUseReturnValueAnnotatedMethodIsNotUsed" xml:space="preserve">
    <value>带有 [MustUseReturnValue] 注解的方法的返回值未使用</value>
  </data>
  <data name="ParenthesesCanBeSafelyRemovedFromExpressions_Text" xml:space="preserve">
    <value>可以安全地从表达式中移除圆括号而不更改代码语义</value>
  </data>
  <data name="CheckedOperatorCannotBeImplicitMessage" xml:space="preserve">
    <value>'implicit' 用户定义的转换运算符不能被声明为 checked</value>
  </data>
  <data name="OverrideCannotBeMarkedAsVirtualMessage" xml:space="preserve">
    <value>重写{0}不能被标记为 virtual</value>
  </data>
  <data name="ParameterHidesPrimaryConstructorParameterMessage" xml:space="preserve">
    <value>形参 '{0}' 隐藏主构造函数形参 '{1}'</value>
  </data>
  <data name="UseDiscardAssignmentDescription" xml:space="preserve">
    <value>将故意忽略的变量声明 'var _ = ...' 替换为弃元赋值 '_ = ...'。</value>
  </data>
  <data name="UseOfWithoutMessage" xml:space="preserve">
    <value>使用不带 () 的{0} '{1}'</value>
  </data>
  <data name="PossiblyMistakenUseOfCancellationTokenMessage_AdditionSingle" xml:space="preserve">
    <value>包含{0}声明 {1} {2}。</value>
  </data>
  <data name="UseNameofExpressionToReferenceNameMessage" xml:space="preserve">
    <value>使用 '{0}' 表达式引用{1} '{2}' 名称</value>
  </data>
  <data name="TypeByteSbyteShortUshortIntUintLongOrUlongExpectedMessage" xml:space="preserve">
    <value>应输入类型 byte、sbyte、short、ushort、int、uint、long 或 ulong</value>
  </data>
  <data name="CompilerWarning_CS8012_Title" xml:space="preserve">
    <value>引用程序集面向的是另一个处理器</value>
  </data>
  <data name="MethodSupportsCancellation" xml:space="preserve">
    <value>方法支持取消</value>
  </data>
  <data name="CompilerWarning_CS8785_Title" xml:space="preserve">
    <value>生成器无法生成源。</value>
  </data>
  <data name="DuplicatedSequentialIfBodiesMessage" xml:space="preserve">
    <value>重复的 'if' 分支</value>
  </data>
  <data name="UseDeconstruction" xml:space="preserve">
    <value>使用析构</value>
  </data>
  <data name="ReturnValueOrOutParametersOfMethodAnnotatedWithMustUseReturnValueAttributeIsNotUsed" xml:space="preserve">
    <value>带有 [{1}] 特性注解的方法的返回值和 '{0}' 形参均未使用</value>
  </data>
  <data name="IsNotAValidParameterNameFromMessage" xml:space="preserve">
    <value>'{0}' 不是来自 '{1}' 的有效形参名称</value>
  </data>
  <data name="ALambdaExpressionWithAttributesCannotBeConvertedToAnExpressionTreeMessage" xml:space="preserve">
    <value>具有特性的 lambda 表达式不能转换为表达式树</value>
  </data>
  <data name="CSharpFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_attributes" xml:space="preserve">
    <value>特性周围</value>
  </data>
  <data name="CatchClauseIsRedundantMessage" xml:space="preserve">
    <value>catch 子句冗余</value>
  </data>
  <data name="NonPublicMemberInImplementationClassHidesDefaultImplementationInInterface" xml:space="preserve">
    <value>实现类中的非 public 成员会隐藏接口中的默认实现</value>
  </data>
  <data name="CannotRefAssignToBecauseHasANarrowerEscapeScopeThanMessage" xml:space="preserve">
    <value>不能将 '{0}' 引用赋给 '{1}'，因为 '{0}' 的转义作用域比 '{1}' 窄</value>
  </data>
  <data name="PreferRemovingRedundantCommasBefore_Caption" xml:space="preserve">
    <value>在多行列表中的新行前首选移除冗余逗号</value>
  </data>
  <data name="CannotHavePrimaryConstructorMessage" xml:space="preserve">
    <value>{0}不能有主构造函数</value>
  </data>
  <data name="AsyncIterator_Text" xml:space="preserve">
    <value>异步迭代器</value>
  </data>
  <data name="CannotCastExpressionOfTypeToTypeMessage" xml:space="preserve">
    <value>不能将 '{0}' 类型的表达式转换为 '{1}' 类型</value>
  </data>
  <data name="CSharpFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_braces" xml:space="preserve">
    <value>大括号周围</value>
  </data>
  <data name="TheEventCanOnlyAppearOnTheLeftHandSideOfOrMessage" xml:space="preserve">
    <value>事件“{0}”只能出现在 += 或 -= 的左边</value>
  </data>
  <data name="CompilerWarning_CS3013_Title" xml:space="preserve">
    <value>添加的模块必须用 CLSCompliant 特性标记才能与程序集匹配</value>
  </data>
  <data name="MethodsAccessor_RiderPresentableName" xml:space="preserve">
    <value>方法//访问器</value>
  </data>
  <data name="CompilerWarning_CS9107_Title" xml:space="preserve">
    <value>参数捕获到封闭类型状态，其值也传递给基构造函数。该值也可能由基类捕获。</value>
  </data>
  <data name="TheParameterHasCallerArgumentExpressionAttributeAppliedSoArgumentCouldBeOmittedMessage" xml:space="preserve">
    <value>形参 '{0}' 应用了 'CallerArgumentExpression' 特性，因此可以省略实参</value>
  </data>
  <data name="SimilarAnonymousTypeDetectedNearbyAreTheyTheSameMessage" xml:space="preserve">
    <value>附近检测到类似的匿名类型。它们相同吗?</value>
  </data>
  <data name="TheGivenExpressionOfisOperatorIsNeverOfTheProvidedType31" xml:space="preserve">
    <value>'is' 运算符的表达式从不为提供的类型</value>
  </data>
  <data name="NullnessAnnotationConflictWithJetBrainsAnnotationsTitle" xml:space="preserve">
    <value>为 null 性与层次结构中的注解冲突</value>
  </data>
  <data name="InterceptsLocationHint_SubmenuName" xml:space="preserve">
    <value>拦截位置</value>
  </data>
  <data name="MergeConditionalExpressionMessage" xml:space="preserve">
    <value>合并条件表达式</value>
  </data>
  <data name="CallToBaseMemberWithImplicitDefaultParametersMessage" xml:space="preserve">
    <value>使用隐式默认形参调用基成员</value>
  </data>
  <data name="RequiredMemberCannotBeLessVisibleThanContainingTypeMessage" xml:space="preserve">
    <value>必需成员 '{0}' 的可见性或具有的 setter 的可见性不能低于包含类型 '{1}' 的可见性</value>
  </data>
  <data name="NullSuppressionOperatorMightBeConfusedWithAnInvertedisExpressionMessage" xml:space="preserve">
    <value>Null 禁止运算符可能与反转的 'is' 表达式混淆</value>
  </data>
  <data name="UseUtf8StringLiteralForCollectionExpressionMessage" xml:space="preserve">
    <value>集合表达式可以转换为 UTF-8 字符串字面量</value>
  </data>
  <data name="ADefaultLiteraldefaultIsNotValidAsAPatternUseAnotherLiteralEGOrnullAsAppropriateToMatchEverythingUseADiscardPatternMessage" xml:space="preserve">
    <value>默认字面量 'default' 作为模式无效。请相应使用其他文本(例如 "0" 或 "null")。要匹配一切项，请使用弃元模式 "_"。</value>
  </data>
  <data name="ExpectedMessage" xml:space="preserve">
    <value>预期{0}</value>
  </data>
  <data name="OperatorCannotBeCheckedMessage" xml:space="preserve">
    <value>用户定义的运算符 '{0}' 不能被声明为 checked</value>
  </data>
  <data name="MergeIntoPatternMessage" xml:space="preserve">
    <value>合并到模式中</value>
  </data>
  <data name="InterceptorMustHaveMatchingThisParameterMessage" xml:space="preserve">
    <value>拦截器 '{0}' 必须具有与 '{3}' 上的形参 '{1}{2} this' 匹配的 'this' 形参</value>
  </data>
  <data name="InvalidModifierInLocalFunctionDeclarationMessage" xml:space="preserve">
    <value>局部函数声明中的修饰符 '{0}' 无效</value>
  </data>
  <data name="AnInParameterCannotHaveTheOutAttributeMessage" xml:space="preserve">
    <value>in 参数不能具有 Out 特性</value>
  </data>
  <data name="IsSpecifiedSeveralTimesInTypeParameterConstraintMessage" xml:space="preserve">
    <value>在类型形参约束中多次指定了{0} '{1}'</value>
  </data>
  <data name="LocalVariableHasTooWideDeclarationScope" xml:space="preserve">
    <value>局部变量具有过大的声明作用域</value>
  </data>
  <data name="NonPublicCannotImplementFromInterfaceMessage" xml:space="preserve">
    <value>非 public {0} '{1}' 不能从接口{2}实现{0}</value>
  </data>
  <data name="CannotSpecifyADefaultValueForThethisParameterMessage" xml:space="preserve">
    <value>不能为 "this" 参数指定默认值</value>
  </data>
  <data name="AccessibilityModifiersMayNotBeUsedOnAccessorsInAnInterfaceMessage" xml:space="preserve">
    <value>可访问性修饰符不能用于接口中的访问器</value>
  </data>
  <data name="CompilerWarning_CS8961_Title" xml:space="preserve">
    <value>CallerArgumentExpressionAttribute 将不起任何作用；它由 CallerFilePathAttribute 替代</value>
  </data>
  <data name="ScopedNameDisallowedMessage" xml:space="preserve">
    <value>类型和别名不能被命名为 'scoped'</value>
  </data>
  <data name="IntegerValueAssignedToThisEntityDoesntLieInTheIntervalSpecifiedInTheAttribute" xml:space="preserve">
    <value>赋给此实体的整数值不位于特性中指定的间隔内</value>
  </data>
  <data name="CommentsDocCommentsAttributeValue_RiderPresentableName" xml:space="preserve">
    <value>注释//文档注释//特性值</value>
  </data>
  <data name="LoopControlVariableIsNeverChangedInsideLoopMessage" xml:space="preserve">
    <value>循环控制变量在循环内从未更改过</value>
  </data>
  <data name="SpecificationOfMethodTypeArgumentsIsRedundantBecauseTheyAreInferredFromArgumentTypes" xml:space="preserve">
    <value>方法类型实参规范冗余，因为它们是从实参类型推断得出的</value>
  </data>
  <data name="NameSensitiveDescription" xml:space="preserve">
    <value>在对经典扩展方法进行分组时，请考虑扩展形参的名称。具有不同扩展形参名称的方法将放在单独的扩展块中。</value>
  </data>
  <data name="CannotApplyOperatorToOperandOfTypeMessage" xml:space="preserve">
    <value>不能将运算符 '{0}' 应用于 '{1}' 类型的操作数</value>
  </data>
  <data name="NullabilityOfReferenceTypesInReturnTypeOfDoesntMatchOverriddenMemberMessage" xml:space="preserve">
    <value>返回值类型 {0} 中引用类型的为 null 性与被重写的成员 '{1}' 不匹配</value>
  </data>
  <data name="AssignmentInsteadOfDiscardDescription" xml:space="preserve">
    <value>报告看起来像弃元模式但实际上分配了一个具有类似弃元名称 '_' 的局部变量的表达式</value>
  </data>
  <data name="AnExpressionTreeMayNotContainATupleOrOperatorMessage" xml:space="preserve">
    <value>表达式树不能包含元组 == 或 != 运算符</value>
  </data>
  <data name="FieldHidesPropertyWithDefaultImplementationInInterfaceMessage" xml:space="preserve">
    <value>字段 '{0}' 会隐藏接口{1}中具有默认实现的属性</value>
  </data>
  <data name="TypePatternInSwitchCaseLabelCanBeMergedWithDirectCastSInSwitchSection" xml:space="preserve">
    <value>可以将 switch case 标签中的类型模式与 'switch' 部分中的直接转换合并</value>
  </data>
  <data name="TypeIsNotAValidWinRTTypeMessage" xml:space="preserve">
    <value>类型 '{0}' 不是有效的 WinRT 类型</value>
  </data>
  <data name="CannotSpecifyBothReferenceAndValueTypeConstraintMessage" xml:space="preserve">
    <value>不能同时指定引用和值类型约束</value>
  </data>
  <data name="UseNameofExpressionToReferenceEnumMemberNameMessage" xml:space="preserve">
    <value>使用 '{0}' 表达式引用 '{1}.{2}' 名称</value>
  </data>
  <data name="ThereIsNoSuitableForOverrideMessage" xml:space="preserve">
    <value>没有要重写的合适{0}</value>
  </data>
  <data name="InputStringInContractAnnotationAttributeCouldntBeParsed" xml:space="preserve">
    <value>无法解析 ContractAnnotation 特性中的输入字符串</value>
  </data>
  <data name="VoidMethodWithMustDisposeResourceAttributeTitle" xml:space="preserve">
    <value>'void' 方法使用 [MustDisposeResource] 特性注解</value>
  </data>
  <data name="CannotCreateAnInstanceOfTheStaticClassMessage" xml:space="preserve">
    <value>无法创建静态类“{0}”的实例</value>
  </data>
  <data name="InvalidScopedLocalTypeOrReferenceKindMessage" xml:space="preserve">
    <value>'scoped' 修饰符只能用于 refs 和 ref 结构值</value>
  </data>
  <data name="InternalModifierCanBeSafelyAddedRemoved_Text" xml:space="preserve">
    <value>可以安全地在类型中添加/移除 'internal' 修饰符，而不更改代码语义</value>
  </data>
  <data name="CompilerWarning_CS8886_Title" xml:space="preserve">
    <value>使用未赋值的 out 参数</value>
  </data>
  <data name="ListPatternRequiresSystemIndexIndexerMessage" xml:space="preserve">
    <value>列表模式不能用于 '{0}' 类型的值。找不到合适的条目索引器。</value>
  </data>
  <data name="RequiredMemberCannotBeHiddenMessage" xml:space="preserve">
    <value>必需成员 '{0}' 不能被 '{1}' 隐藏</value>
  </data>
  <data name="PossibleIncorrectImplementationOfDoubleCheckLockingPatternReadAccessToCheckedField19" xml:space="preserve">
    <value>可能错误地实现了双重检查锁定模式。请对checked 字段进行读取访问。</value>
  </data>
  <data name="ReturnTypeOfAFunctionCanBeNonNullableSettingSuggestChangesInVirtualMembersDescription" xml:space="preserve">
    <value>配置是否报告 virtual 成员中不可以为 null 的返回值类型。如果 virtual 成员应在不属于当前解决方案的外部代码中具有重写，则无法验证此类重写是否也可以更新为返回不可以为 null 的值。在这种情况下，设置可用于禁止检查。</value>
  </data>
  <data name="CompilerWarning_CS9021_Title" xml:space="preserve">
    <value>在显式分配自动实现的属性之前，将向调用方返回控件，从而导致前面隐式分配了'default'。</value>
  </data>
  <data name="Thread_Executes_TakesLocks_Text" xml:space="preserve">
    <value>- 线程 #{0} 执行 '{1}'，获取锁</value>
  </data>
  <data name="WinRTConstructorCannotBeProtectedMessage" xml:space="preserve">
    <value>WinRT 构造函数不能为 protected</value>
  </data>
  <data name="CompilerWarning_CS8847_Title" xml:space="preserve">
    <value>Switch 表达式不会处理某些为 null 的输入。</value>
  </data>
  <data name="CannotSpecifyBothReferenceAndUnmanagedTypeConstraintMessage" xml:space="preserve">
    <value>不能同时指定引用和非托管类型约束</value>
  </data>
  <data name="RedundantNullableAnnotationOnBaseTypeConstraintOfTypeParameterHavingNonNullableTypeKind" xml:space="preserve">
    <value>具有不可以为 null 的类型的类型形参的基类型约束上存在冗余的可以为 null 的注解</value>
  </data>
  <data name="TheBodyOfAnAsyncIteratorMethodMustContainAyieldStatementMessage" xml:space="preserve">
    <value>异步迭代器方法的主体必须包含 'yield' 语句</value>
  </data>
  <data name="sealedModifierIsRedundantBecauseIsSealedMessage" xml:space="preserve">
    <value>'sealed' 修饰符冗余，因为{0} '{1}' 为 sealed</value>
  </data>
  <data name="ImplicitJumpBeforeLocalFunctionHintCommentText" xml:space="preserve">
    <value>局部函数</value>
  </data>
  <data name="CannotConvertStaticExtensionQualifierType_To_Text" xml:space="preserve">
    <value>无法将限定符类型 '{0}' 转换为扩展接收器类型 '{1}'</value>
  </data>
  <data name="ReplaceEnumerableCountInvocationWithCollectionCountPropertyAccessMessage" xml:space="preserve">
    <value>将 'Enumerable.Count()' 调用替换为集合计数属性访问</value>
  </data>
  <data name="ReturnValueOfMethodIsNotUsedJustificationMessage" xml:space="preserve">
    <value>方法的返回值未使用。{0}</value>
  </data>
  <data name="TurnOffInferredDiscardNamesInlayHint_Text" xml:space="preserve">
    <value>隐藏舍弃值的推断名称</value>
  </data>
  <data name="CompilerWarning_CS0440_Title" xml:space="preserve">
    <value>定义名为 "global" 的别名是欠妥的</value>
  </data>
  <data name="trueIsRedundantAsforStatementCondition" xml:space="preserve">
    <value>'true' 作为 'for' 语句条件冗余</value>
  </data>
  <data name="ConvertingLockMessage" xml:space="preserve">
    <value>转换为其他类型后，'System.Threading.Lock' 类型的值将在 'lock' 语句中使用可能意想不到的基于监视器的锁定</value>
  </data>
  <data name="FieldOffsetAttributeOnNonExplicitLayoutTypeMessage" xml:space="preserve">
    <value>'[FieldOffset]' 特性只能放置在标记为 '[StructLayout(LayoutKind.Explicit)]' 的类型的成员上</value>
  </data>
  <data name="ParameterModifierthisShouldBeOnTheFirstParameterMessage" xml:space="preserve">
    <value>形参修饰符 'this' 应在第一个形参上</value>
  </data>
  <data name="ConvertAsExpressionTypeCheckAndTheFollowingNullCheckIntoPatternMatching" xml:space="preserve">
    <value>将 'as' 表达式类型检查以及后续的 null 检查转换为模式匹配</value>
  </data>
  <data name="RedundantSpreadElementTitle" xml:space="preserve">
    <value>冗余的 spread 元素</value>
  </data>
  <data name="CompilerWarning_CS3027_Title" xml:space="preserve">
    <value>类型不符合 CLS，因为基接口不符合 CLS</value>
  </data>
  <data name="TypeIsEitherMentionedInTheBaseTypesListOfOtherPartOrItIsInterfaceAndAppearsAsOthersTypeBaseAndContainsNoExplicitImplementations" xml:space="preserve">
    <value>类型在其他部分的基类型列表中被提及，或者它是一个接口，显示为其他类型的基，不包含显式实现</value>
  </data>
  <data name="CollectionExpressionFoundNotAccessibleAddMethod_Text" xml:space="preserve">
    <value>无法从此处访问集合表达式 'Add' 方法的最佳候选 '{0}'</value>
  </data>
  <data name="StringsEscapeCharacter_RiderPresentableName" xml:space="preserve">
    <value>字符串//转义字符 1</value>
  </data>
  <data name="CompilerWarning_CS1658_Title" xml:space="preserve">
    <value>警告正在重写错误</value>
  </data>
  <data name="ConvertIfStatementToSwitch" xml:space="preserve">
    <value>将 'if' 语句转换为 'switch'</value>
  </data>
  <data name="Namespaces_Caption" xml:space="preserve">
    <value>命名空间</value>
  </data>
  <data name="ReadonlyField_Text" xml:space="preserve">
    <value>'readonly' 字段</value>
  </data>
  <data name="NullabilityOfReferenceTypesInTypeOfParameterDoesntMatchImplementedMemberMessage" xml:space="preserve">
    <value>形参 '{0}' 的类型中引用类型的为 null 性与被实现的成员 '{1}' 不匹配</value>
  </data>
  <data name="MissingUnmanagedKeyword_ToolTip" xml:space="preserve">
    <value>缺少 'unmanaged' 关键字</value>
  </data>
  <data name="FixedSizeBufferCanOnlyBeAccessedThroughLocalVariableParameterOrFieldMessage" xml:space="preserve">
    <value>只能通过局部变量、形参或字段访问固定大小的缓冲区</value>
  </data>
  <data name="OnlyNonNullableValueTypeCouldBeUnderlyingOfSystemNullableMessage" xml:space="preserve">
    <value>'System.Nullable' 的基础只能是不可以为 null 的值类型</value>
  </data>
  <data name="ConflictingStaticExtensionTypeArgumentErrorMessage" xml:space="preserve">
    <value>扩展 {1} 的类型形参 {0} 的类型实参有冲突:</value>
  </data>
  <data name="ConditionalAccessExpressionIsNotClassifiedAsAVariableMessage" xml:space="preserve">
    <value>条件访问表达式未被分类为变量</value>
  </data>
  <data name="ReplacePropertyPatternMemberSOfRecursivePatternWithPositionalDeconstructionPatterns" xml:space="preserve">
    <value>将递归模式的属性模式成员替换为位置析构模式</value>
  </data>
  <data name="EmptyExtensionBlockDescription" xml:space="preserve">
    <value>extension 块为空，可以安全地移除</value>
  </data>
  <data name="LocalFunctionMustBestaticInOrderToUseTheConditionalAttributeMessage" xml:space="preserve">
    <value>本地函数“{0}”必须为 "static" 才能使用 "Conditional" 特性</value>
  </data>
  <data name="HeuristicallyUnreachableSwitchArmDueToIntegerAnalysis" xml:space="preserve">
    <value>由于整数分析而启发式无法访问的 switch arm</value>
  </data>
  <data name="MethodsMethod_RiderPresentableName" xml:space="preserve">
    <value>方法//方法</value>
  </data>
  <data name="CompilerWarning_CS8622_Title" xml:space="preserve">
    <value>参数类型中引用类型的为 Null 性与目标委托不匹配(可能是由于为 Null 性特性)。</value>
  </data>
  <data name="DuplicateTypeParameterNameMessage" xml:space="preserve">
    <value>重复的类型形参名称</value>
  </data>
  <data name="ArrayElementsCannotBeOfStaticClassTypeMessage7" xml:space="preserve">
    <value>'{0}': 数组元素不能为 static 类类型</value>
  </data>
  <data name="VariableResultedFromAccessingElement_Text" xml:space="preserve">
    <value>访问{0} '{1}' 的元素生成的变量</value>
  </data>
  <data name="CannotConvertElementType_ToIterator_Text" xml:space="preserve">
    <value>不能将元素类型 '{0}' 转换为迭代器类型 '{1}'</value>
  </data>
  <data name="MoveLocalFunctionAfterJumpStatement_SuggestInNestedScopes_Title" xml:space="preserve">
    <value>建议在以跳转语句结尾的嵌套作用域中使用</value>
  </data>
  <data name="ExplicitCallToTheBaseClassConstructorWithNoArgumentsIsGeneratedByTheCompilerByDefaultAndCanBeOmitted" xml:space="preserve">
    <value>不带实参的基类构造函数的显式调用。默认情况下，它由编译器生成，可以省略。</value>
  </data>
  <data name="UseObjectInitializerMessage" xml:space="preserve">
    <value>使用对象初始值设定项</value>
  </data>
  <data name="CannotUseTypeInASignatureOfMethodAttributedWithUnmanagedCallersOnlyMessage" xml:space="preserve">
    <value>不能在具有 'UnmanagedCallersOnly' 特性的方法签名中使用 '{0}' 类型</value>
  </data>
  <data name="CompilerWarning_CS1645_Title" xml:space="preserve">
    <value>功能不是标准化 ISO C# 语言规范的一部分，其他编译器可能不接受它</value>
  </data>
  <data name="RedundantstringToCharArrayCall6" xml:space="preserve">
    <value>冗余的 'string.ToCharArray()' 调用</value>
  </data>
  <data name="AutoPropertyMustOverrideAllAccessorsOfTheOverriddenPropertyMessage" xml:space="preserve">
    <value>自动属性必须重写被重写属性的所有访问器</value>
  </data>
  <data name="RedundantParenthesesMessage" xml:space="preserve">
    <value>冗余的圆括号</value>
  </data>
  <data name="Preview_Text" xml:space="preserve">
    <value>'preview'</value>
  </data>
  <data name="CompilerWarning_CS8616_Title" xml:space="preserve">
    <value>返回类型中引用类型的为 Null 性与实现的成员不匹配。</value>
  </data>
  <data name="FloatingPointConstantIsOutsideTheRangeOfTypeMessage" xml:space="preserve">
    <value>浮点常量超出“{0}”类型的范围</value>
  </data>
  <data name="TheAccessibilityModifierOfTheAccessorMustBeMoreRestrictiveThanTheMessage" xml:space="preserve">
    <value>访问器的可访问性修饰符必须比{0} '{1}' 更严格</value>
  </data>
  <data name="ADeclarationOfAByReferenceVariableMustHaveAnInitializerMessage" xml:space="preserve">
    <value>按引用变量的声明必须有初始值设定项</value>
  </data>
  <data name="ThePointerTypeMayNotBeUsedForAFieldAutoPropertyOfARecordMessage" xml:space="preserve">
    <value>指针类型 '{0}' 不能用于记录的字段/自动属性</value>
  </data>
  <data name="WinRTDoesNotSupportIndexersMessage" xml:space="preserve">
    <value>WinRT 不支持索引器</value>
  </data>
  <data name="FileLocalTypeAsBaseTypeMessage" xml:space="preserve">
    <value>file-local 类型 '{0}' 不能用作非 file-local 类型 '{1}' 的基类型</value>
  </data>
  <data name="Nullable_Text" xml:space="preserve">
    <value>可以为 null</value>
  </data>
  <data name="UseForEachVariableMessage" xml:space="preserve">
    <value>为每个变量使用{0}</value>
  </data>
  <data name="DoesNotOverrideExpectedMethodFromobjectMessage" xml:space="preserve">
    <value>'{0}' 不从 'object' 重写预期方法</value>
  </data>
  <data name="NullabilityOfReferenceTypesInReturnTypeDoesntMatchPartialMemberDeclarationMessage" xml:space="preserve">
    <value>此{0}的声明部分在引用类型的可为 null 性上存在差异</value>
  </data>
  <data name="ReplaceIfStatementWithNullPropagatingCode" xml:space="preserve">
    <value>将 if 语句替换为 null 传播代码</value>
  </data>
  <data name="WinRTDoesNotSupportOperatorOverloadsMessage" xml:space="preserve">
    <value>WinRT 不支持运算符重载</value>
  </data>
  <data name="UsageOfEnumerableContainsExtensionMethodWillPerformALinearSearchConsiderProvidingEqualityComparerToTheSetsConstructorAndUsingItsOwnContainsMethod" xml:space="preserve">
    <value>'Enumerable.Contains' 扩展方法的用法将执行线性搜索。
          请考虑为 set 的构造函数提供相等比较器并使用其自己的 '.Contains' 方法。</value>
  </data>
  <data name="TypeCannotBeUsedInThisContextBecauseItCannotBeRepresentedInMetadataMessage" xml:space="preserve">
    <value>类型 '{0}' 不能用于此上下文，因为它不能在元数据中表示</value>
  </data>
  <data name="UsePreferredArgumentStyleForAnonymousFunctions" xml:space="preserve">
    <value>对匿名函数使用首选实参样式</value>
  </data>
  <data name="CompilerWarning_CS0419_Title" xml:space="preserve">
    <value>cref 特性中有不明确的引用</value>
  </data>
  <data name="EnforceBracesInIfElseStatement_Caption" xml:space="preserve">
    <value>在 'if-else' 语句中强制使用大括号</value>
  </data>
  <data name="TypeSystemRangeIsNotResolvedMessage" xml:space="preserve">
    <value>类型 'System.Range' 未被解析</value>
  </data>
  <data name="TheFollowingShouldBeAssignedUponExit_Text" xml:space="preserve">
    <value>退出时应为以下符号赋值:</value>
  </data>
  <data name="TypeMemberIsInferredToBeNullable" xml:space="preserve">
    <value>类型成员被推断为可以为 null 的</value>
  </data>
  <data name="RedundantDictionaryContainsKeyBeforeAddingTitle" xml:space="preserve">
    <value>在将条目添加到字典之前，'ContainsKey' 调用冗余</value>
  </data>
  <data name="CannotCreateAFunctionPointerForBecauseItIsNotAStaticMethodMessage" xml:space="preserve">
    <value>无法为“{0}”创建函数指针，因为它不是静态方法</value>
  </data>
  <data name="TestingAgainstTrueIsRedundantMessage" xml:space="preserve">
    <value>针对 '{0}' 的测试冗余</value>
  </data>
  <data name="CannotSpecifyBothAConstraintClassAndAllowsRefStructConstraintMessage" xml:space="preserve">
    <value>不能同时指定约束类和 'allows ref struct' 约束</value>
  </data>
  <data name="NullabilityOfReferenceTypesInTypeOfParameterDoesntMatchImplicitlyImplementedMemberMessage" xml:space="preserve">
    <value>形参 '{0}' 的类型中引用类型的为 null 性与隐式实现的成员 '{1}' 不匹配</value>
  </data>
  <data name="UseRawStringMessage" xml:space="preserve">
    <value>使用原始字符串</value>
  </data>
  <data name="PossibleOverflowInCheckedContextMessage" xml:space="preserve">
    <value>在 checked 上下文中可能溢出</value>
  </data>
  <data name="InvalidEmbeddedStatementMessage" xml:space="preserve">
    <value>嵌入式语句无效</value>
  </data>
  <data name="PatternTypeSpecificationIsRedundantMessage" xml:space="preserve">
    <value>模式类型规范冗余</value>
  </data>
  <data name="BracesAndOperatorsBrackets_RiderPresentableName" xml:space="preserve">
    <value>大括号和运算符//中括号</value>
  </data>
  <data name="ChangeFieldTypeToSystemThreadingLockMessage" xml:space="preserve">
    <value>考虑将 '{0}' 字段的类型更改为 '{1}' 以表达字段意图</value>
  </data>
  <data name="PossiblyMistakenUseOfCancellationTokenMessage_AdditionMultipleSameType" xml:space="preserve">
    <value>包含{0}声明以下 '{1}' 变量:</value>
  </data>
  <data name="refStructsCannotImplementInterfacesMessage" xml:space="preserve">
    <value>'ref' 结构不能实现接口</value>
  </data>
  <data name="yieldStatementCannotAppearInfinallyBlockMessage" xml:space="preserve">
    <value>'yield' 语句不能出现在 'finally' 块中</value>
  </data>
  <data name="UserDefinedConversionFromSystemObjectMessage" xml:space="preserve">
    <value>从 System.Object 的用户定义转换</value>
  </data>
  <data name="_11OrGreater_Text" xml:space="preserve">
    <value>11.0 或更高</value>
  </data>
  <data name="LineDirectiveFileNameExpectedMessage" xml:space="preserve">
    <value>应是引用的文件名</value>
  </data>
  <data name="CSharp14OverloadResolutionWithSpanBreakingChangeTitle" xml:space="preserve">
    <value>C# 14 在带有跨度形参的重载解析中的重大变化</value>
  </data>
  <data name="OperationIsInvalidOnVoidPointerMessage" xml:space="preserve">
    <value>运算对 void 指针无效</value>
  </data>
  <data name="thisParameterDeclarationCouldBeOnStaticMethodsOnlyMessage" xml:space="preserve">
    <value>'this' 形参声明只能在 static 方法上</value>
  </data>
  <data name="RedundantNullableAnnotationOnBaseTypeConstraintOfTypeParameterConstrainedByAnotherNonNullableBaseType" xml:space="preserve">
    <value>受另一个不可以为 null 的基类型约束的类型形参的基类型约束上存在冗余的可以为 null 的注解</value>
  </data>
  <data name="EntityFramework_ModelCircularDependencyHighlighting_Description_Text" xml:space="preserve">
    <value>报告可能导致创建依赖关系循环的实体属性</value>
  </data>
  <data name="RemoveSealedModifierOrMakeConstructorPublicOrInternal" xml:space="preserve">
    <value>移除 'sealed' 修饰符或将构造函数设为 public 或 internal</value>
  </data>
  <data name="InconsistentAccessibilityTypeArgumentIsLessAccessibleThanMessage" xml:space="preserve">
    <value>可访问性不一致: 类型实参 '{0}' 的可访问性低于{1} '{2}'</value>
  </data>
  <data name="AddOrRemoveTrailingCommaWhenTheLastElementIsNotFollowedByANewLineAccordingToTheSelectedCodeStyle" xml:space="preserve">
    <value>根据代码样式设置，当最后一个元素后面没有新行时添加或移除尾随逗号</value>
  </data>
  <data name="DuplicatedSwitchExpressionArmsDescription" xml:space="preserve">
    <value>重复的 'switch' arm。考虑将它们合并成一个单独的 arm，以提高可读性和减少代码重复。</value>
  </data>
  <data name="UnmatchedDirectiveMessage" xml:space="preserve">
    <value>不匹配的 #{0} 指令</value>
  </data>
  <data name="PatternCheckAlwaysGivesTheSameResult" xml:space="preserve">
    <value>模式检查结果始终相同</value>
  </data>
  <data name="OneOfTheParametersOfABinaryOperatorMustBeTheContainingTypeOrItsTypeParameterConstrainedToItMessage" xml:space="preserve">
    <value>二进制运算符的其中一个形参必须为包含类型，或其约束的类型形参</value>
  </data>
  <data name="ReturnTypeOfAFunctionCanBeNonNullable" xml:space="preserve">
    <value>函数的返回值类型可以设为不可为 null</value>
  </data>
  <data name="ShouldNotHaveAParamsParameterSinceDoesNotMessage" xml:space="preserve">
    <value>'{0}' 不得具有 params 形参，因为 '{1}' 没有</value>
  </data>
  <data name="RedundantNullableAttribute" xml:space="preserve">
    <value>冗余的可以为 null 的特性</value>
  </data>
  <data name="MemberNamesCannotBeTheSameAsTheirEnclosingTypeMessage" xml:space="preserve">
    <value>成员名称不能与其封闭类型相同</value>
  </data>
  <data name="RedundantMethodOverloadMessage" xml:space="preserve">
    <value>冗余的方法重载</value>
  </data>
  <data name="OperatorCannotHaveparamsParameterMessage" xml:space="preserve">
    <value>运算符不能有 'params' 形参</value>
  </data>
  <data name="CallToNonReadonlyFromAreadonlyMemberResultsInAnImplicitCopyOfthisMessage" xml:space="preserve">
    <value>从 'readonly' 成员调用非只读{0}会导致 'this' 的隐式副本</value>
  </data>
  <data name="ConvertIfDeclarationIsNotOfBuiltInOr_Text" xml:space="preserve">
    <value>如果声明不是内置类型或简单类型并且无法从用法明显看出，则转换</value>
  </data>
  <data name="UnmanagedCallersOnlyCanOnlyBeAppliedToOrdinaryStaticMethodsOrStaticLocalFunctionsMessage" xml:space="preserve">
    <value>"UnmanagedCallersOnly" 仅可应用于普通静态方法或静态本地函数</value>
  </data>
  <data name="PossiblyUnintendedSideEffectsInsideConditionalInvocationDescription" xml:space="preserve">
    <value>当条件调用在某些构建配置中未执行时，将跳过外部可见的修改</value>
  </data>
  <data name="MakeClassStatic" xml:space="preserve">
    <value>将类设为 static</value>
  </data>
  <data name="SuspiciousvolatileFieldUsageCompoundOperationIsNotAtomicInterlockedClassCanBeUsedInsteadMessage" xml:space="preserve">
    <value>可疑的 'volatile' 字段用法: 复合操作不是原子操作。可以改用 'Interlocked' 类。</value>
  </data>
  <data name="FormattingIsSpecifiedButInterpolatedStringExpressionIsNotIFormattable" xml:space="preserve">
    <value>已指定格式设置，但内插字符串表达式不是 IFormattable</value>
  </data>
  <data name="ComparingWithNullOfTypeAlwaysProducesfalseMessage" xml:space="preserve">
    <value>与 '{0}' 类型的 null 比较始终产生 'false'</value>
  </data>
  <data name="PossibleCastExpressionOfIncompatibleType" xml:space="preserve">
    <value>不兼容类型的可能的转换表达式</value>
  </data>
  <data name="CompilerWarning_CS8524_Title" xml:space="preserve">
    <value>switch 表达式不会处理其输入类型的某些值(它不是穷举)，这包括未命名的枚举值。</value>
  </data>
  <data name="AddOrRemoveExplicitTypeSpecification_Text" xml:space="preserve">
    <value>添加或移除显式类型规范</value>
  </data>
  <data name="ConvertLambdaExpressionToMethodGroup" xml:space="preserve">
    <value>将 lambda 表达式转换为方法组</value>
  </data>
  <data name="ReplaceIfStatementWithNullPropagatingCodeWhenPossible" xml:space="preserve">
    <value>将 if 语句替换为 null 传播代码(如果可能)</value>
  </data>
  <data name="CompilerWarning_CS8974_Title" xml:space="preserve">
    <value>将方法组转换为非委托类型</value>
  </data>
  <data name="ReturnOfUsingVariableDescription" xml:space="preserve">
    <value>不返回 'using' 语句捕获的变量，因为它会在返回之前被处置</value>
  </data>
  <data name="CompilerWarning_CS8629_Title" xml:space="preserve">
    <value>可为 null 的值类型可为 null。</value>
  </data>
  <data name="UsePreferredStyleForDiscardDeclaration" xml:space="preserve">
    <value>对弃元声明使用首选样式</value>
  </data>
  <data name="OnlyRecordsMayInheritFromRecordsMessage" xml:space="preserve">
    <value>只能从记录继承记录</value>
  </data>
  <data name="RedundantreadonlyModifier" xml:space="preserve">
    <value>冗余的 'readonly' 修饰符</value>
  </data>
  <data name="RedundantImmediateDelegateInvocationMessage" xml:space="preserve">
    <value>冗余的即时委托调用</value>
  </data>
  <data name="SeparateLocalFunctionsWithJumpStatementDescription" xml:space="preserve">
    <value>在块末尾使用显式 'return' 或 'continue' 分隔局部函数。这将帮助读者了解方法或循环的真正结束位置，而无需检查局部函数之后或之间是否存在任何可执行代码。</value>
  </data>
  <data name="WinRTTypeShouldBeSealedMessage" xml:space="preserve">
    <value>WinRT 类型应为 sealed</value>
  </data>
  <data name="BaseTypeIsRequired" xml:space="preserve">
    <value>基类型为必填项</value>
  </data>
  <data name="CannotUseAResultOfInThisContextBecauseItMayExposeVariablesReferencedByItsArgumentOutsideOfTheirDeclarationScopeMessage" xml:space="preserve">
    <value>不能在此上下文中使用 '{0}' 的结果，因为它可能会在声明作用域以外公开其实参引用的变量</value>
  </data>
  <data name="ConvertLambdaExpressionOrAnonymousMethodToMethodGroup" xml:space="preserve">
    <value>将 lambda 表达式或匿名方法转换为方法组</value>
  </data>
  <data name="CannotAssignToAnonymousTypePropertyMessage" xml:space="preserve">
    <value>无法将“{0}”分配给匿名类型属性</value>
  </data>
  <data name="CompilerWarning_CS0114_Title" xml:space="preserve">
    <value>成员隐藏继承的成员；缺少关键字 override</value>
  </data>
  <data name="ReturnType_Text" xml:space="preserve">
    <value>返回值类型</value>
  </data>
  <data name="PossiblyMissingCommaBeforeIndexerInitializer" xml:space="preserve">
    <value>索引器初始值设定项之前可能缺少逗号</value>
  </data>
  <data name="UnsafeContextDeclarationIsRedundantBecauseItIsDeclaredInUnsafeContextOrItDoesntContainUnsafeConstructs" xml:space="preserve">
    <value>unsafe 上下文声明冗余，因为它是在 unsafe 上下文中声明的，或者它不包含 unsafe 构造</value>
  </data>
  <data name="StaticMemberInitializerRefersToStaticMemberBelowOrInOtherPart" xml:space="preserve">
    <value>static 成员初始值设定项引用以下或其他部分中的 static 成员</value>
  </data>
  <data name="NonNullableBackingFieldIsUninitializedInConstructorConsiderDeclaringTheAsNullableOrUseAttributesMessage" xml:space="preserve">
    <value>在退出构造函数时，不可为 null 的 {0}“{1}”必须包含非 null 值。请考虑添加 '{2}' 修饰符或将{0}声明为可以为 null{3}。</value>
  </data>
  <data name="MethodReturnType_Text" xml:space="preserve">
    <value>方法返回值类型</value>
  </data>
  <data name="TheswitchExpressionMustBeAValueFoundMessage" xml:space="preserve">
    <value>'switch' 表达式必须为值；实际为 '{0}'</value>
  </data>
  <data name="InvalidRealLiteralMessage" xml:space="preserve">
    <value>无效的实数字面量</value>
  </data>
  <data name="AddInterceptorSourceGeneratorToExclusionList_Text" xml:space="preserve">
    <value>对 '{0}' 拦截的调用隐藏</value>
  </data>
  <data name="CannotChooseMethodFromMethodGroupDidYouIntendToInvokeTheMethodMessage" xml:space="preserve">
    <value>不能从方法组中选择方法。您是想调用该方法吗?</value>
  </data>
  <data name="TheSecondOperandOfAnisOrasOperatorMayNotBeStaticTypeMessage" xml:space="preserve">
    <value>'is' 或 'as' 运算符的第二个操作数不能为 static 类型 '{0}'</value>
  </data>
  <data name="AccessToForeachVariableInClosure" xml:space="preserve">
    <value>访问闭包中的 foreach 变量</value>
  </data>
  <data name="MarkingMethodAsOperationContractWithoutServiceContractAttributeOnTheContainingTypeCouldCauseRuntimeException" xml:space="preserve">
    <value>在包含类型上没有 ServiceContract 特性的情况下将方法设为 OperationContract 可能会导致运行时异常</value>
  </data>
  <data name="RedundantExplicitArrayTypeSpecificationMessage" xml:space="preserve">
    <value>冗余的显式数组类型规范</value>
  </data>
  <data name="HidesInheritedAbstractMessage" xml:space="preserve">
    <value>'{0}' 会隐藏继承的 abstract {1} '{2}'</value>
  </data>
  <data name="CompilerWarning_CS0252_Title" xml:space="preserve">
    <value>可能非有意的引用比较；左侧需要强制转换</value>
  </data>
  <data name="NonNullableOrRequiredMemberIsNotInitializedAtConstructorExit" xml:space="preserve">
    <value>不可以为 null 或必需成员未在构造函数出口处初始化</value>
  </data>
  <data name="KindNameIsGetOnlyExceptIn_Text" xml:space="preserve">
    <value>{0} 为只获取(在 {1} 中除外)。</value>
  </data>
  <data name="CapturedPrimaryConstructorParameterIsMutableTitle" xml:space="preserve">
    <value>捕获的主构造函数形参可变</value>
  </data>
  <data name="ForTypeParameterClause" xml:space="preserve">
    <value>类型形参 '{0}'</value>
  </data>
  <data name="BackingFieldIsUsedButNeverAssigned" xml:space="preserve">
    <value>支持字段已被使用，但从未被赋值</value>
  </data>
  <data name="UnboxingAPossiblyNullValueMessage" xml:space="preserve">
    <value>取消装箱可能为 null 的值</value>
  </data>
  <data name="PossibleNullAssignmentToNonNullableEntity" xml:space="preserve">
    <value>可能将 'null' 赋给不可以为 null 的实体</value>
  </data>
  <data name="ParamsParameterInLambdaOnlyMessage" xml:space="preserve">
    <value>形参 {0} 在 lambda 中具有 'params' 修饰符，但在目标委托类型中没有</value>
  </data>
  <data name="PossiblyMistakenUseOfCancellationTokenMessage" xml:space="preserve">
    <value>可能错误使用了{2}的 {0} 形参 '{1}'。{3}</value>
  </data>
  <data name="CodeCleanupTask_CSMakeFieldReadonly" xml:space="preserve">
    <value>如果可能，将字段设为只读</value>
  </data>
  <data name="DeconstructionvarFormDisallowsASpecificTypeForvarMessage" xml:space="preserve">
    <value>析构 'var (...)' 表单不允许 'var' 的特定类型</value>
  </data>
  <data name="CompilerWarning_CS0469_Title" xml:space="preserve">
    <value>"goto case" 值不可隐式转换为开关类型</value>
  </data>
  <data name="NullabilityOfTypeOfParameterDoesntMatchImplicitlyImplementedMemberPossiblyBecauseOfNullabilityAttributesMessage" xml:space="preserve">
    <value>形参 '{0}' 的类型的为 null 性与隐式实现的成员 '{1}' 不匹配(可能是由于为 null 性特性)</value>
  </data>
  <data name="UseNullableAnnotationInsteadOfAnAttributeMessage" xml:space="preserve">
    <value>使用可以为 null 的注解而不是特性</value>
  </data>
  <data name="AnonymousFunction_Text" xml:space="preserve">
    <value>匿名函数</value>
  </data>
  <data name="CompilerWarning_CS9016_Title" xml:space="preserve">
    <value>使用可能未赋值的自动实现的属性。请考虑更新到语言版本以自动默认属性。</value>
  </data>
  <data name="MergeNegatedNullPatternChecksIntoComplexPattern" xml:space="preserve">
    <value>将求反的 null/模式检查合并到复杂模式中</value>
  </data>
  <data name="TheArgumentDoesntMatchTheParameterThatWasCheckedMessage" xml:space="preserve">
    <value>实参 '{0}' 与检查的形参 '{1}' 不匹配</value>
  </data>
  <data name="ReplaceTypeofTNameExpressionWithConstantNameofExpression" xml:space="preserve">
    <value>将 'typeof(T).Name' 表达式替换为常量 'nameof' 表达式</value>
  </data>
  <data name="AsyncIteratorFunctionCannotReturnByReferenceMessage" xml:space="preserve">
    <value>异步/迭代器函数不能通过引用返回</value>
  </data>
  <data name="CannotSpecifyBothValueAndUnmanagedTypeConstraintMessage" xml:space="preserve">
    <value>不能同时指定值和非托管类型约束</value>
  </data>
  <data name="_Parameter_Text" xml:space="preserve">
    <value>'{0}' 形参</value>
  </data>
  <data name="InterceptorMustReferToStartOfTokenPositionMessage" xml:space="preserve">
    <value>提供的行号和字符编号未引用令牌 '{0}' 的开头。您是要使用行 '{1}' 和字符 '{2}' 吗?</value>
  </data>
  <data name="SeparateLocalFunctionsWithJumpStatementMessage" xml:space="preserve">
    <value>使用显式 '{0}' 语句分隔局部函数</value>
  </data>
  <data name="EmptyStatementIsRedundantMessage" xml:space="preserve">
    <value>空语句冗余</value>
  </data>
  <data name="UsePreferredStyleForTrailingCommaBefore_Text" xml:space="preserve">
    <value>对多行列表中新行前的尾随逗号使用首选样式</value>
  </data>
  <data name="ConversionFromDerivedClassMessage" xml:space="preserve">
    <value>从派生类转换</value>
  </data>
  <data name="Params_Text" xml:space="preserve">
    <value>'params'</value>
  </data>
  <data name="CollectionExpressionHasBuilderAttributeWithoutIterationType_Text" xml:space="preserve">
    <value>'{0}' 具有 'CollectionBuilderAttribute'，但没有迭代器类型</value>
  </data>
  <data name="MergeSequentialChecksMessage" xml:space="preserve">
    <value>合并顺序检查</value>
  </data>
  <data name="LocalFunctionIsNeverUsedCompilerWarning" xml:space="preserve">
    <value>局部函数从未被使用(编译器警告)</value>
  </data>
  <data name="FeatureIsNotAvailablePleaseUseLanguageVersionpreviewMessage" xml:space="preserve">
    <value>功能 '{0}' 不可用。请使用语言版本 'preview'。</value>
  </data>
  <data name="InterceptedCallHints_Text" xml:space="preserve">
    <value>被拦截的调用</value>
  </data>
  <data name="CapturedReferenceTovolatileFieldWillNotBeTreatedAsvolatile6" xml:space="preserve">
    <value>捕获的对 'volatile' 字段的引用不会被视为 'volatile'</value>
  </data>
  <data name="PreferTaskMethodsOverMethodsReturningvoid" xml:space="preserve">
    <value>首选任务方法而非返回 'void' 的方法: 'async void' 方法未处理的任何异常都可能导致进程崩溃</value>
  </data>
  <data name="EmptyStatementIsRedundant" xml:space="preserve">
    <value>空语句冗余</value>
  </data>
  <data name="AbstractInheritedMemberIsMissingAccessorImplementationMessage" xml:space="preserve">
    <value>abstract 继承成员 '{0}' 缺少 {1} 访问器实现</value>
  </data>
  <data name="ParamsCollectionInfiniteChainOfAddCallsMessage" xml:space="preserve">
    <value>集合初始值设定项会导致出现集合 '{0}' 实例化的无限链</value>
  </data>
  <data name="EmptyObjectOrCollectionInitializerListIsRedundantMessage" xml:space="preserve">
    <value>空对象或集合初始值设定项列表冗余</value>
  </data>
  <data name="EmptyNamespaceDeclaration" xml:space="preserve">
    <value>空命名空间声明</value>
  </data>
  <data name="ExpressionIsAlwaysnull" xml:space="preserve">
    <value>表达式始终为 'null'</value>
  </data>
  <data name="CannotConvertToStaticTypeMessage" xml:space="preserve">
    <value>不能转换为 static 类型 '{0}'</value>
  </data>
  <data name="InterfaceCannotContainMessage" xml:space="preserve">
    <value>接口不能包含{0}</value>
  </data>
  <data name="PartsOfPartialHaveDifferentAccessibilityMessage" xml:space="preserve">
    <value>分部{0} '{1}' 的某些部分具有不同的可访问性</value>
  </data>
  <data name="TheTypeParameterMustBeNonNullableValueTypeInOrderToUseItAsUnderlyingOfSystemNullableTConsiderAddingAclassOrdefaultConstraintToAllowUsingAsANullableAnnotationMessage" xml:space="preserve">
    <value>类型形参 '{0}' 必须为不可以为 null 的值类型才能将其用作 'System.Nullable&lt;T&gt;' 的基础。请考虑添加 'class' 或 'default' 约束以允许使用 '?' 作为可以为 null 的注解。</value>
  </data>
  <data name="RecordMemberMayNotBeStaticMessage" xml:space="preserve">
    <value>记录成员 '{0}' 不能为 static</value>
  </data>
  <data name="ArrayInitializerLengthDoesntMatchTheGivenSizeMessage" xml:space="preserve">
    <value>数组初始值设定项长度与给定大小不匹配</value>
  </data>
  <data name="SimplifyIsInstanceOfTypeTitle" xml:space="preserve">
    <value>简化 'IsInstanceOfType()' 调用</value>
  </data>
  <data name="RedundantTypeArgumentsInsideNameofMessage" xml:space="preserve">
    <value>'nameof' 中的类型实参冗余</value>
  </data>
  <data name="SuspiciousLockingOverSynchronizationPrimitive" xml:space="preserve">
    <value>可疑的同步基元锁定</value>
  </data>
  <data name="AddsAnAccessorNotFoundInInterfaceMemberMessage" xml:space="preserve">
    <value>“{0}”添加了接口成员“{1}”中没有的访问器</value>
  </data>
  <data name="InvalidFunctionPointerParameterModifierMessage" xml:space="preserve">
    <value>函数指针形参修饰符无效</value>
  </data>
  <data name="CodeCleanupTask_ArrangeNullCheckingPattern" xml:space="preserve">
    <value>排列 null 检查模式样式</value>
  </data>
  <data name="IgnoredDirectiveBadPlacementMessage" xml:space="preserve">
    <value>'#{0}' 指令前不允许其他标记</value>
  </data>
  <data name="ParameterMustHaveWhenExitingMessage" xml:space="preserve">
    <value>退出时形参 {0} 必须具有非 null 值</value>
  </data>
  <data name="ClassWithComImportAttributeCannotHaveUserDefinedConstructor" xml:space="preserve">
    <value>具有 [ComImport] 特性的类不能有用户定义的构造函数</value>
  </data>
  <data name="ReplaceBuiltInTypeReferenceWithACLRTypeNameOrAKeywordInStaticMemberAccessExpressions" xml:space="preserve">
    <value>在 static 成员访问表达式中将内置类型引用替换为 CLR 类型名称或关键字</value>
  </data>
  <data name="CannotUseAsATypeArgumentMessage" xml:space="preserve">
    <value>不能将 '{0}' 用作类型实参</value>
  </data>
  <data name="TheInterpolatedStringHandlerArgumentAttributeAppliedToParameterIsMalformedAndCannotBeInterpretedConstructAnInstanceOfManuallyMessage" xml:space="preserve">
    <value>应用于形参 '{0}' 的 [InterpolatedStringHandlerArgumentAttribute] 格式错误，不能解释。请手动构造 '{1}' 的实例。</value>
  </data>
  <data name="DuplicatedChainedIfBodiesMessage" xml:space="preserve">
    <value>重复的 'if' 分支</value>
  </data>
  <data name="ShebangDirectiveBadPlacementTitle" xml:space="preserve">
    <value>将 shebang 指令移动到文件开头</value>
  </data>
  <data name="ImmediateDelegateInvocation" xml:space="preserve">
    <value>即时委托调用</value>
  </data>
  <data name="UsageOfinheritdocIsInvalidMessage" xml:space="preserve">
    <value>&lt;inheritdoc /&gt; 的用法无效: {0}</value>
  </data>
  <data name="LeftOperandIsAlwaysNullMessage" xml:space="preserve">
    <value>'??' 左操作数始终为 null</value>
  </data>
  <data name="ForSimpleTypes_Caption" xml:space="preserve">
    <value>对于简单类型</value>
  </data>
  <data name="DivisionByZeroInAtLeastOneExecutionPathMessage" xml:space="preserve">
    <value>在至少一个执行路径中除以零</value>
  </data>
  <data name="PartOfForeachLoopCanBeConvertedIntoLINQExpressionButAnotherGetEnumeratorMethodWillBeUsed" xml:space="preserve">
    <value>foreach 循环的一部分可以转换为 LINQ 表达式，但将使用另一个 'GetEnumerator' 方法</value>
  </data>
  <data name="awaitCannotBeUsedInAnInterpolatedStringOfByrefLikeTypeMessage" xml:space="preserve">
    <value>'await' 不能用于类似 byref 类型 '{0}' 的内插字符串</value>
  </data>
  <data name="AStaticAbstractInterfaceMemberCanBeAccessedOnlyOnATypeParameterMessage" xml:space="preserve">
    <value>只能在类型形参上访问 static virtual 或 abstract 接口成员</value>
  </data>
  <data name="AssignmentIsNotUsed" xml:space="preserve">
    <value>未使用赋值</value>
  </data>
  <data name="PreferConcreteValueOverDefaultDescription" xml:space="preserve">
    <value>最好使用具体值(如 'false' 或 '0')而不是 'default' 或 'new()' 等泛型表达式</value>
  </data>
  <data name="UsingSymbolRequiresOptingIntoPreviewFeaturesSeeUrl_PrePunctuatedText" xml:space="preserve">
    <value>{0}使用 {1} 需要选择预览功能。如需了解详情，请参阅 {2}。</value>
  </data>
  <data name="SuspiciousvolatileFieldUsageCompoundOperationIsNotAtomicInterlockedClassCanBeUsedInstead" xml:space="preserve">
    <value>可疑的 'volatile' 字段用法: 复合操作不是原子操作。可以改用 'Interlocked' 类。</value>
  </data>
  <data name="TheGivenExpressionNeverMatchesTheProvidedPatternMessage" xml:space="preserve">
    <value>表达式从未与提供的模式匹配</value>
  </data>
  <data name="AutoPropertyCannotBeMarkedreadonlyBecauseItHasAsetAccessorMessage" xml:space="preserve">
    <value>自动属性 '{0}' 不能被标记为 'readonly'，因为它有 'set' 访问器</value>
  </data>
  <data name="TypeSystemValueTupleIsNotResolvedMessage" xml:space="preserve">
    <value>类型 'System.ValueTuple' 未被解析</value>
  </data>
  <data name="TheSourceExpressionIsAlwaysOfPatternsTypeMatchesOnAllNonNullValues" xml:space="preserve">
    <value>源表达式始终为模式的类型，在所有非 null 值上匹配</value>
  </data>
  <data name="PossiblyWrongStringComparisonWithSpansDescription" xml:space="preserve">
    <value>可能存在错误的字符串比较: 只有指向同一内存位置时，跨度才相等。新创建或静态字符串的跨度不太可能与其他跨度相等，您可能希望比较字符/字节。</value>
  </data>
  <data name="IsNotAnInstanceMethodTheReceiverCannotBeAnInterpolatedStringHandlerArgumentMessage" xml:space="preserve">
    <value>'{0}' 不是实例方法，接收器不能为内插字符串处理程序实参</value>
  </data>
  <data name="MethodIsMarkedAsOperationContractButContainingTypeIsntMarkedAsServiceContractMessage" xml:space="preserve">
    <value>方法 '{0}' 被标记为 OperationContract，但包含类型未被标记为 ServiceContract</value>
  </data>
  <data name="PreferWhetherToAddVarKeywordToDiscards_Text" xml:space="preserve">
    <value>首选将 'var' 关键字添加到弃元中以防止与 '_' 变量可能发生的冲突</value>
  </data>
  <data name="TypeCheckForNullableTypeIsEqualToUnderlyingTypeCheck" xml:space="preserve">
    <value>可以为 null 的类型的类型检查等于基础类型检查</value>
  </data>
  <data name="TypeIsMarkedByCannotApplyEqualityOperatorAttributeAttributeButComparedWithOrOperators" xml:space="preserve">
    <value>类型由 'CannotApplyEqualityOperatorAttribute' 特性标记，但它使用 '==' 或 '!=' 运算符进行比较</value>
  </data>
  <data name="CallToBaseEqualsMethodIsResolvedToObjectEqualsWhichIsReferenceEquality" xml:space="preserve">
    <value>对 'Equals(...)' 基方法的调用被解析为 'Object.Equals'，它是引用相等</value>
  </data>
  <data name="RefAssignReturnOnlyWarningMessage" xml:space="preserve">
    <value>这会将 '{1}' 引用赋给 '{0}' ，但 '{2}' 只能通过 return 语句转义当前方法</value>
  </data>
  <data name="TheTypeMustBeValidUnmanagedTypeSimpleNumericboolcharvoidEnumerationTypeOrTypeWithAllFieldsOfUnmanagedTypesAtAnyLevelOfNestingInOrderToUseItAsATypeArgumentForParameterMessage" xml:space="preserve">
    <value>类型 '{0}' 必须为有效的非托管类型(简单数字、'bool'、'char'、'void'、枚举类型或在任何嵌套级别具有所有非托管类型的字段的{1}类型)才能将其用作 '{2}' 形参的类型实参</value>
  </data>
  <data name="CompilerWarning_CS1735_Title" xml:space="preserve">
    <value>XML 注释中有 typeparamref 标记，但是没有该名称的类型参数</value>
  </data>
  <data name="ReturnOfTaskProducedByUsingVariableMessage" xml:space="preserve">
    <value>返回的任务可能需要 '{0}' 对象才能完成，但它是由 'using' 语句捕获的，并且会在返回之前被自动处置</value>
  </data>
  <data name="CoVariantArrayConversionFromToCanCauseRunTimeExceptionOnWriteOperationMessage" xml:space="preserve">
    <value>从 {0} 到 {1} 的协变数组转换可能导致写入操作出现运行时异常</value>
  </data>
  <data name="VariableCanBeDeclaredWithMoreSpecificTypeMessage" xml:space="preserve">
    <value>可以使用更具体的类型 '{0}' 声明变量</value>
  </data>
  <data name="DuplicatedStatementsDescription" xml:space="preserve">
    <value>如果之后执行了相同的序列，则移除条件分支或 'switch' case 内的语句。</value>
  </data>
  <data name="ZeroIndexCanBeOmittedInRangeExpression" xml:space="preserve">
    <value>在范围表达式中，可以省略零索引</value>
  </data>
  <data name="AddRemovethisQualifier" xml:space="preserve">
    <value>添加/移除 'this' 限定符</value>
  </data>
  <data name="MembersOfOfTypeCannotBeAssignedWithNestedInitializerBecauseItIsOfAValueTypeMessage" xml:space="preserve">
    <value>不能向 '{2}' 类型的{0} '{1}' 的成员分配嵌套初始值设定项，因为它为值类型</value>
  </data>
  <data name="AllUnderscoreLocalParameterNameDescription" xml:space="preserve">
    <value>对于具有用法的形参，'_' 字符组成的名称可能具有误导性，因为此类名称通常为未使用的形参所保留</value>
  </data>
  <data name="SuggestToReplacexIsToxIfXIsOfTypeInt" xml:space="preserve">
    <value>建议将
          `x is &gt; 42` 替换为 `x &gt; 42`
          (如果 x 为 int 类型)</value>
  </data>
  <data name="InlineArrayIndexerNotUsedMessage" xml:space="preserve">
    <value>内联数组索引器不会用于元素访问表达式</value>
  </data>
  <data name="CSharpFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_statement_braces" xml:space="preserve">
    <value>语句大括号周围</value>
  </data>
  <data name="MoveLocalFunctionAfterJumpStatement_SuggestInNestedScopes_Description" xml:space="preserve">
    <value>当可以使用显式 'continue'、'break' 或 'return' 语句将局部函数与代码的其余部分分隔开时，建议将局部函数移动到嵌套作用域(例如循环或 'if' 语句)的末尾。这将帮助读者清楚地将在某个点执行的代码与在那里声明但可能稍后执行的代码分开。</value>
  </data>
  <data name="PartialMember_MustHaveADefinitionPartMessage" xml:space="preserve">
    <value>分部{0} '{1}' 必须有定义部分</value>
  </data>
  <data name="ParameterWithparamsModifierMustHaveAnArrayTypeMessage" xml:space="preserve">
    <value>带有 'params' 修饰符的形参必须具有数组类型</value>
  </data>
  <data name="RedundantArgumentWithDefaultValue" xml:space="preserve">
    <value>带有默认值的冗余实参</value>
  </data>
  <data name="CannotInitializeAByReferenceVariableWithAValueMessage" xml:space="preserve">
    <value>无法使用值初始化按引用变量</value>
  </data>
  <data name="RedundantConditionalTernaryExpressionUsagepreConditionTrueFalsePre" xml:space="preserve">
    <value>冗余的条件三元表达式用法:
&lt;pre&gt;
  condition ? true : false
&lt;/pre&gt;</value>
  </data>
  <data name="ThisMightLeadToAPossibleDeadlockIfMethods_Text" xml:space="preserve">
    <value>如果这种类型的方法(属性)由多个线程同时执行，这可能会导致死锁。</value>
  </data>
  <data name="SafeCastExpressionAlwaysSucceedsAndCanBeReplacedWithADirectCast" xml:space="preserve">
    <value>安全转换表达式始终成功并且可被替换为直接转换</value>
  </data>
  <data name="BadArgRefMessage" xml:space="preserve">
    <value>与 'in' 形参相对应的实参 {0} 的 'ref' 修饰符相当于 'in'。请考虑改用 'in'。</value>
  </data>
  <data name="CompilerWarning_CS7081_Title" xml:space="preserve">
    <value>CallerMemberNameAttribute 将不起任何作用；它由 CallerLineNumberAttribute 重写</value>
  </data>
  <data name="CompilerWarning_CS8034_Title" xml:space="preserve">
    <value>无法加载分析器程序集</value>
  </data>
  <data name="AddOrRemoveExplicitTypeSpecificationInDefaultValueExpressionWhenTypeIsEvidentFromTheUsage" xml:space="preserve">
    <value>在可以从用法明显看出类型时，在默认值表达式中添加或移除显式类型规范</value>
  </data>
  <data name="UseBracesToSeparateWhileStatementBody_Text" xml:space="preserve">
    <value>使用大括号分隔 'while' 语句体</value>
  </data>
  <data name="CannotYieldInTheBodyOfBecauseItReturnsByReferenceMessage" xml:space="preserve">
    <value>不能在{0} '{1}' 体中生成，因为它按引用返回</value>
  </data>
  <data name="FileTypeNestedMessage" xml:space="preserve">
    <value>file-local 类型 '{0}' 必须在顶层类型中定义；'{0}' 是嵌套类型</value>
  </data>
  <data name="NotResolvedParamsCollectionCreateMethodReferenceFromCallSiteMessage" xml:space="preserve">
    <value>找不到 '{0}' 类型的合适构建器方法来从 '{1}' 创建 'params' 集合</value>
  </data>
  <data name="CannotTakeTheSizeOfAVariableOfAManagedTypeMessage" xml:space="preserve">
    <value>'{0}' 没有预定义的大小，因此 sizeof 只能在不安全的上下文中使用</value>
  </data>
  <data name="EntityFrameworkRelationsToBeLoadedText" xml:space="preserve">
    <value>查询中可能需要包括以下导航:</value>
  </data>
  <data name="InlineTemporaryVariableInitializedWithAValueOfOtherVariableParameterToReduceTheAmountOfDifferentNamesUsedToReferenceTheSameValue" xml:space="preserve">
    <value>使用其他变量/形参的值初始化的内联临时变量，以减少用于引用相同值的不同名称的数量</value>
  </data>
  <data name="ReadonlyredundantMemberAccessorModifierInStructDeclaration" xml:space="preserve">
    <value>结构声明中存在只读 'redundant' 成员/访问器修饰符</value>
  </data>
  <data name="CannotBeBothabstractAndsealedMessage" xml:space="preserve">
    <value>{0} '{1}' 不能为 'abstract' 和 'sealed'</value>
  </data>
  <data name="TheSwitchCaseHasAlreadyBeenHandledByAPreviousCaseMessage" xml:space="preserve">
    <value>switch case 无法访问。它已被上一个 case 处理或无法匹配。</value>
  </data>
  <data name="UseNullPropagationSettingApplyStyleHeuristicsDescription" xml:space="preserve">
    <value>使用此选项，只有在更改不会影响可读性的情况下才会建议转换。例如，如果应用它会提升变量，它将禁止建议，引入新的 'Nullable&lt;T&gt;.Value' 访问。</value>
  </data>
  <data name="VirtualMemberCallInConstructor" xml:space="preserve">
    <value>构造函数中存在 virtual 成员调用</value>
  </data>
  <data name="ThePatternHasAlreadyBeenHandledByAPreviousArmOfTheswitchExpressionMessage" xml:space="preserve">
    <value>模式无法访问。它已由 switch 表达式的前一个 arm 处理，或者不可能匹配。</value>
  </data>
  <data name="TypeParameterCouldBeDeclaredAsCovariantOrContravariant2" xml:space="preserve">
    <value>类型形参可被声明为协变或逆变</value>
  </data>
  <data name="UseBracesToSeparateifStatementBody" xml:space="preserve">
    <value>使用大括号分隔 'if' 语句体</value>
  </data>
  <data name="CannotResolveConstructorCallMessage" xml:space="preserve">
    <value>不能解析 '{0}' 构造函数调用</value>
  </data>
  <data name="CheckForInequalityBeforeAssignmentIsRedundantpreIfXValueXValuePre" xml:space="preserve">
    <value>在赋值前检查不等冗余
&lt;pre&gt;
  if (x != value)
    x = value;
&lt;/pre&gt;</value>
  </data>
  <data name="CheckedOperatorNeedsMatchMessage" xml:space="preserve">
    <value>运算符 '{0}' 也要求定义匹配的非 checked 版本的运算符</value>
  </data>
  <data name="CannotImplementBecauseItDoesNotReturnMessage" xml:space="preserve">
    <value>'{0}' 不能实现 '{1}'，因为它不返回{2}</value>
  </data>
  <data name="CannotAccessExplicitImplementationOfMessage" xml:space="preserve">
    <value>不能访问 '{0}.{1}' 的显式实现</value>
  </data>
  <data name="StaticClassCannotBeUsedInAnonymousTypePropertyMessage" xml:space="preserve">
    <value>static 类不能用于匿名类型属性</value>
  </data>
  <data name="ExternEventCannotHaveAddOrRemoveAccessorsMessage" xml:space="preserve">
    <value>extern 事件不能有 add 或 remove 访问器</value>
  </data>
  <data name="NameIsNotValidAtThisPointMessage" xml:space="preserve">
    <value>{0}名称在此位置无效</value>
  </data>
  <data name="RedundantScopedParameterModifierMessage" xml:space="preserve">
    <value>冗余的 'scoped' 修饰符</value>
  </data>
  <data name="RedundantTypeCheckInAPattern" xml:space="preserve">
    <value>模式中存在冗余类型检查</value>
  </data>
  <data name="EventUnsubscriptionViaAnonymousDelegateMessage" xml:space="preserve">
    <value>通过匿名委托取消订阅事件</value>
  </data>
  <data name="DivisionByZeroInAtLeastOneExecutionPath" xml:space="preserve">
    <value>在至少一个执行路径中除以零</value>
  </data>
  <data name="CompilerWarning_CS0280_Title" xml:space="preserve">
    <value>类型不实现集合模式；成员有错误的签名</value>
  </data>
  <data name="VariableResultedFromACallTo__Text" xml:space="preserve">
    <value>调用{0}生成的变量</value>
  </data>
  <data name="RequiredMembersMustBeAssignedValueMessage" xml:space="preserve">
    <value>必需成员 '{0}' 必须被赋值，它不能使用嵌套成员或集合初始值设定项</value>
  </data>
  <data name="CompilerWarning_CS0675_Title" xml:space="preserve">
    <value>对进行了带符号扩展的操作数使用了按位或运算符</value>
  </data>
  <data name="EmptyConstructorIsRedundantTheCompilerGeneratesTheSameByDefaultMessage" xml:space="preserve">
    <value>空构造函数冗余。默认情况下，编译器生成相同的内容。</value>
  </data>
  <data name="NamespaceNameExpectedMessage_TypeAddition" xml:space="preserve">
    <value>; '{0}' 是类型，而不是命名空间。请考虑改用 'using static' 指令。</value>
  </data>
  <data name="UseNullPropagationMessage" xml:space="preserve">
    <value>使用 null 传播</value>
  </data>
  <data name="CompilerWarning_CS8667_Title" xml:space="preserve">
    <value>分部方法声明在对类型参数的约束中具有不一致的为 Null 性</value>
  </data>
  <data name="SimplifyNegatedRelationalPatternMessage" xml:space="preserve">
    <value>简化求反关系模式</value>
  </data>
  <data name="DuplicatedSwitchBranchesMessage" xml:space="preserve">
    <value>重复的 'switch' 分支</value>
  </data>
  <data name="UseExpressionBodyOrBlockBodyForLocal_Text" xml:space="preserve">
    <value>为局部函数使用表达式主体或块主体</value>
  </data>
  <data name="SimplifyConditionalTernaryExpression" xml:space="preserve">
    <value>简化条件三元表达式</value>
  </data>
  <data name="CompilerWarning_CS0658_Title" xml:space="preserve">
    <value>不是可识别的特性位置</value>
  </data>
  <data name="CharIsPossiblyUnintentionallyUsedAsIntegerWhereOverloadWithStringIsAvailableMessage" xml:space="preserve">
    <value>可能无意中将 char 用作整数，这里可以使用带字符串的重载</value>
  </data>
  <data name="ConditionalMemberCannotHaveAnOutParameterMessage" xml:space="preserve">
    <value>条件成员“{0}”不能有 out 参数</value>
  </data>
  <data name="CompilerWarning_CS8644_Title" xml:space="preserve">
    <value>类型不实现接口成员。接口中基类型实现的引用类型的 Null 性不匹配。</value>
  </data>
  <data name="BlockDescriptionHints_Text" xml:space="preserve">
    <value>块标头提示</value>
  </data>
  <data name="IsAlreadyListedInInterfaceListMessage" xml:space="preserve">
    <value>“{0}”已经在接口列表中列出</value>
  </data>
  <data name="APartialMemberMayNotHaveMultipleImplementingDeclarationsMessage" xml:space="preserve">
    <value>分部{0}不能有多个实现声明</value>
  </data>
  <data name="TheTypeArgumentsCannotBeInferredFromTheQuerynCandidatesAreMessage" xml:space="preserve">
    <value>不能从查询中推断类型实参。 
候选项为:{0}</value>
  </data>
  <data name="ifStatementCanBeReWrittenAsExpression7" xml:space="preserve">
    <value>'if' 语句可被重写为 '?:' 表达式</value>
  </data>
  <data name="CanSimplifyDictionaryRemovingWithSingleCallMessage" xml:space="preserve">
    <value>可以使用单个 'Remove' 简化条目移除</value>
  </data>
  <data name="ComparisonOfABooleanValueWithtrueOrfalseConstant" xml:space="preserve">
    <value>比较布尔值与 'true' 或 'false' 常量</value>
  </data>
  <data name="_MustBe__Text" xml:space="preserve">
    <value>{0}必须为{1}</value>
  </data>
  <data name="TheswitchExpressionDoesNotHandleAllPossibleInputsItIsNotExhaustiveForExampleThePatternIsNotCoveredHoweverAPatternWithAwhenClauseMightSuccessfullyMatchThisValueMessage" xml:space="preserve">
    <value>'switch' 表达式不处理所有可能的输入(它不是详尽的)。例如，不涵盖模式 '{0}'。但是具有 'when' 子句的模式可能与此值成功匹配。</value>
  </data>
  <data name="UsingStatementResourceInitializationExpressionDescription" xml:space="preserve">
    <value>在 'using' 语句之前计算对象属性，以确保在初始化过程中不会抛出异常，从而确保对象不会被处置</value>
  </data>
  <data name="BecauseResultOfAsynchronousIteratorCallIsNotBeingIteratedExecutionOfTheCurrentMethodContinuesBeforeTheCallIsCompletedConsiderUsingTheawaitForeachOverTheResultOfTheCall" xml:space="preserve">
    <value>由于异步迭代器调用的结果未循环访问，当前方法会在调用完成之前继续执行。请考虑在调用结果上使用 'await foreach'。</value>
  </data>
  <data name="RedundantSpreadElementDescription" xml:space="preserve">
    <value>移除冗余的 spread 元素以直接使用内部集合的条目</value>
  </data>
  <data name="UseRawString_Title" xml:space="preserve">
    <value>使用原始字符串</value>
  </data>
  <data name="CompilerWarning_CS8770_Title" xml:space="preserve">
    <value>方法缺少 "[DoesNotReturn]" 注释，无法匹配已实现的或被替代的成员。</value>
  </data>
  <data name="CannotUseExtensionReceiverParameterInThisContextMessage" xml:space="preserve">
    <value>无法在此上下文中使用扩展形参 '{0}'</value>
  </data>
  <data name="ArrangeNullCheckingPattern_Title" xml:space="preserve">
    <value>排列 null 检查模式</value>
  </data>
  <data name="ForBuiltInTypes" xml:space="preserve">
    <value>对于内置类型</value>
  </data>
  <data name="UnsafeIteratorArgType_Text" xml:space="preserve">
    <value>迭代器不能有指针类型形参</value>
  </data>
  <data name="RedundantStringFormatCallMessage" xml:space="preserve">
    <value>冗余的 'String.Format()' 调用</value>
  </data>
  <data name="CompilerWarning_CS1634_Title" xml:space="preserve">
    <value>#pragma 警告后应为 "disable" 或 "restore"</value>
  </data>
  <data name="LambdaExpressionAnonymousMethodPassedToParameterAnnotatedByRequireStaticDelegateMustBeStaticToHelpAvoidIntroducingHeapAllocations" xml:space="preserve">
    <value>传递给由 '[RequireStaticDelegate]' 特性注解的形参的 lambda 表达式/匿名方法必须为 'static'，以帮助避免引入堆分配</value>
  </data>
  <data name="AccessorsaddAndremoveInInterfaceMustDeclareABodyMessage" xml:space="preserve">
    <value>接口中的 'add' 和 'remove' 访问器必须声明主体</value>
  </data>
  <data name="InvokeAsExtensionMethodMessage" xml:space="preserve">
    <value>作为扩展方法调用</value>
  </data>
  <data name="ANewExpressionRequiresOrAfterTypeMessage" xml:space="preserve">
    <value>新表达式需要在类型之后具有 ()、[] 或 {}</value>
  </data>
  <data name="CompilerWarning_CS3006_Title" xml:space="preserve">
    <value>仅 ref 或 out 有区别，或者仅数组秩的重载方法不符合 CLS</value>
  </data>
  <data name="TypesRecord_RiderPresentableName" xml:space="preserve">
    <value>类型//记录</value>
  </data>
  <data name="EnforceBracesInLockStatement_Caption" xml:space="preserve">
    <value>在 'lock' 语句中强制使用大括号</value>
  </data>
  <data name="CannotAccessStaticSymbolInTextArgument" xml:space="preserve">
    <value>不能访问文本实参中的 static 符号</value>
  </data>
  <data name="ThereIsNoTargetTypeForTheDefaultLiteralMessage" xml:space="preserve">
    <value>默认字面量没有目标类型</value>
  </data>
  <data name="VarianceInterfaceNestingMessage" xml:space="preserve">
    <value>无法在具有 'in' 或 'out' 类型形参的接口中声明枚举、类和结构</value>
  </data>
  <data name="VariableIsDeclaredAsNullableButOnlyNeverContainsANullableValue" xml:space="preserve">
    <value>变量被声明为可以为 null，但从未包含 null 值</value>
  </data>
  <data name="AutoPropertiesCannotReturnByReferenceMessage" xml:space="preserve">
    <value>自动属性不能通过引用返回</value>
  </data>
  <data name="PropertyOfNamedAttributeArgumentMustHavePublicAccessorsMessage" xml:space="preserve">
    <value>命名特性实参的属性必须具有 public 访问器</value>
  </data>
  <data name="MembersNamedCloneAreDisallowedInRecordsMessage" xml:space="preserve">
    <value>记录中不允许名为 'Clone' 的成员</value>
  </data>
  <data name="IncludeUnconstrainedGenericsSettingsName" xml:space="preserve">
    <value>包括无约束泛型类型形参的可能变异</value>
  </data>
  <data name="ArrayElementTypeCannotBeMessage" xml:space="preserve">
    <value>数组元素类型不能为 '{0}'</value>
  </data>
  <data name="NullnessAnnotationConflictWithJetBrainsAnnotationsMessage" xml:space="preserve">
    <value>成员的为 null 性与层次结构中的注解冲突</value>
  </data>
  <data name="ReplaceWithSingleCallToFirst_Text" xml:space="preserve">
    <value>替换为对 First(..) 的单个调用</value>
  </data>
  <data name="InterceptsLocationHintHighlighting_Tooltip" xml:space="preserve">
    <value>**Ctrl+点击**以导航到被拦截的调用</value>
  </data>
  <data name="ProgramMissEntryPointErrorMessage" xml:space="preserve">
    <value>程序 '{0}' 不包含适合入口点的 static 'Main' 方法</value>
  </data>
  <data name="CompilerWarning_CS9095_Title" xml:space="preserve">
    <value>这将通过 ref 参数按引用返回参数的成员；但它只能在 return 语句中安全返回</value>
  </data>
  <data name="MoveToExtensionBlockMessage" xml:space="preserve">
    <value>移至扩展块</value>
  </data>
  <data name="BuiltInTypeReferenceForMemberAccessCodeStyleRule_TitleCaption" xml:space="preserve">
    <value>在 static 成员访问表达式中将内置类型引用替换为 CLR 类型名称或关键字</value>
  </data>
  <data name="ObjectReferenceEqualsIsAlwaysFalseBecauseItIsCalledWithValueType" xml:space="preserve">
    <value>'Object.ReferenceEquals' 始终为 false，因为它使用值类型进行调用</value>
  </data>
  <data name="ConvertifDoWhileTowhile" xml:space="preserve">
    <value>将 'if do while' 转换为 'while'</value>
  </data>
  <data name="DoNotUseSystemRuntimeCompilerServicesFixedBufferAttributeOnAAutoPropertyMessage" xml:space="preserve">
    <value>请勿在带支持字段的属性上使用 'System.Runtime.CompilerServices.FixedBuffer' 特性</value>
  </data>
  <data name="SomeValuesOfTheEnumAreNotProcessedInsideswitchStatement" xml:space="preserve">
    <value>枚举的某些值未在 'switch' 语句内处理</value>
  </data>
  <data name="CannotCreateDelegateFromMethodGroupWithRefStructMessage" xml:space="preserve">
    <value>不能使用 ref 结构从方法组创建委托</value>
  </data>
  <data name="StaticFieldOrAutoPropertyInGenericType" xml:space="preserve">
    <value>泛型类型中存在 static 字段或自动属性</value>
  </data>
  <data name="ThreadStaticDoesntWorkWithInstanceFields" xml:space="preserve">
    <value>[ThreadStatic] 对实例字段无效</value>
  </data>
  <data name="WinRTTypesCannotHaveMultipleConstructorsWithTheSameNumberOfArgumentsMessage" xml:space="preserve">
    <value>WinRT 类型不能具有多个拥有相同实参数量的构造函数</value>
  </data>
  <data name="ConstructorMustHaveBodyMessage" xml:space="preserve">
    <value>构造函数必须有主体</value>
  </data>
  <data name="RedundantNullableDirectiveDescription" xml:space="preserve">
    <value>可以为 null 的指令不会更改上下文，可以安全地移除</value>
  </data>
  <data name="CanSimplifySetAddingWithSingleCallTitle" xml:space="preserve">
    <value>可以简化 'Add' 前面的 'Contains'</value>
  </data>
  <data name="MustDeclarePrimaryConstructorInTheSameTypePartInOrderToUseBaseTypeConstructorCallSyntaxMessage" xml:space="preserve">
    <value>{0} '{1}' 必须声明主构造函数(在相同类型的部分中)，才能使用基类型构造函数调用语法</value>
  </data>
  <data name="ShiftExpressionWithZeroLeftOperandEqualsZeroMessage" xml:space="preserve">
    <value>左操作数为零的移位表达式等于零</value>
  </data>
  <data name="CompilerWarning_CS8519_Title" xml:space="preserve">
    <value>给定的表达式永远不会与提供的模式匹配。</value>
  </data>
  <data name="SomeValuesOfTheEnumAreNotProcessedInsideswitchExpressionAndAreHandledViaExceptionInDefaultArm" xml:space="preserve">
    <value>枚举的某些值未在 'switch' 表达式内处理，而是通过 default arm 中的异常进行处理</value>
  </data>
  <data name="CompilerWarning_CS8383_Title" xml:space="preserve">
    <value>由于元组 == 或 != 运算符的另一侧指定了其他名称或未指定名称，因此元组元素名称被忽略。</value>
  </data>
  <data name="IsAlreadyListedInTheInterfaceListOnTypeWithDifferentNullabilityOfReferenceTypesMessage" xml:space="preserve">
    <value>“{0}”已列入类型“{1}”的接口列表中，其中包含不同引用类型的 Null 性</value>
  </data>
  <data name="PossibleMistakenSystemTypeArgumentDescription" xml:space="preserve">
    <value>'System.Type' 类型的潜在错误实参在应为类型检查的对象的位置使用</value>
  </data>
  <data name="IteratorFunctionDoesNotReachItsEndOrAreturnStatementByAnyOfPossibleExecutionPaths" xml:space="preserve">
    <value>迭代器函数未通过任何可能的执行路径到达其结尾或 'return' 语句</value>
  </data>
  <data name="QualifierIsInconsistentWithSelectedCodeStyleMessage" xml:space="preserve">
    <value>限定符与代码样式设置不一致</value>
  </data>
  <data name="VoidInUsingAliasMessage" xml:space="preserve">
    <value>不能将别名声明为 'void'</value>
  </data>
  <data name="ReplaceObjectPatternNotPerformingAnyAdditionalChecksWithVarPattern" xml:space="preserve">
    <value>将不执行任何额外检查的对象模式替换为 'var' 模式</value>
  </data>
  <data name="ExtractCommonPropertyPatternDescription" xml:space="preserve">
    <value>通过提取通用属性模式简化递归模式</value>
  </data>
  <data name="JoinOrSeparatevarInDeconstructionDeclarations" xml:space="preserve">
    <value>在析构声明中联接或分隔 'var'</value>
  </data>
  <data name="SpecifyStringCultureExplicitly" xml:space="preserve">
    <value>显式指定字符串区域性</value>
  </data>
  <data name="ExpressionHasIdenticalTrueAndFalseBranchesMessage" xml:space="preserve">
    <value>'?:' 表达式具有相同的 true 和 false 分支</value>
  </data>
  <data name="PlaceAssignmentExpressionIntoBlock" xml:space="preserve">
    <value>将赋值表达式放入块中</value>
  </data>
  <data name="ValueOfSomeContextTypeIsAlreadyProvidedByMemberAnnotatedWithProvidesContextAnnotation" xml:space="preserve">
    <value>通过 [ProvidesContext] 注解进行注解的成员已提供某些上下文类型的值</value>
  </data>
  <data name="SimplifyLINQExpressionUseAnyMessage" xml:space="preserve">
    <value>简化 LINQ 表达式(使用 'Any')</value>
  </data>
  <data name="CompilerWarning_CS3009_Title" xml:space="preserve">
    <value>基类型不符合 CLS</value>
  </data>
  <data name="TheTypeMayNotBeUsedAsTheTargetTypeForMessage" xml:space="preserve">
    <value>类型 '{0}' 不能用作 '{1}' 的目标类型</value>
  </data>
  <data name="VirtualCannotBePrivateMessage" xml:space="preserve">
    <value>virtual {0}不能为 private</value>
  </data>
  <data name="PreferSingleOrSeparateDeclarationExpressions_Text" xml:space="preserve">
    <value>首选单个或单独的声明表达式</value>
  </data>
  <data name="MethodHasAsyncOverloadWithCancellationSupport" xml:space="preserve">
    <value>方法具有支持取消的异步重载</value>
  </data>
  <data name="NamedArguments_Text" xml:space="preserve">
    <value>命名实参</value>
  </data>
  <data name="Number_RiderPresentableName" xml:space="preserve">
    <value>数值</value>
  </data>
  <data name="TypeUsedInAMustBeImplicitlyConvertibleToSystemIAsyncDisposableOrImplementASuitableDisposeAsyncMethodMessage" xml:space="preserve">
    <value>{1}中使用的类型 '{0}' 必须可隐式转换为 '{2}' 或实现合适的 '{3}' 方法</value>
  </data>
  <data name="WinRTTypeCannotBeGenericMessage" xml:space="preserve">
    <value>WinRT 类型不能为泛型</value>
  </data>
  <data name="CustomAsyncOperationsAreNotSupportedUseAsyncInfoFactoryInsteadMessage" xml:space="preserve">
    <value>不支持自定义异步操作，请改用 AsyncInfoFactory</value>
  </data>
  <data name="CodeCleanupTask_CSOptimizeUsings_OptimizeUsings" xml:space="preserve">
    <value>优化 'using' 指令</value>
  </data>
  <data name="NonStaticLoggerTemplate_Description" xml:space="preserve">
    <value>传递给结构化日志记录 API 的消息模板应为常量</value>
  </data>
  <data name="TheTupleElementNameIsIgnoredBecauseADifferentNameOrNoNameIsSpecifiedByTheTargetTypeMessage" xml:space="preserve">
    <value>元组元素名称 '{0}' 已被忽略，因为目标类型 '{1}' 指定了其他名称或未指定名称</value>
  </data>
  <data name="AddressOfInIterator_Text" xml:space="preserve">
    <value>'&amp;' 运算符不能用于迭代器方法中的形参或局部变量</value>
  </data>
  <data name="AReadonlyFieldCannotBeAssignedToExceptInAConstructorOrAVariableInitializerMessage" xml:space="preserve">
    <value>不能给只读字段赋值(除了在构造函数或变量初始值设定项中外)</value>
  </data>
  <data name="LocalFunctionHasTheSameNameAsAMethodAndHidesIt" xml:space="preserve">
    <value>局部函数与方法同名，并将其隐藏</value>
  </data>
  <data name="TypeParameterIsNotAllowedForConstantTypeMessage" xml:space="preserve">
    <value>常量类型不允许使用类型形参</value>
  </data>
  <data name="ArraysInWinRTPublicAPIShouldBeSingleDimensionalMessage" xml:space="preserve">
    <value>WinRT 公开 API 中的数组应该是一维数组</value>
  </data>
  <data name="RedundantSwitchExpressionArmsTitle" xml:space="preserve">
    <value>冗余的 'switch' 表达式 arm</value>
  </data>
  <data name="UnscopedRefAttributeUnsupportedTargetMessage" xml:space="preserve">
    <value>UnscopedRefAttribute 不能应用于此条目，因为它默认不区分作用域</value>
  </data>
  <data name="DuplicateHashSetElementInitializationMessage" xml:space="preserve">
    <value>在初始化 '{1}' 集合时发现重复元素 '{0}'</value>
  </data>
  <data name="CompilerWarning_CS3012_Title" xml:space="preserve">
    <value>必须在程序集而不是模块上指定 CLSCompliant 特性，以便启用 CLS 遵从性检查</value>
  </data>
  <data name="ItIsNotLegalToUseTypedynamicInAPatternMessage" xml:space="preserve">
    <value>在模式中使用类型 'dynamic' 不合法</value>
  </data>
  <data name="FixedFieldMustNotBeRefMessage" xml:space="preserve">
    <value>fixed 字段不得是 ref 字段</value>
  </data>
  <data name="StreamReadReturnValueIgnoredTitle" xml:space="preserve">
    <value>'Stream.Read()' 读取的实际字节数会被忽略</value>
  </data>
  <data name="TargetParameterHasDifferentRefnessMessage" xml:space="preserve">
    <value>形参 '{0} {1} {2}' 的引用种类修饰符与目标中的相应形参 '{3} {4} {5}' 不匹配</value>
  </data>
  <data name="ArglistIsNotAllowedInTheParameterListOfIteratorsMessage" xml:space="preserve">
    <value>迭代器的形参列表中不允许使用 '__arglist'</value>
  </data>
  <data name="KeywordsKeyword_RiderPresentableName" xml:space="preserve">
    <value>关键字//关键字</value>
  </data>
  <data name="IsAttributedWithUnmanagedCallersOnlyAndCannotBeConvertedToADelegateTypeObtainAFunctionPointerToThisMethodMessage" xml:space="preserve">
    <value>'{0}' 具有 'UnmanagedCallersOnly' 特性，不能转换为委托类型。请获得此方法的函数指针。</value>
  </data>
  <data name="TheFirstOperandOfAnisOrasOperatorMayNotBeALambdaExpressionAnonymousMethodOrMethodGroupMessage" xml:space="preserve">
    <value>'is' 或 'as' 运算符的第一个操作数不能为 lambda 表达式、匿名方法或方法组</value>
  </data>
  <data name="ConvertPropertyToAutoPropertyWithPrivateSetter" xml:space="preserve">
    <value>将属性转换为带 private setter 的自动属性</value>
  </data>
  <data name="DiscardDesignationCanBeOmittedInThisContext" xml:space="preserve">
    <value>在此上下文中可以省略弃元指定</value>
  </data>
  <data name="CannotUseAttributeConstructorBecauseItHasParamsCollectionMessage" xml:space="preserve">
    <value>无法使用特性构造函数 '{0}'，因为它具有非数组类型的 'params' 形参</value>
  </data>
  <data name="UsePreferredArgumentStyleForNamedExpressions" xml:space="preserve">
    <value>对命名表达式使用首选实参样式</value>
  </data>
  <data name="RefReturnNonRefVariableWarningMessage" xml:space="preserve">
    <value>这会通过引用返回{0} '{1}'，但它不是 ref 局部变量</value>
  </data>
  <data name="TheSourceExpressionNeverMatchesTheProvidedPatternMessage" xml:space="preserve">
    <value>源表达式从未与提供的模式匹配</value>
  </data>
  <data name="TheSourceExpressionNeverMatchesTheProvidedPattern" xml:space="preserve">
    <value>源表达式从未与提供的模式匹配</value>
  </data>
  <data name="CannotSpecifyBothnotnullAndunmanagedTypeConstraintMessage" xml:space="preserve">
    <value>不能同时指定 'notnull' 和 'unmanaged' 类型约束</value>
  </data>
  <data name="ExternHasConstructorInitializerMessage" xml:space="preserve">
    <value>extern 构造函数不能具有构造函数初始值设定项</value>
  </data>
  <data name="TypeCheckAndCastsCanBeMerged" xml:space="preserve">
    <value>可以合并类型检查和转换</value>
  </data>
  <data name="PossibleCyclicConstructorCall4" xml:space="preserve">
    <value>可能的循环构造函数调用</value>
  </data>
  <data name="InterceptorNonUniquePathMessage" xml:space="preserve">
    <value>无法拦截路径为 '{0}' 的文件中的调用，因为编译中的多个文件具有此路径</value>
  </data>
  <data name="EventUnsubscriptionViaAnonymousDelegateIsMeaningless" xml:space="preserve">
    <value>通过匿名委托取消订阅事件毫无意义</value>
  </data>
  <data name="OverridableCannotBeStaticMessage" xml:space="preserve">
    <value>overridable {0}不能为 static</value>
  </data>
  <data name="Parentheses_Text" xml:space="preserve">
    <value>圆括号</value>
  </data>
  <data name="ReferenceToUndefinedEntity__ToolTip" xml:space="preserve">
    <value>对未定义实体 '{0}' 的引用</value>
  </data>
  <data name="RedundantOrderByClauseAscendingKeywordMessage" xml:space="preserve">
    <value>冗余的 '{0}' 子句 '{1}' 关键字</value>
  </data>
  <data name="TheInterfaceCannotBeUsedAsTypeParameterInTheGenericTheConstraintInterfaceOrItsBaseInterfaceHasStaticAbstractMembersMessage" xml:space="preserve">
    <value>接口 '{0}' 类型不能用作类型形参 '{1}' 的类型实参。接口具有没有实现的 static abstract 成员:{2}</value>
  </data>
  <data name="Constructor_Text" xml:space="preserve">
    <value>构造函数</value>
  </data>
  <data name="CompilerWarning_CS0649_Title" xml:space="preserve">
    <value>从未对字段赋值，字段将一直保持其默认值</value>
  </data>
  <data name="MethodsExtensionMethod_RiderPresentableName" xml:space="preserve">
    <value>方法//扩展方法</value>
  </data>
  <data name="AnnotationDuplicateInHierarchy" xml:space="preserve">
    <value>层次结构中的注解重复</value>
  </data>
  <data name="IndexerCannotBeDeclaredstaticMessage" xml:space="preserve">
    <value>索引器不能被声明为 'static'</value>
  </data>
  <data name="TypeSystemRuntimeCompilerServicesFormattableStringFactoryIsNotResolvedMessage" xml:space="preserve">
    <value>类型 'System.Runtime.CompilerServices.FormattableStringFactory' 未被解析</value>
  </data>
  <data name="ModifiersOrderMustRespectReferenceOrder" xml:space="preserve">
    <value>声明修饰符的顺序与代码样式设置不匹配</value>
  </data>
  <data name="TheValuePassedToTheMethodIsNeverUsedBecauseItIsOverwrittenInTheMethodBodyBeforeBeingReadMessage" xml:space="preserve">
    <value>传递给方法的值从未被使用，因为它在读取之前在方法体中被覆盖</value>
  </data>
  <data name="Missing_Modifier_Text" xml:space="preserve">
    <value>缺少 '{0}' 修饰符</value>
  </data>
  <data name="_14OrGreater_Text" xml:space="preserve">
    <value>14.0 或更高</value>
  </data>
  <data name="MembersCannotBeUsedInThisAttributeMessage" xml:space="preserve">
    <value>成员 {0} 不能在此特性中使用</value>
  </data>
  <data name="RedundantOperandInLogicalConditionalExpressionMessage" xml:space="preserve">
    <value>逻辑条件表达式中存在冗余的操作数</value>
  </data>
  <data name="TheOperandOfAnOperatorMustBeAnAssignableVariablePropertyOrIndexerMessage" xml:space="preserve">
    <value>{0}{1}运算符的操作数必须为可赋值的变量、属性或索引器</value>
  </data>
  <data name="OverriddenGetHashCodeCallsBaseObjectGetHashCode" xml:space="preserve">
    <value>被重写的 GetHashCode 调用基 'Object.GetHashCode()'</value>
  </data>
  <data name="RedundantAccessorBodyMessage" xml:space="preserve">
    <value>冗余的访问器体</value>
  </data>
  <data name="CannotSpecifyBothnotnullAndclassTypeConstraintMessage" xml:space="preserve">
    <value>不能同时指定 'notnull' 和 'class' 类型约束</value>
  </data>
  <data name="RedundantUseOfQualifierForATypeNameOrStaticMemberUsage" xml:space="preserve">
    <value>类型名称或 static 成员用法的限定符的冗余使用</value>
  </data>
  <data name="CannotDeriveFromSpecialClassMessage" xml:space="preserve">
    <value>不能从特殊类 {0} 派生</value>
  </data>
  <data name="CannotTakeTheAddressOfTheGivenExpressionMessage" xml:space="preserve">
    <value>无法获取给定表达式的地址</value>
  </data>
  <data name="StaticClassCannotHaveNonStaticMessage" xml:space="preserve">
    <value>static 类 '{0}' 不能有非 static {1} '{2}'</value>
  </data>
  <data name="MethodLacksDoesNotReturnAnnotationInOrderToMatchImplementedMemberMessage" xml:space="preserve">
    <value>方法 '{0}' 缺少匹配被实现的成员所需的 '[DoesNotReturn]' 注解</value>
  </data>
  <data name="DuplicateAllowsRefStructConstraintMessage" xml:space="preserve">
    <value>重复的 'allows ref struct' 类型约束</value>
  </data>
  <data name="ReplacePartOfTheStringLiteralWithStaticallyTypedNameofExpression" xml:space="preserve">
    <value>将部分字符串字面量替换为静态类型化 'nameof' 表达式</value>
  </data>
  <data name="CannotBeOfStaticClassTypeMessage" xml:space="preserve">
    <value>{0}不能为 static 类类型 '{1}'</value>
  </data>
  <data name="NameSensitiveTitle" xml:space="preserve">
    <value>分组时考虑扩展形参的名称</value>
  </data>
  <data name="NonAbstractAndNonExternMustDeclareABodyMessage" xml:space="preserve">
    <value>非 abstract 和非 extern {0}必须声明主体</value>
  </data>
  <data name="FieldOffsetAttributeOnStaticFieldMessage" xml:space="preserve">
    <value>静态字段或常量字段上不允许存在 '[FieldOffset]' 特性</value>
  </data>
  <data name="DuplicateAttributeMessage" xml:space="preserve">
    <value>“{0}”特性重复</value>
  </data>
  <data name="UseOfToStringCallInAContextWhereItWouldBeGeneratedByTheCompilerAutomaticallyForExampleInAConcatenationWithAStringOrAsAnArgumentOfAStringFormatCall" xml:space="preserve">
    <value>在将由编译器自动生成 ToString() 调用的上下文中使用该调用。
          例如，与字符串串联或作为 string.Format() 调用的实参。</value>
  </data>
  <data name="LocalVariableHidesPrimaryConstructorParameterMessage" xml:space="preserve">
    <value>局部变量 '{0}' 隐藏主构造函数形参 '{1}'</value>
  </data>
  <data name="CannotOverrideInheritedBecauseItIsSealedMessage" xml:space="preserve">
    <value>不能重写继承的{0} '{1}'，因为它为 sealed</value>
  </data>
  <data name="PropertiesAndVariablesPrimaryConstructorParameter_RiderPresentableName" xml:space="preserve">
    <value>属性和变量//主构造函数形参</value>
  </data>
  <data name="CompilerWarning_CS0458_Title" xml:space="preserve">
    <value>表达式的结果总是 "null"</value>
  </data>
  <data name="AnArglistParameterMustBeTheLastParameterInAFormalParameterListMessage" xml:space="preserve">
    <value>__arglist 参数必须是形参表中的最后一个参数</value>
  </data>
  <data name="CompilerWarning_CS3017_Title" xml:space="preserve">
    <value>不能在模块上指定与程序集的 CLSCompliant 特性不同的 CLSCompliant 特性</value>
  </data>
  <data name="CompilerWarning_CS8851_Title" xml:space="preserve">
    <value>记录定义 "Equals" 而不定义 "GetHashCode"。</value>
  </data>
  <data name="SwitchStatementForEnumValuesDoesNotHaveDefaultSectionThisMightLeadToUnexpectedBehaviorIfNewEnumValuesWillBeIntroduced" xml:space="preserve">
    <value>枚举值的 switch 语句没有 default 部分。如果将引入新的枚举值，这可能会导致意外行为。</value>
  </data>
  <data name="ContainerNullabilityAttributeUsageWithDeclarationOfNonContainerTypeDoesntAffectCodeAnalysis" xml:space="preserve">
    <value>将容器为 null 性特性与非容器类型声明一起使用不影响代码分析</value>
  </data>
  <data name="ASuppressedNullableWarningOrAssumingAValueIsNonNullableMightHideAnUnderlyingProblemMessage" xml:space="preserve">
    <value>禁止的可以为 null 警告或假设一个值不可以为 null 的可能会隐藏底层问题</value>
  </data>
  <data name="RedundantVerbatimPrefixMessage" xml:space="preserve">
    <value>冗余的逐字字符串前缀</value>
  </data>
  <data name="Base__IsRequiredByAttribute__Text" xml:space="preserve">
    <value>特性 '{2}' 需要基{0} '{1}'</value>
  </data>
  <data name="ShebangDirectiveBadPlacementMessage" xml:space="preserve">
    <value>shebang 指令必须是文件中的第一个标记</value>
  </data>
  <data name="ExpressionDoesNotHaveANameMessage" xml:space="preserve">
    <value>表达式不具有名称</value>
  </data>
  <data name="CompilerWarning_CS8826_Title" xml:space="preserve">
    <value>分部方法声明具有签名差异。</value>
  </data>
  <data name="CompilerWarning_CS9022_Title" xml:space="preserve">
    <value>在显式分配字段之前，将向调用方返回控件，从而导致前面的隐式分配为 'default'。</value>
  </data>
  <data name="CompilerWarning_CS9191_Title" xml:space="preserve">
    <value>与 'in' 形参相对应的实参的 'ref' 修饰符相当于 'in'。请考虑改用 'in'。</value>
  </data>
  <data name="CompilerWarning_CS8846_Title" xml:space="preserve">
    <value>switch 表达式不会处理属于其输入类型的所有可能值(它并非详尽无遗)。</value>
  </data>
  <data name="RedundantbaseQualifier" xml:space="preserve">
    <value>冗余的 'base.' 限定符</value>
  </data>
  <data name="GlobalUsingStaticFileLocalTypeMessage" xml:space="preserve">
    <value>file-local 类型 '{0}' 不能用于 'global using static' 指令</value>
  </data>
  <data name="ParameterOfUnaryOperatorMustBeOfExtendedTypeMessage" xml:space="preserve">
    <value>一元运算符的形参必须为扩展类型</value>
  </data>
  <data name="AssignmentMadeToSameVariableDidYouMeanToAssignSomethingElseMessage" xml:space="preserve">
    <value>对同一变量进行赋值；是否希望对其他变量赋值?</value>
  </data>
  <data name="CannotConvertKeyType_ToIterationKeyType_Text" xml:space="preserve">
    <value>不能将键类型 '{0}' 转换为迭代键类型 '{1}'</value>
  </data>
  <data name="JoinOrSeparateAttributesIsSection" xml:space="preserve">
    <value>在部分中联接或分隔特性</value>
  </data>
  <data name="Attributes_Text" xml:space="preserve">
    <value>特性</value>
  </data>
  <data name="SomeDeclaration_Text" xml:space="preserve">
    <value>'{0}' 声明</value>
  </data>
  <data name="RedundantFixedPointerDeclaration" xml:space="preserve">
    <value>冗余的固定指针声明</value>
  </data>
  <data name="MustBeANonAbstractTypeWithAPublicParameterlessConstructorInOrderToUseItAsParameterInTheGenericMessage" xml:space="preserve">
    <value>'{0}' 必须为具有 public 无形参构造函数的非 abstract 类型，才能在泛型{2} '{3}' 中将其用作形参 '{1}'</value>
  </data>
  <data name="TheExpressionBeingAssignedToMustBeConstantMessage" xml:space="preserve">
    <value>指派给“{0}”的表达式必须是常量</value>
  </data>
  <data name="LineDirectiveReverseLinesErrorMessage" xml:space="preserve">
    <value>结束位置必须大于或等于起始位置</value>
  </data>
  <data name="PossiblyUnintendedUsageParameterlessGetExpressionTypeTitle" xml:space="preserve">
    <value>Possible unintended usage of parameterless GetExpressionType()</value>
  </data>
  <data name="PossiblyWrongStringComparisonWithSpansMessage" xml:space="preserve">
    <value>可能存在错误的字符串比较: 只有指向同一内存位置时，跨度才相等。是否要比较跨度内容?</value>
  </data>
  <data name="RedundantElseKeyword" xml:space="preserve">
    <value>冗余的 'else' 关键字</value>
  </data>
  <data name="OrSafelyHandlingNull__InGetAccessor_Text" xml:space="preserve">
    <value>，或者安全地处理 '{2}' 访问器中 '{0}' 为 {1} 的情况</value>
  </data>
  <data name="CompilerWarning_CS8002_Title" xml:space="preserve">
    <value>引用程序集没有强名称</value>
  </data>
  <data name="ExtensionDisallowsNameErrorMessage" xml:space="preserve">
    <value>扩展声明可能不具有名称</value>
  </data>
  <data name="DoubleNegationOperator" xml:space="preserve">
    <value>双重求反运算符</value>
  </data>
  <data name="ConstantInitializerMustBeCompileTimeConstantMessage" xml:space="preserve">
    <value>常量初始值设定项必须为编译时常量</value>
  </data>
  <data name="CSharpFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_generic_brackets" xml:space="preserve">
    <value>泛型中括号周围</value>
  </data>
  <data name="ReplaceWithSimpleAssignment_Text" xml:space="preserve">
    <value>替换为简单赋值</value>
  </data>
  <data name="SubpatternContainingDiscardPatternOrEmptyObjectPatternCanBeRemoved" xml:space="preserve">
    <value>可以移除包含弃元模式或空对象模式的子模式</value>
  </data>
  <data name="CannotDeriveFromTheDynamicTypeMessage" xml:space="preserve">
    <value>“{0}”: 无法从动态类型派生</value>
  </data>
  <data name="MethodParameterHasTheSameNameAsAFieldPropertyAndHidesIt" xml:space="preserve">
    <value>方法形参与字段/属性同名，并将其隐藏</value>
  </data>
  <data name="ConversionFrom_To__Text" xml:space="preserve">
    <value>从 '{0}' 到 '{1}' 的转换</value>
  </data>
  <data name="ThelSuffixIsEasilyConfusedWithTheDigitUseLForClarityMessage" xml:space="preserve">
    <value>'l' 后缀容易与数字 '1' 混淆，为了清楚起见，请使用 'L'</value>
  </data>
  <data name="InactivePreprocessorBranch_ToolTip" xml:space="preserve">
    <value>停用的预处理程序分支</value>
  </data>
  <data name="UseIsOperator_Text" xml:space="preserve">
    <value>使用 'is' 运算符</value>
  </data>
  <data name="CannotBeOverridenByMethodMessage" xml:space="preserve">
    <value>'{0}' 无法重写 '{1}'，因为后者不是方法</value>
  </data>
  <data name="TheReturnTypeOfOperatorTrueOrFalseMustBeBoolMessage" xml:space="preserve">
    <value>运算符 True 或 False 的返回类型必须是 bool</value>
  </data>
  <data name="ArglistIsNotAllowedInTheParameterListOfIteratorsMessage19" xml:space="preserve">
    <value>迭代器的参数列表中不允许有 __arglist</value>
  </data>
  <data name="RedundantcaseLabelBeforeDefaultSection" xml:space="preserve">
    <value>default 部分之前存在冗余的 'case' 标签</value>
  </data>
  <data name="OutAttrOnRefReadonlyParamMessage" xml:space="preserve">
    <value>ref readonly 形参不能具有 Out 特性</value>
  </data>
  <data name="TheNullableAnnotationOnClassConstraintIsRedundantBecauseTypeParameterIsConstrainedByNonNullableTypeMessage" xml:space="preserve">
    <value>'{0}?' 约束上的可以为 null 的注解冗余，因为类型形参 '{1}' 受不可以为 null 的类型 '{2}' 约束</value>
  </data>
  <data name="CompilerWarning_CS8509_Title" xml:space="preserve">
    <value>switch 表达式不会处理属于其输入类型的所有可能值(它并非详尽无遗)。</value>
  </data>
  <data name="TheswitchExpressionDoesNotHandleAllPossibleInputsItIsNotExhaustiveForExampleThePatternIsNotCoveredMessage" xml:space="preserve">
    <value>'switch' 表达式不处理所有可能的输入(它不是详尽的)。例如，不涵盖模式 '{0}'。</value>
  </data>
  <data name="WhenLambdaSignatureContainsSingleImplicitlyTypedParameterSignatureParenthesesCanBeOmitted" xml:space="preserve">
    <value>当 lambda 签名包含一个隐式类型化形参时，可以省略签名圆括号</value>
  </data>
  <data name="RedundantSwitchExpressionArmsMessage" xml:space="preserve">
    <value>冗余的 'switch' 表达式 arm</value>
  </data>
  <data name="UseNullableAnnotationInsteadOfAnAttribute" xml:space="preserve">
    <value>使用可以为 null 的注解而不是特性</value>
  </data>
  <data name="PartialMethodsMustHaveAvoidReturnTypeUnlessLanguageVersionOrGreaterIsUsedMessage" xml:space="preserve">
    <value>除非使用语言版本 '9.0' 或更高版本，否则分部方法必须具有 'void' 返回值类型</value>
  </data>
  <data name="CompilerWarning_CS8634_Title" xml:space="preserve">
    <value>类型不能用作泛型类型或方法中的类型参数。类型参数的为 Null 性与 “class” 约束不匹配。</value>
  </data>
  <data name="TheConstraintMustComeBeforeAnyOtherConstraintsMessage" xml:space="preserve">
    <value>'{0}' 约束必须在任何其他约束之前</value>
  </data>
  <data name="EnforceBracesInWhileStatement_Caption" xml:space="preserve">
    <value>在 'while' 语句中强制使用大括号</value>
  </data>
  <data name="ContainerNullabilityAttributeUsageWithDeclarationOfNonContainerType" xml:space="preserve">
    <value>将容器为 null 性特性与非容器类型声明一起使用</value>
  </data>
  <data name="ExpressionHasIdenticalTrueAndFalseBranches" xml:space="preserve">
    <value>'?:' 表达式具有相同的 true 和 false 分支</value>
  </data>
  <data name="AGotoCannotJumpToALocationAfterAUsingVariableDeclarationMessage" xml:space="preserve">
    <value>goto 不能跳转到 using 变量声明之后的位置</value>
  </data>
  <data name="AVoidTaskOrTaskOfTOrATaskLikeType_Text" xml:space="preserve">
    <value>一个 '{0}'、'{1}'、'{2}' 或类似任务的类型</value>
  </data>
  <data name="CannotImplicitlyImplementANonPublicFromInterfaceMessage" xml:space="preserve">
    <value>{0} '{1}' 不能从接口 {3} 隐式实现非 public {2}</value>
  </data>
  <data name="CompilerWarning_CS8897_Title" xml:space="preserve">
    <value>静态类型不能用作参数</value>
  </data>
  <data name="Type_Text" xml:space="preserve">
    <value>类型</value>
  </data>
  <data name="SecondParameterOfShiftOperatorShouldBeintMessage" xml:space="preserve">
    <value>移位运算符的第二个形参应为 'int'</value>
  </data>
  <data name="RedundantCqrsAttribute_Message" xml:space="preserve">
    <value>冗余 CQRS 特性</value>
  </data>
  <data name="ReturnValueOfPureMethodIsNotUsedMessage" xml:space="preserve">
    <value>纯方法的返回值未使用</value>
  </data>
  <data name="ParenthesesAreRedundantIfAttributeHasNoArguments8" xml:space="preserve">
    <value>如果特性没有实参，则圆括号冗余</value>
  </data>
  <data name="NonNullableIsUninitializedConsiderDeclaringTheAsNullableMessage" xml:space="preserve">
    <value>不可以为 null 的{0} '{1}' 未被初始化。请考虑添加 '{2}' 修饰符或将{0}声明为可以为 null。</value>
  </data>
  <data name="MethodHasAsyncOverloadWithCancellationSupportMessage" xml:space="preserve">
    <value>方法具有支持取消的异步重载</value>
  </data>
  <data name="ShebangDirectiveInProjectBasedProgramMessage" xml:space="preserve">
    <value>'#:' 指令只能在基于文件的程序('-features:FileBasedProgram')中使用</value>
  </data>
  <data name="NewConstraintCannotHaveRequiredMembersMessage" xml:space="preserve">
    <value>'{0}' 不能在泛型 {2} '{3}' 中满足形参 '{1}' 上的 'new()' 约束，因为 '{0}' 具有必需成员。</value>
  </data>
  <data name="ArgumentType_IsNotAssignableToParameterType_Message" xml:space="preserve">
    <value>实参类型 '{0}' 不可分配给形参类型 '{1}'</value>
  </data>
  <data name="ConstantShiftExpressionWithNonZeroOperandsResultsInZeroValue" xml:space="preserve">
    <value>具有非零操作数的常量位移表达式导致零值</value>
  </data>
  <data name="RedundantVerbatimStringPrefixMessage" xml:space="preserve">
    <value>冗余的逐字字符串字符串前缀</value>
  </data>
  <data name="RedundantLambdaParameterExplicitTypeSpecificationMessage" xml:space="preserve">
    <value>冗余的 lambda 形参显式类型规范</value>
  </data>
  <data name="InstanceAutoPropertiesInreadonlyStructsMustBereadonlyMessage" xml:space="preserve">
    <value>'readonly' 结构中的实例自动属性必须为只获取或仅初始化</value>
  </data>
  <data name="InExplicitInterfaceDeclarationIsNotAnInterfaceMessage" xml:space="preserve">
    <value>'显式接口声明中的“{0}”不是接口</value>
  </data>
  <data name="CSharpFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_switch_statement" xml:space="preserve">
    <value>switch 语句周围</value>
  </data>
  <data name="ShouldNotHaveCapturesOfTheContainingContextMessage" xml:space="preserve">
    <value>{0}不应捕获包含上下文</value>
  </data>
  <data name="EmptyNamespaceDeclarationIsRedundantMessage" xml:space="preserve">
    <value>空命名空间声明冗余</value>
  </data>
  <data name="CatchTypeShouldExtendSystemExceptionMessage" xml:space="preserve">
    <value>catch 类型应扩展 'System.Exception'</value>
  </data>
  <data name="CannotImplementBecauseTargetRuntimeDoesntSupportStaticAbstractMembersInInterfacesMessage" xml:space="preserve">
    <value>'{0}' 不能实现 '{1}'，因为目标运行时不支持接口中的 static abstract 成员</value>
  </data>
  <data name="NullabilityOfTypeOfParameterDoesntMatchImplementedMemberPossiblyBecauseOfNullabilityAttributesMessage" xml:space="preserve">
    <value>形参 '{0}' 的类型的为 null 性与被实现的成员 '{1}' 不匹配(可能是由于为 null 性特性)</value>
  </data>
  <data name="RefReturnOnlyParameterMessage" xml:space="preserve">
    <value>不能经 ref 形参通过引用返回{0} '{1}'；它只能在 return 语句中返回</value>
  </data>
  <data name="UsingSymbolRequiresOptingIntoPreviewFeatures_PrePunctuatedText" xml:space="preserve">
    <value>{0}使用 {1} 需要选择预览功能。</value>
  </data>
  <data name="UseExpressionBodyOrBlockBodyForProperties_Text" xml:space="preserve">
    <value>为属性/索引器/事件使用表达式主体或块主体</value>
  </data>
  <data name="AbstractCannotBePrivateMessage" xml:space="preserve">
    <value>abstract {0}不能为 private</value>
  </data>
  <data name="BaseInterfaceType_Text" xml:space="preserve">
    <value>基接口类型</value>
  </data>
  <data name="FunctionMustBeCalledOnServerSideDescription" xml:space="preserve">
    <value>报告在 'LINQ to Entities' 上下文之外调用时可能产生运行时异常的仅数据库方法</value>
  </data>
  <data name="UseLocalFunctionMessage" xml:space="preserve">
    <value>使用本地函数</value>
  </data>
  <data name="AforeachForEachForVBNETCanBeConvertedIntoALINQExpressionButAnotherGetEnumeratorMethodWillBeUsed" xml:space="preserve">
    <value>'foreach' (对于 VB.NET 为 'For Each')可以转换为 LINQ 表达式，但将使用另一个 'GetEnumerator' 方法</value>
  </data>
  <data name="CompilerWarning_CS8966_Title" xml:space="preserve">
    <value>CallerArgumentExpressionAttribute 将不起任何作用，因为它适用于不允许可选参数的上下文中使用的成员</value>
  </data>
  <data name="ReplaceWithFieldKeyword" xml:space="preserve">
    <value>替换为 'field' 关键字</value>
  </data>
  <data name="ImplicitlyTypedArrayCannotHaveSizeExpressionMessage" xml:space="preserve">
    <value>隐式类型化数组不能有大小表达式</value>
  </data>
  <data name="CannotConvertSourceType_ToTargetType_Text" xml:space="preserve">
    <value>不能将源类型 '{0}' 转换为目标类型 '{1}'</value>
  </data>
  <data name="RedundantSetsRequiredMembersAttributeDescription" xml:space="preserve">
    <value>[SetsRequiredMembers] 特性冗余，因为没有 'required' 成员</value>
  </data>
  <data name="ParametersMustHaveWhenExitingWithMessage" xml:space="preserve">
    <value>以 '{1}' 退出时形参 {0} 必须具有非 null 值</value>
  </data>
  <data name="PreferUsingNamedPositionalArgumentWhenBooleanNumericbyteOrcharLiteralValueIsPassed" xml:space="preserve">
    <value>传递布尔、数字、'byte' 或 'char' 字面量值时，首选使用命名/位置实参</value>
  </data>
  <data name="ScopedMismatchInParameterOfOverrideOrImplementationMessage" xml:space="preserve">
    <value>形参 '{0}' 的 'scoped' 修饰符与被重写或实现的{1} '{2}.{3}' 不匹配</value>
  </data>
  <data name="ParameterWithCallerInfoMustHaveDefaultValueMessage" xml:space="preserve">
    <value>带有调用方信息的形参必须具有默认值</value>
  </data>
  <data name="PossibleUnintendedReferenceComparison" xml:space="preserve">
    <value>可能非有意的引用比较</value>
  </data>
  <data name="refOroutParameterWithOptionalAttribute" xml:space="preserve">
    <value>具有 [Optional] 特性的 'ref' 或 'out' 形参</value>
  </data>
  <data name="AByReferenceReturnCannotBeUsedInThatReturnsMessage" xml:space="preserve">
    <value>按引用返回值不能在按值返回的{0}中使用</value>
  </data>
  <data name="AWithoutGetterOrInaccessibleGetterCannotBeReadMessage" xml:space="preserve">
    <value>不能读取没有 getter 或 getter 不能访问的{0}</value>
  </data>
  <data name="NameAndNameCannotDifferInCaseOnlyMessage" xml:space="preserve">
    <value>{0}名称 '{1}' 和{2}名称 '{3}' 不能仅大小写不同</value>
  </data>
  <data name="InconsistentAccessibilityBaseIsLessAccessibleThanMessage" xml:space="preserve">
    <value>可访问性不一致: 基{0} '{1}' 的可访问性低于{2} '{3}'</value>
  </data>
  <data name="TypeNameExpectedMessage" xml:space="preserve">
    <value>'{0}': '应为类型名称</value>
  </data>
  <data name="RedundantLambdaSignatureParenthesesMessage" xml:space="preserve">
    <value>冗余的 lambda 签名圆括号</value>
  </data>
  <data name="PatternIsAlwaysMessage" xml:space="preserve">
    <value>模式始终为 {0}</value>
  </data>
  <data name="InsertPragmaWarningDescriptionHintActionText" xml:space="preserve">
    <value>添加显式警告描述注释</value>
  </data>
  <data name="TheCannotBeUsedWithTypeArgumentsMessage" xml:space="preserve">
    <value>{0}“{1}”不能与类型参数一起使用</value>
  </data>
  <data name="CompilerWarning_CS8633_Title" xml:space="preserve">
    <value>类型参数的约束中的为 Null 性与隐式实现接口方法中的类型参数的约束不匹配。</value>
  </data>
  <data name="MethodWithParameterIsHiddenByOverloadMessage" xml:space="preserve">
    <value>带有{0}形参的方法被重载隐藏</value>
  </data>
  <data name="MissingCallingConventionSpecifiers_ToolTip" xml:space="preserve">
    <value>缺少调用约定说明符</value>
  </data>
  <data name="CompilerWarning_CS8612_Title" xml:space="preserve">
    <value>类型中引用类型的为 Null 性与隐式实现的成员不匹配。</value>
  </data>
  <data name="CompilerWarning_CS8009_Title" xml:space="preserve">
    <value>引用程序集具有不同区域性设置</value>
  </data>
  <data name="RemoveToList_Text" xml:space="preserve">
    <value>移除 ToList()</value>
  </data>
  <data name="AnonymousTypeProperty_Text" xml:space="preserve">
    <value>匿名类型属性</value>
  </data>
  <data name="AddOrRemoveTrailingCommaBeforeNewLine_Text" xml:space="preserve">
    <value>根据所选代码样式，在多行列表中的新行之前添加或移除尾随逗号</value>
  </data>
  <data name="TheNewConstraintMustBeTheLastConstraintSpecifiedMessage" xml:space="preserve">
    <value>new() 约束必须是指定的最后一个约束</value>
  </data>
  <data name="RedundantAttributeSuffix" xml:space="preserve">
    <value>冗余的 'Attribute' 后缀</value>
  </data>
  <data name="CodeIsUnreachableMessage" xml:space="preserve">
    <value>代码不可到达</value>
  </data>
  <data name="withExpressionModifiesAllAccessibleInstanceMembersUnlessItsAnUnintentionalMistakeItShouldMakeMoreSenseToCreateAnEntirelyNewInstance" xml:space="preserve">
    <value>'with' 表达式会修改所有可访问的实例成员。除非这是无意中出错，否则创建全新的实例应当会更有意义。</value>
  </data>
  <data name="NonNullableNotSatisfiedInConstructorConsiderDeclaringAsNullableMessage" xml:space="preserve">
    <value>在退出构造函数时，不可为 null 的 {0} '{1}' 必须包含非 null 值。请考虑添加 '{2}' 修饰符或将{0}声明为可以为 null。</value>
  </data>
  <data name="ApplicationOfAttributeUsageAttributeHasPropertyAssignmentToItsDefaultValue" xml:space="preserve">
    <value>[AttributeUsage] 特性的应用程序具有对其默认值的属性赋值</value>
  </data>
  <data name="EqualityComparisonOfFloatingPointNumbers" xml:space="preserve">
    <value>浮点数的相等比较</value>
  </data>
  <data name="CompilerWarning_CS8881_Title" xml:space="preserve">
    <value>在将控件返回给调用方之前，必须在构造函数中完全分配结构的字段。请考虑更新语言版本以自动默认字段。</value>
  </data>
  <data name="TheSourceExpressionOfisOperatorOrswitchStatementNeverMatchesTheProvidedPattern" xml:space="preserve">
    <value>'is' 运算符或 'switch' 语句的源表达式从未与提供的模式匹配</value>
  </data>
  <data name="CanReplaceCastWithTypeArgumentDescription" xml:space="preserve">
    <value>将转换表达式替换为显式类型实参以增强编译时安全性</value>
  </data>
  <data name="AttributesOnLambdaExpressionsRequireAParenthesizedParameterListMessage" xml:space="preserve">
    <value>lambda 表达式上的特性要求带圆括号的形参列表</value>
  </data>
  <data name="TheParameterOfAUnaryOperatorMustBeTheContainingTypeOrItsTypeParameterConstrainedToItMessage" xml:space="preserve">
    <value>一元运算符的形参必须为包含类型或其约束的类型形参</value>
  </data>
  <data name="ExpressionIsAlwaystrueOrAlwaysfalse" xml:space="preserve">
    <value>表达式始终为 'true' 或始终为 'false'</value>
  </data>
  <data name="NotResolvedParamsCollectionCreateMethodReferenceMessage" xml:space="preserve">
    <value>找不到 '{0}' 类型的合适构建器方法来创建 'params' 集合</value>
  </data>
  <data name="CannotMakeReferenceToVariableOfTypeMessage" xml:space="preserve">
    <value>无法引用类型为“{0}”的变量</value>
  </data>
  <data name="UseWithExpressionToCopyTuple" xml:space="preserve">
    <value>使用 'with' 表达式复制元组</value>
  </data>
  <data name="refKeywordMustImmediatelyPrecedeTheStructMessage" xml:space="preserve">
    <value>'ref' 关键字必须紧接在 'struct' 关键字之前</value>
  </data>
  <data name="DuplicateDefaultCaseLabelMessage" xml:space="preserve">
    <value>重复的 default case 标签</value>
  </data>
  <data name="TheNullableAnnotationOnclassConstraintIsRedundantBecauseTypeParameterIsConstrainedByNonNullableBaseType" xml:space="preserve">
    <value>'class?' 约束上的可以为 null 的注解冗余，因为类型形参受不可以为 null 的基类型约束</value>
  </data>
  <data name="RedundantEmptySwitchSection" xml:space="preserve">
    <value>冗余的空 switch 部分</value>
  </data>
  <data name="NPlusOneMainDescription" xml:space="preserve">
    <value>高亮显示有问题的 Entity Framework 查询，其中原始实体的导航属性可能会导致对数据库进行多次不必要的 SQL 查询(N+1 问题)</value>
  </data>
  <data name="ExplicitNameSpecificationOfValueTupleComponentIsRedundantItIsInferredFromInitializerExpression" xml:space="preserve">
    <value>值元组组件的显式名称规范冗余。它是从初始值设定项表达式中推断得出的。</value>
  </data>
  <data name="FileLocalTypeDisallowedInSignatureMessage" xml:space="preserve">
    <value>file-local 类型 '{0}' 不能用于非 file-local 类型 '{1}' 的成员签名</value>
  </data>
  <data name="ConvertToCompoundAssignmentMessage" xml:space="preserve">
    <value>转换为复合赋值</value>
  </data>
  <data name="ObsoleteOverridesNonObsoleteMessage" xml:space="preserve">
    <value>过时的{0} '{1}' 重写未过时的{2} '{3}'。</value>
  </data>
  <data name="StaticCannotImplementFromInterfaceMessage" xml:space="preserve">
    <value>static {0} '{1}' 不能从接口 {2} 实现{3}{0}</value>
  </data>
  <data name="NeitherisNorasAreValidOnPointerTypesMessage" xml:space="preserve">
    <value>'is' 和 'as' 对指针类型均无效</value>
  </data>
  <data name="AvoidUsingSynchronizationPrimitivesAslockObjects" xml:space="preserve">
    <value>避免使用同步基元作为 'lock' 对象</value>
  </data>
  <data name="WinRTClassCannotContainExternallyVisibleFieldsMessage" xml:space="preserve">
    <value>WinRT 类不能包含外部可见字段</value>
  </data>
  <data name="ParenthesesAreRedundantIfAttributeHasNoArgumentsMessage" xml:space="preserve">
    <value>如果特性没有实参，则圆括号冗余</value>
  </data>
  <data name="CompilerWarning_CS8618_Title" xml:space="preserve">
    <value>在退出构造函数时，不可为 null 的字段必须包含非 null 值。请考虑添加 'required' 修饰符或声明为可以为 null。</value>
  </data>
  <data name="PreprocessorInactiveBranch_RiderPresentableName" xml:space="preserve">
    <value>预处理程序//停用分支</value>
  </data>
  <data name="CannotawaitInTheBodyOfAlockStatementMessage" xml:space="preserve">
    <value>不能在 'lock' 语句体中 'await'</value>
  </data>
  <data name="RedundantclassKeywordInRecordDeclarationRecordsAreClassesByDefault" xml:space="preserve">
    <value>记录声明中存在冗余的 'class' 关键字: 默认情况下记录是类</value>
  </data>
  <data name="MergeConditionalExpressionTernaryOperatorIntoConditionalAccessExpression" xml:space="preserve">
    <value>将条件表达式(?: 三元运算符)合并到条件访问表达式中</value>
  </data>
  <data name="RedundantSwitchExpressionArmsDescription" xml:space="preserve">
    <value>catch-all arm '_ =&gt;' 之前和包含其内容的 arm 冗余</value>
  </data>
  <data name="ParameterOccursAfterInTheParameterListButIsUsedAsAnArgumentForInterpolatedStringHandlerConversionsThisWillRequireTheCallerToReorderParametersWithNamedArgumentsAtTheCallSiteConsiderPuttingTheInterpolatedStringHandlerParameterAfterAllArgumentsInvolvedMessage" xml:space="preserve">
    <value>在形参列表中，形参 '{0}' 出现在 '{1}' 之后，但它被用作内插字符串处理程序转换的实参。这将需要调用方在调用点使用命名实参重新排序形参。请考虑将内插字符串处理程序形参放在所有涉及的实参之后。</value>
  </data>
  <data name="TheTypeMustBeConvertibleToInOrderToUseItAsParameterInTheGenericMessage" xml:space="preserve">
    <value>类型 '{0}' 必须可以转换为 '{1}' 才能在泛型{3} '{4}' 中将其用作形参 '{2}'</value>
  </data>
  <data name="ThisCombinationOfArgumentsToIsDisallowedBecauseItMayExposeVariablesReferencedByParameterOutsideOfTheirDeclarationScopeMessage" xml:space="preserve">
    <value>不允许使用 '{0}' 的这种实参组合，因为它可能会在其声明作用域以外公开形参 '{1}' 引用的变量</value>
  </data>
  <data name="PossibleOverflow" xml:space="preserve">
    <value>可能溢出</value>
  </data>
  <data name="NonExternOperatorMustDeclareABodyMessage" xml:space="preserve">
    <value>非 abstract 和非 extern 运算符必须声明主体</value>
  </data>
  <data name="CSharpFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_parenthesis" xml:space="preserve">
    <value>圆括号周围</value>
  </data>
  <data name="ConditionalAccessQualifierExpressionIsKnownToBeNullOrNotNull2" xml:space="preserve">
    <value>条件访问限定符表达式已知为 null 或非 null</value>
  </data>
  <data name="TheswitchExpressionDoesNotHandleSomeNullInputsItIsNotExhaustiveForExampleThePatternIsNotCoveredMessage" xml:space="preserve">
    <value>'switch' 表达式不处理某些 null 输入(它不是详尽的)。例如，不涵盖模式 '{0}'。</value>
  </data>
  <data name="CompilerWarning_CS8625_Title" xml:space="preserve">
    <value>无法将 null 字面量转换为非 null 的引用类型。</value>
  </data>
  <data name="__CannotImplement_FromInterface_Return_Text" xml:space="preserve">
    <value>{0} '{1}' 不能从接口 '{3}' 实现{2}。返回值类型应为 '{4}'。</value>
  </data>
  <data name="UsePreferredCodeStyleToCheckJoinedSeparatevarUsagesInDeconstructionDeclarations" xml:space="preserve">
    <value>使用首选代码样式以检查析构声明中的联接/单独的 'var' 用法</value>
  </data>
  <data name="Property_Text" xml:space="preserve">
    <value>属性</value>
  </data>
  <data name="CompilerWarning_CS0183_Title" xml:space="preserve">
    <value>'"is" 表达式的给定表达式始终是所提供的类型</value>
  </data>
  <data name="RedundantConditionCheckBeforeAssignments" xml:space="preserve">
    <value>赋值前的条件检查冗余</value>
  </data>
  <data name="NotResolvedParamsCollectionDefaultCtorReferenceMessage" xml:space="preserve">
    <value>找不到 '{0}' 类型的默认构造函数来创建 'params' 集合</value>
  </data>
  <data name="CompilerWarning_CS8520_Title" xml:space="preserve">
    <value>给定的表达式始终与提供的常量匹配。</value>
  </data>
  <data name="TheParameterizedConstructorHasAParameterNamedvalueWhichIsTheSameAsTheDefaultReturnValueNameConsiderUsingAnotherNameForTheParameterMessage" xml:space="preserve">
    <value>形参化构造函数具有名为 'value' 的形参，它与默认返回值名称相同。请考虑为该形参使用其他名称。</value>
  </data>
  <data name="ConversionEqualityOrInequalityOperatorsDeclaredInInterfacesMustBeAbstractMessage" xml:space="preserve">
    <value>在接口中声明的转换、相等或不等运算符必须为 abstract 或 virtual</value>
  </data>
  <data name="TypeMemberIsInferredAlwaysNotToBeNullConsiderAnnotatingItWithNotNullOrItemNotNullAttribute" xml:space="preserve">
    <value>类型成员被推断为始终非 null: 请考虑使用 [NotNull] 或 [ItemNotNull] 特性对其进行注解</value>
  </data>
  <data name="CodeCleanupTask_ArrangeArgumentsStyle" xml:space="preserve">
    <value>应用实参样式(命名与位置)</value>
  </data>
  <data name="PossiblyUnintendedSideEffectsInsideConditionalInvocationMessage" xml:space="preserve">
    <value>当条件调用未执行时，将跳过外部可见的修改</value>
  </data>
  <data name="PossibleSystemInvalidCastException" xml:space="preserve">
    <value>可能出现 'System.InvalidCastException'</value>
  </data>
  <data name="CannotSpecifyreadonlyModifiersOnBothAndItsAccessorRemoveOneOfThemMessage" xml:space="preserve">
    <value>不能在{0}及其访问器上指定 'readonly' 修饰符。请移除其中之一。</value>
  </data>
  <data name="CompilerWarning_CS0612_Title" xml:space="preserve">
    <value>类型或成员已过时</value>
  </data>
  <data name="ConvertToAutoPropertyWithPrivateSetterMessage" xml:space="preserve">
    <value>转换为带 private setter 的自动属性</value>
  </data>
  <data name="InterceptorGlobalNamespaceMessage" xml:space="preserve">
    <value>不能在全局命名空间中声明拦截器</value>
  </data>
  <data name="TupleElementNameIsOnlyAllowedAtPositionMessage" xml:space="preserve">
    <value>只允许位置 {1} 使用元组元素名称“{0}”</value>
  </data>
  <data name="BaseTypeRequiredAttributeSupportsOnlyClassesAndInterfacesMessage" xml:space="preserve">
    <value>BaseTypeRequired 特性仅支持类和接口</value>
  </data>
  <data name="ConditionalAccessQualifierExpressionIsNotNullAccordingToNullableReferenceTypesAnnotations3" xml:space="preserve">
    <value>根据可以为 null 的引用类型的注解，条件访问限定符表达式不为 null</value>
  </data>
  <data name="ANamespaceShouldEitherBeFileScopedWithSemicolonOrBlockScopedWithBracesMessage" xml:space="preserve">
    <value>命名空间应为带分号的文件作用域命名空间，或带大括号的块作用域命名空间</value>
  </data>
  <data name="CSharpFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_member_access_symbols" xml:space="preserve">
    <value>成员访问符号周围</value>
  </data>
  <data name="AnExpressionTreeMayNotContainAnAccessOfStaticAbstractInterfaceMemberMessage" xml:space="preserve">
    <value>表达式树不能包含对 static abstract 接口成员的访问</value>
  </data>
  <data name="IncompleteDataUsageDescription" xml:space="preserve">
    <value>高亮显示可能会返回不完整数据的导航属性的用法</value>
  </data>
  <data name="AccessorBodyWithSimpleFieldKeywordReturnOrAssignmentIsRedundant" xml:space="preserve">
    <value>具有简单 'field' 关键字返回或赋值的访问器主体冗余</value>
  </data>
  <data name="TheClassTypeConstraintMustComeAfterConstraintMessage" xml:space="preserve">
    <value>类类型约束 '{0}' 必须在 '{1}' 约束之后</value>
  </data>
  <data name="RequiredMemberMustBeSetMessage" xml:space="preserve">
    <value>必需成员 '{0}' 必须在对象初始值设定项中设置</value>
  </data>
  <data name="UseCollectionExpressionMessage" xml:space="preserve">
    <value>使用集合表达式</value>
  </data>
  <data name="TypeParameterInheritsConflictingConstraintsAndMessage" xml:space="preserve">
    <value>类型参数“{0}”继承了彼此冲突的“{1}”和“{2}”约束</value>
  </data>
  <data name="CompilerWarning_CS8763_Title" xml:space="preserve">
    <value>不应返回标记为 [DoesNotReturn] 的方法。</value>
  </data>
  <data name="Properties_Caption" xml:space="preserve">
    <value>属性</value>
  </data>
  <data name="WinRTMethodCannotHaveOptionalParametersMessage" xml:space="preserve">
    <value>WinRT 方法不能有可选形参</value>
  </data>
  <data name="ConflictingStaticExtensionTypeArgumentErrorMessage_MethodTypeArgument" xml:space="preserve">
    <value>方法指定: {0}</value>
  </data>
  <data name="ConstantInitializerIsMissingMessage" xml:space="preserve">
    <value>缺少常量初始值设定项</value>
  </data>
  <data name="NullabilityAttributeUsedWithDeclarationThatCannotBeDirectlyReferencedFromOtherCode" xml:space="preserve">
    <value>与不能从其他代码直接引用的声明一起使用的为 null 性特性</value>
  </data>
  <data name="NameDisallowedMessage" xml:space="preserve">
    <value>类型和别名不能被命名为 '{0}'</value>
  </data>
  <data name="UseSymbolAliasTitle" xml:space="preserve">
    <value>使用别名</value>
  </data>
  <data name="MergeConditionalExpressionSettingApplyStyleHeuristicsDescription" xml:space="preserve">
    <value>使用此选项，只有在更改不会影响可读性的情况下才会建议转换。例如，如果应用它需要引入 null 合并分支，它将禁止建议。</value>
  </data>
  <data name="PossibleSystemInvalidOperationExceptionCollectionWasModifiedDescription" xml:space="preserve">
    <value>修改集合可能会导致下一次 foreach 迭代时出现 'System.InvalidOperationException: 集合已被修改'</value>
  </data>
  <data name="IteratorsCannotHaveParametersMessage" xml:space="preserve">
    <value>迭代器不能有 '{0}' 形参</value>
  </data>
  <data name="RedundantExplicitTypeInArrayCreation" xml:space="preserve">
    <value>数组创建中存在冗余的显式类型</value>
  </data>
  <data name="ConvertIfDeclarationIsNotOfBuiltInOrSimpleTypeAndIsNotEvidentFromTheUsage" xml:space="preserve">
    <value>如果声明不是内置类型或简单类型并且无法从用法明显看出，则转换</value>
  </data>
  <data name="CompilerWarning_CS2008_Title" xml:space="preserve">
    <value>未指定源文件</value>
  </data>
  <data name="ConvertToMethodCallWithExpressionInsideMessage6" xml:space="preserve">
    <value>转换为内部包含 '?:' 表达式的方法调用</value>
  </data>
  <data name="ConvertToMethodCallWithExpressionInsideMessage5" xml:space="preserve">
    <value>转换为内部包含 '?:' 表达式的方法调用</value>
  </data>
  <data name="refThisParameterMustBeAValueTypeOrAGenericTypeConstrainedToStructMessage" xml:space="preserve">
    <value>'ref this' 形参必须为值类型或受结构体约束的泛型类型</value>
  </data>
  <data name="ConvertToLambdaExpressionWhenPossible" xml:space="preserve">
    <value>转换为 lambda 表达式(如果可能)</value>
  </data>
  <data name="CanReplaceCastWithVariableTypeTitle" xml:space="preserve">
    <value>转换表达式可被替换为显式变量类型</value>
  </data>
  <data name="CorrespondingParameterHasCallerArgumentExpressionAttributeAppliedSoArgumentCouldBeOmitted" xml:space="preserve">
    <value>相应的形参应用了 'CallerArgumentExpression' 特性，因此可以省略实参</value>
  </data>
  <data name="HasParameterSButIsInvokedWithArgumentSMessage" xml:space="preserve">
    <value>{0} '{1}' 具有 {2} 个形参，但使用 {3} 个实参调用</value>
  </data>
  <data name="RedundantEmptyFinallyBlock" xml:space="preserve">
    <value>冗余的空 finally 块</value>
  </data>
  <data name="LocalVariableHasTheSameNameAsAFieldPropertyAndHidesIt" xml:space="preserve">
    <value>局部变量与字段/属性同名，并将其隐藏</value>
  </data>
  <data name="ReplaceSubstringMethodCallWithRangeIndexerAccess" xml:space="preserve">
    <value>将 'Substring' 方法调用替换为范围索引器访问</value>
  </data>
  <data name="CannotUseBeforeItIsDeclaredMessage" xml:space="preserve">
    <value>不能在声明{0} '{1}' 之前使用它</value>
  </data>
  <data name="ThisVariable_Text" xml:space="preserve">
    <value>'{0}' 变量</value>
  </data>
  <data name="UseNameofExpressionToReferenceTypesName" xml:space="preserve">
    <value>使用 'nameof' 表达式引用类型名称</value>
  </data>
  <data name="ReferenceToThisIsImmutableInReadonlyAccessor_Text" xml:space="preserve">
    <value>对 '{0}' 的引用在{2}的 '{1}' 访问器中不可变。</value>
  </data>
  <data name="RedundantConfigureAwaitTrue" xml:space="preserve">
    <value>使用冗余的 'ConfigureAwait' 捕获上下文</value>
  </data>
  <data name="LocalFunctionReturnValueIsNeverUsed" xml:space="preserve">
    <value>局部函数返回值从未被使用</value>
  </data>
  <data name="SpecifyStringComparisonExplicitly7" xml:space="preserve">
    <value>显式指定字符串比较</value>
  </data>
  <data name="AccordingToValuesOfTheBitMasksExpressionResultWillAlwaysBeTheSame" xml:space="preserve">
    <value>根据位掩码的值，表达式结果将始终相同</value>
  </data>
  <data name="IsRecursiveOnAllExecutionPathsMessage" xml:space="preserve">
    <value>{0}在所有执行路径上都是递归的</value>
  </data>
  <data name="AnonymousMethodToExpressionTreeMessage" xml:space="preserve">
    <value>无法将匿名方法表达式转换为表达式树</value>
  </data>
  <data name="CompilerWarning_CS7082_Title" xml:space="preserve">
    <value>CallerFilePathAttribute 将不起任何作用；它由 CallerLineNumberAttribute 重写</value>
  </data>
  <data name="ASingleElementDeconstructPatternRequiresSomeOtherSyntaxForDisambiguationItIsRecommendedToAddADiscardDesignatorAfterTheCloseParenMessage" xml:space="preserve">
    <value>单元素解构模式需要一些其他语法来消除歧义。建议在关闭 paren ")" 之后添加弃元指示符 "_"。</value>
  </data>
  <data name="CollectionCreateMethodHasXParametersButIsInvokedWithYArgumentsMessage" xml:space="preserve">
    <value>集合构建器 '{0}' 方法应为 {1} 个构造函数形参，但却使用 {2} 个构造函数实参调用</value>
  </data>
  <data name="DecomposeVariableIntoPositionalComponentsAndReplaceVariableUsagesWithCorrespondingComponentVariables" xml:space="preserve">
    <value>将变量分解为位置组件并将变量用法替换为相应的组件变量</value>
  </data>
  <data name="MathAbsArgumentIsAlwaysNonNegative" xml:space="preserve">
    <value>Math.Abs() 实参始终为非负</value>
  </data>
  <data name="AnAttributeTypeArgumentCannotUseTypeParametersMessage" xml:space="preserve">
    <value>特性类型实参不能使用类型形参</value>
  </data>
  <data name="SemicolonAfterClassStructEnumInterfaceNamespaceDeclarationsIsRedundantInC" xml:space="preserve">
    <value>类/结构/枚举/接口/命名空间声明后的分号在 C# 中冗余</value>
  </data>
  <data name="MemoryStackAllocationInsideALoopCanCauseATemporaryMemoryLeakBecauseTheAllocatedMemoryIsFreedOnlyWhenTheMethodReturnsMessage" xml:space="preserve">
    <value>循环内的内存堆栈分配可能会导致临时内存泄漏，因为仅在方法返回时才会释放分配的内存</value>
  </data>
  <data name="ConfigureAwaitAnalysisDisplayName_Text" xml:space="preserve">
    <value>ConfigureAwait 分析模式</value>
  </data>
  <data name="LoopCanBeConvertedIntoLINQExpressionMessage" xml:space="preserve">
    <value>循环可以转换为 LINQ 表达式</value>
  </data>
  <data name="TheExpressionMustBeOfTypeBecauseItIsBeingReturnedByReferenceMessage" xml:space="preserve">
    <value>表达式必须为 '{0}' 类型，因为它是通过引用返回的</value>
  </data>
  <data name="RedundantConditionalTernaryExpressionUsage" xml:space="preserve">
    <value>冗余的条件三元表达式用法</value>
  </data>
  <data name="ConvertToStaticClassMessage" xml:space="preserve">
    <value>转换为 '{0}' 类</value>
  </data>
  <data name="CannotAccessNonStaticInStaticContextMessage" xml:space="preserve">
    <value>不能在 static 上下文中访问非 static {0} '{1}'</value>
  </data>
  <data name="CannotInitializeRequiredMembersFromACollectionExpressionMessage" xml:space="preserve">
    <value>无法使用集合表达式初始化 '{0}'，因为不会初始化以下必需成员:</value>
  </data>
  <data name="TargetRuntimeDoesntSupportDefaultInterfaceImplementationMessage" xml:space="preserve">
    <value>目标运行时不支持默认接口实现</value>
  </data>
  <data name="KindNameIsAReadOnlyReferenceExceptIn_Text" xml:space="preserve">
    <value>{0} 为只读引用(在 {1} 中除外)。</value>
  </data>
  <data name="CanSimplifyDictionaryLookupWithTryGetValueTitle" xml:space="preserve">
    <value>可以使用 'TryGetValue' 简化字典查找</value>
  </data>
  <data name="WithElementIsNotFirstMessage" xml:space="preserve">
    <value>集合实参元素必须为第一个元素</value>
  </data>
  <data name="InterceptorLineOutOfRangeMessage" xml:space="preserve">
    <value>为行 '{1}' 配置了拦截器 '{0}'，该行号大于给定文件中的行数 '{2}'</value>
  </data>
  <data name="OperandOfExpressionConditionIsKnownToBeNullOrNotNull" xml:space="preserve">
    <value>'??' 表达式条件的操作数已知为 null 或非 null</value>
  </data>
  <data name="IncorrectSignatureOfMessage" xml:space="preserve">
    <value>'{0}' 的签名不正确</value>
  </data>
  <data name="TheConstraintsForTypeParameterOfMethodMustMatchTheConstraintsForTypeParameterOfInterfaceMethodConsiderUsingAnExplicitInterfaceImplementationInsteadMessage" xml:space="preserve">
    <value>方法“{1}”的类型参数“{0}”的约束必须与接口方法“{3}”的类型参数“{2}”的约束相匹配。请考虑改用显式接口实现。</value>
  </data>
  <data name="TargetTypedNewExpressions_Text" xml:space="preserve">
    <value>目标类型化新表达式</value>
  </data>
  <data name="CannotAssignvoidToARangeVariableMessage" xml:space="preserve">
    <value>不能将 'void' 赋给范围变量</value>
  </data>
  <data name="UseEventArgsEmptyMessage" xml:space="preserve">
    <value>使用 'EventArgs.Empty'</value>
  </data>
  <data name="MustHaveFieldOffsetAttributeMessage" xml:space="preserve">
    <value>标有 '[StructLayout(LayoutKind.Explicit)]' 的类型中的实例字段必须具有 '[FieldOffset]' 特性</value>
  </data>
  <data name="BackingFieldsOfInstanceAutoProperties_Text" xml:space="preserve">
    <value>实例自动属性的支持字段</value>
  </data>
  <data name="RuntimeDoesNotSupportByRefLikeGenerics" xml:space="preserve">
    <value>目标运行时不支持类似 by-ref 的泛型</value>
  </data>
  <data name="GCSuppressFinalizeIsInvokedForTypeWithoutDestructor" xml:space="preserve">
    <value>为不带析构函数的类型调用了 'GC.SuppressFinalize'</value>
  </data>
  <data name="ConvertIfDeclarationIsPartOfADeconstruction" xml:space="preserve">
    <value>如果声明是析构的一部分，则转换</value>
  </data>
  <data name="ArgumentOfTypeCannotBeUsedAsAnOutputOfTypeForParameterInDueToDifferencesInTheNullabilityOfReferenceTypesMessage" xml:space="preserve">
    <value>'{0}' 类型的实参不能用作 '{3}' 中形参 '{2}' 的 '{1}' 类型的输出，因为引用类型的为 null 性不同</value>
  </data>
  <data name="RedundantScopedParameterModifierDescription" xml:space="preserve">
    <value>'scoped' 形参修饰符冗余，因为目标形参已经被语言规则隐式 'scoped'</value>
  </data>
  <data name="CompilerWarning_CS8609_Title" xml:space="preserve">
    <value>返回类型中引用类型的为 Null 性与重写成员不匹配。</value>
  </data>
  <data name="ElementNamesAreNotPermittedWhenPatternMatchingViaSystemRuntimeCompilerServicesITupleMessage" xml:space="preserve">
    <value>通过 'System.Runtime.CompilerServices.ITuple' 进行模式匹配时，不允许使用元素名称</value>
  </data>
  <data name="CompilerWarning_CS8898_Title" xml:space="preserve">
    <value>静态类型不能用作返回类型</value>
  </data>
  <data name="DuplicateDefinitionOfGlobalUsingAliasMessage" xml:space="preserve">
    <value>重复的 global using 别名 '{0}' 的定义</value>
  </data>
  <data name="NullabilityOfTypeArgumentMustMatchclassConstraintInOrderToUseItAsParameterMessage" xml:space="preserve">
    <value>类型实参 '{0}' 的为 null 性必须与 'class' 约束匹配才能将其用作形参 '{1}'</value>
  </data>
  <data name="ConvertTowhileLoopMessage" xml:space="preserve">
    <value>转换为 'while' 循环</value>
  </data>
  <data name="ConditionalAccessQualifierExpressionIsNeverNullAccordingToNullableReferenceTypesAnnotationsMessage" xml:space="preserve">
    <value>根据可以为 null 的引用类型的注解，条件访问限定符表达式永远不为 null</value>
  </data>
  <data name="NoDefiningDeclarationFoundForImplementingDeclarationOfPartialMemberMessage" xml:space="preserve">
    <value>没有为分部方法{0} '{1}' 的实现声明找到定义声明</value>
  </data>
  <data name="PropertiesAndVariablesDynamic_RiderPresentableName" xml:space="preserve">
    <value>属性和变量//动态</value>
  </data>
  <data name="IQueryableIsPossiblyUnintentionallyUsedAsIEnumerableMessage" xml:space="preserve">
    <value>IQueryable 可能被无意中用作 IEnumerable</value>
  </data>
  <data name="PartialMethodDeclarationsOfHaveInconsistentNullabilityForTypeParameterMessage" xml:space="preserve">
    <value>'{0}' 的分部方法声明具有类型形参 '{1}' 的不一致为 null 性</value>
  </data>
  <data name="UseIndexFromEndExpression" xml:space="preserve">
    <value>使用从结尾索引表达式</value>
  </data>
  <data name="CompilerWarning_CS9208_Title" xml:space="preserve">
    <value>集合表达式可能会导致意外堆分配</value>
  </data>
  <data name="WhenCreatedTypeIsNotEvident_Caption" xml:space="preserve">
    <value>当创建的类型不明显时</value>
  </data>
  <data name="TheNameDoesNotMatchTheCorrespondingDeconstructParameterMessage" xml:space="preserve">
    <value>名称 '{0}' 与相应的 'Deconstruct()' 形参 '{1}' 不匹配</value>
  </data>
  <data name="CommandInvasionDescription" xml:space="preserve">
    <value>CQRS 上下文交集。命令从“查询”上下文调用。</value>
  </data>
  <data name="CompilerWarning_CS8768_Title" xml:space="preserve">
    <value>返回类型中引用类型的为 Null 性与实现的成员不匹配(可能是由于为 Null 性特性)。</value>
  </data>
  <data name="CodeCleanupTask_CSShortenReferences" xml:space="preserve">
    <value>缩短限定引用</value>
  </data>
  <data name="AsyncIteratorHasOneOrMoreParametersOfTypeCancellationTokenButNoneOfThemIsDecoratedWithTheEnumeratorCancellationAttributeSoTheCancellationTokenParameterFromTheGeneratedIAsyncEnumerableGetAsyncEnumeratorWillBeUnconsumedMessage" xml:space="preserve">
    <value>异步迭代器 '{0}' 具有一个或多个 'CancellationToken' 类型的形参，但所有这些形参均未使用 'EnumeratorCancellation' 特性装饰，因此将取消使用来自生成的 'IAsyncEnumerable&lt;&gt;.GetAsyncEnumerator' 的取消令牌形参</value>
  </data>
  <data name="LocalVariableHidesMemberTitle" xml:space="preserve">
    <value>局部变量会隐藏成员</value>
  </data>
  <data name="MethodHasOverloadWithCancellationSupportMessage" xml:space="preserve">
    <value>方法具有支持取消的重载</value>
  </data>
  <data name="LocalFunctions_Caption" xml:space="preserve">
    <value>局部函数</value>
  </data>
  <data name="TheReturnTypeForOrOperatorMustEitherMatchTheParameterTypeOrBeDerivedFromTheParameterTypeOrBeTheContainingTypesTypeParameterConstrainedToItUnlessTheParameterTypeIsADifferentTypeParameterMessage" xml:space="preserve">
    <value>除非形参类型是其他类型形参，否则 ++ 或 -- 运算符的返回值类型必须与形参类型匹配，或从形参类型派生，或为包含类型所约束的类型形参</value>
  </data>
  <data name="ExtractCommonBranchingCodeMessage" xml:space="preserve">
    <value>提取通用代码</value>
  </data>
  <data name="TheClassTypeConstraintMustComeBeforeAnyOtherConstraintsMessage" xml:space="preserve">
    <value>类类型约束“{0}”必须在其他任何约束之前</value>
  </data>
  <data name="UnsupportedTypeForListPatternMessage" xml:space="preserve">
    <value>列表模式可能不能用于 '{0}' 类型的值</value>
  </data>
  <data name="RedundantStringToCharArrayCallMessage" xml:space="preserve">
    <value>冗余的 'String.ToCharArray()' 调用</value>
  </data>
  <data name="TheTypeIsDefinedInAnAssemblyThatIsNotReferencedYouMustAddAReferenceToAssemblyMessage" xml:space="preserve">
    <value>类型“{0}”在未引用的程序集中定义。必须添加对程序集“{1}”的引用。</value>
  </data>
  <data name="CollectionExpressionRefStructMayAllocateMessage" xml:space="preserve">
    <value>'{0}' 类型的集合表达式可能会导致意外堆分配。请考虑显式创建一个数组，然后转换为 '{0}' 以将该分配设为显式。</value>
  </data>
  <data name="ConditionalAccessQualifierExpressionIsKnownToBeNullMessage" xml:space="preserve">
    <value>条件访问限定符表达式已知为 null</value>
  </data>
  <data name="UseEventArgsEmpty" xml:space="preserve">
    <value>使用 'EventArgs.Empty'</value>
  </data>
  <data name="IncompleteDataMainMessage" xml:space="preserve">
    <value>查询可能会返回相关实体的不完整数据</value>
  </data>
  <data name="CSharpFormatterHighlightingProvider_InternalConfigurableSeverityItems_Tabs_are_prohibited_here" xml:space="preserve">
    <value>此处禁止使用制表符</value>
  </data>
  <data name="BranchesOfArefTernaryOperatorCannotReferToVariablesWithIncompatibleDeclarationScopesMessage" xml:space="preserve">
    <value>'ref' 三元运算符的分支不能引用声明作用域不兼容的变量</value>
  </data>
  <data name="TheNullableAnnotationOnTypeConstraintIsRedundantBecauseTypeParameterHasConstraintMessage" xml:space="preserve">
    <value>类型约束 '{0}' 上的可以为 null 的注解冗余，因为类型形参 '{1}' 具有 '{2}' 约束</value>
  </data>
  <data name="StaticMemberCannotBeMarkedreadonlyMessage" xml:space="preserve">
    <value>static 成员 '{0}' 不能被标记为 'readonly'</value>
  </data>
  <data name="PossibleSystemInvalidCastExceptionMessage" xml:space="preserve">
    <value>可能的 '{0}.{1}'</value>
  </data>
  <data name="ExplicitRequiredMemberMessage" xml:space="preserve">
    <value>请勿使用 'System.Runtime.CompilerServices.RequiredMemberAttribute'。在必需字段和属性上改用 'required' 关键字。</value>
  </data>
  <data name="CompilerWarning_CS8777_Title" xml:space="preserve">
    <value>退出时，参数必须具有非 null 值。</value>
  </data>
  <data name="withExpressionModifiesAllAccessibleInstanceMembers" xml:space="preserve">
    <value>'with' 表达式会修改所有可访问的实例成员</value>
  </data>
  <data name="MethodsOverflowCheckedUncheckedOperation_RiderPresentableName" xml:space="preserve">
    <value>方法//溢出 checked/unchecked 运算</value>
  </data>
  <data name="PreferExplicitlyProvidedTupleComponentName" xml:space="preserve">
    <value>首选显式提供的元组组件名称</value>
  </data>
  <data name="TheNullableWarningSuppressionExpressionIsRedundantMessage" xml:space="preserve">
    <value>可以为 null 警告禁止表达式冗余</value>
  </data>
  <data name="CannotReturnByReferenceBecauseItWasInitializedToAValueThatCannotBeReturnedByReferenceMessage" xml:space="preserve">
    <value>“{0}”已初始化为不能通过引用返回的值，因此无法通过引用返回</value>
  </data>
  <data name="SeparateControlTransferStatementWithEmptyLineMessage" xml:space="preserve">
    <value>使用空行分隔控制传输语句</value>
  </data>
  <data name="SafeCastExpressionAlwaysSucceeds" xml:space="preserve">
    <value>安全转换表达式始终成功</value>
  </data>
  <data name="RedundantBracesMessage" xml:space="preserve">
    <value>冗余的大括号</value>
  </data>
  <data name="NamedExpressions_Caption" xml:space="preserve">
    <value>命名表达式</value>
  </data>
  <data name="RedundantSuppressNullableWarningsExpression" xml:space="preserve">
    <value>冗余的可以为 null 警告禁止表达式</value>
  </data>
  <data name="RightOperandIsAlwaysNullMessage" xml:space="preserve">
    <value>'??' 右操作数始终为 null</value>
  </data>
  <data name="IsNotARecognizedAttributeLocationAllAttributesInThisBlockWillBeIgnoredMessage" xml:space="preserve">
    <value>'{0}' 不是可识别的特性位置。将忽略此块中的所有特性。</value>
  </data>
  <data name="BitwiseOperationOnEnumWhichIsNotMarkedByFlagsAttribute" xml:space="preserve">
    <value>枚举上的按位运算未通过 [Flags] 特性进行标记</value>
  </data>
  <data name="_MustBeAssignedUponExit_Text" xml:space="preserve">
    <value>退出时必须为{0} 赋值</value>
  </data>
  <data name="DuplicatedChainedIfBodiesDescription" xml:space="preserve">
    <value>考虑合并重复的链式 'if' 分支以减少冗余</value>
  </data>
  <data name="TheGivenExpressionOfisOperatorIsAlwaysOfTheProvidedType30" xml:space="preserve">
    <value>'is' 运算符的表达式始终为提供的类型</value>
  </data>
  <data name="CircularConstraintDependencyInvolvingAndMessage" xml:space="preserve">
    <value>涉及“{0}”和“{1}”的循环约束依赖项</value>
  </data>
  <data name="ConvertNullableTToT" xml:space="preserve">
    <value>将 'Nullable&lt;T&gt;' 转换为 'T?'</value>
  </data>
  <data name="DefaultValue_Text" xml:space="preserve">
    <value>默认值</value>
  </data>
  <data name="ExampleOfTheDeadlockSituation_Text" xml:space="preserve">
    <value>死锁情况示例:</value>
  </data>
  <data name="SuggestToReplacexIsNotToXIs" xml:space="preserve">
    <value>建议将
          `x is not &gt; 42` 替换为 ` x is &lt;= 42`</value>
  </data>
  <data name="TheDllImportAttributeMustBeSpecifiedOnAMethodMarkedstaticAndexternMessage" xml:space="preserve">
    <value>必须在标记为 'extern' 的方法上指定 DllImport 特性，方法可以是 'static'，也可以是扩展成员</value>
  </data>
  <data name="RedundantTypeArgumentsInsideNameofDescription" xml:space="preserve">
    <value>通过从 'nameof' 中移除冗余类型实参来简化代码，因为它们不会影响结果</value>
  </data>
  <data name="OneWayOperationsMustNotReturnValues" xml:space="preserve">
    <value>单向运算不得返回值</value>
  </data>
  <data name="TypeUsedInAMustHaveAPublicVoidReturningDisposeInstanceMethodMessage" xml:space="preserve">
    <value>{1}中使用的类型 '{0}' 必须具有返回 void 的 public '{2}()' 实例方法</value>
  </data>
  <data name="CompilerWarning_CS1696_Title" xml:space="preserve">
    <value>#pragma 指令之后应是单行注释或行尾</value>
  </data>
  <data name="CompilerWarning_CS9123_Title" xml:space="preserve">
    <value>'&amp;' 运算符不应用于异步方法中的参数或局部变量。</value>
  </data>
  <data name="MergeStringInterpolationWithContainingOneMessage" xml:space="preserve">
    <value>将字符串内插与包含内插合并</value>
  </data>
  <data name="CompilerWarning_CS8860_Title" xml:space="preserve">
    <value>类型和别名不应命名为 "record"。</value>
  </data>
  <data name="CompilerWarning_CS8655_Title" xml:space="preserve">
    <value>Switch 表达式不会处理某些为 null 的输入。</value>
  </data>
  <data name="ConversionToDerivedClassMessage" xml:space="preserve">
    <value>转换为派生类</value>
  </data>
  <data name="EnforceBracesInForStatement_Caption" xml:space="preserve">
    <value>在 'for' 语句中强制使用大括号</value>
  </data>
  <data name="HeuristicallyUnreachableCaseDueToIntegerAnalysis" xml:space="preserve">
    <value>由于整数分析而启发式无法访问的 case</value>
  </data>
  <data name="CannotUsePrimaryParameterInsideInstanceMemberMessage" xml:space="preserve">
    <value>不能在实例成员中使用 '{0}' 主构造函数形参 '{1}'</value>
  </data>
  <data name="InvertIfStatementToReduceNesting" xml:space="preserve">
    <value>反转 'if' 语句以减少嵌套</value>
  </data>
  <data name="InvocationOfPolymorphicFieldLikeEventMessage" xml:space="preserve">
    <value>调用多态类似字段的事件</value>
  </data>
  <data name="MissingXMLCommentForPrivateOrInternalTypeOrMember" xml:space="preserve">
    <value>缺少 private 或 internal 类型或成员的 XML 注释</value>
  </data>
  <data name="RedundantArithmeticOverflowCheckingContext" xml:space="preserve">
    <value>冗余的算法溢出检查上下文</value>
  </data>
  <data name="WinRTSignaturesCannotHaverefParametersMessage" xml:space="preserve">
    <value>WinRT 签名不能有 'ref' 形参</value>
  </data>
  <data name="EmptyRegionMessage" xml:space="preserve">
    <value>此区域为空</value>
  </data>
  <data name="EventMustBeOfADelegateTypeMessage" xml:space="preserve">
    <value>事件必须为委托类型</value>
  </data>
  <data name="CantUserefIterationVariableBecausePropertyDoesntReturnByReferenceMessage" xml:space="preserve">
    <value>无法使用 'ref' 迭代变量，因为 '{0}' 属性不通过引用返回</value>
  </data>
  <data name="ReplaceAnEmptyArrayAllocationWithAUseOfThePredefinedTypeEmptyTypesField" xml:space="preserve">
    <value>将空数组分配替换为使用预定义 'Type.EmptyTypes' 字段</value>
  </data>
  <data name="RedundantVirtualModifierInInterfaceDeclaration" xml:space="preserve">
    <value>接口声明中存在冗余的 'virtual' 修饰符</value>
  </data>
  <data name="CompilerWarning_CS8774_Title" xml:space="preserve">
    <value>退出时，成员必须具有非 null 值。</value>
  </data>
  <data name="PartialPropertyAccessor_MustHaveADefinitionPartMessage" xml:space="preserve">
    <value>分部{0}访问器 '{1}' 已实现，但没有定义部分</value>
  </data>
  <data name="UseExpressionBodyOrBlockBodyForConstructors_Text" xml:space="preserve">
    <value>为构造函数使用表达式主体或块主体</value>
  </data>
  <data name="ByRefTypeAndAwait_Text" xml:space="preserve">
    <value>类型 '{0}' 的实例无法跨 'await' 或 'yield' 边界保留</value>
  </data>
  <data name="BadArrayDeclaratorToDeclareAManagedArrayTheRankSpecifierPrecedesTheVariablesIdentifierToDeclareAFixedSizeBufferFieldUseTheFixedKeywordBeforeTheFieldTypeMessage" xml:space="preserve">
    <value>错误的数组声明符: 要声明托管数组，秩说明符应位于变量标识符之前。要声明固定大小缓冲区字段，应在字段类型之前使用 fixed 关键字。</value>
  </data>
  <data name="ImplementationInheritanceIsNotAllowedInWinRTMessage" xml:space="preserve">
    <value>WinRT 中不允许实现继承</value>
  </data>
  <data name="CannotChangeTupleElementNamesWhenOverriding_Text" xml:space="preserve">
    <value>重写{0} '{1}' 时不能更改元组元素名称</value>
  </data>
  <data name="FunctionDoesNotReachItsEndOrAreturnStatementByAnyOfPossibleExecutionPaths" xml:space="preserve">
    <value>函数未通过任何可能的执行路径到达其结尾或 'return' 语句</value>
  </data>
  <data name="PropertiesAndVariablesLocalVariable_RiderPresentableName" xml:space="preserve">
    <value>属性和变量//局部变量</value>
  </data>
  <data name="NullableWarningSuppressionOperatorMightBeConfusedWithInvertedisExpression" xml:space="preserve">
    <value>可以为 null 警告禁止运算符可能与反转的 'is' 表达式混淆</value>
  </data>
  <data name="NamedArgumentsCannotPrecedePositionalMessage" xml:space="preserve">
    <value>命名实参不能在位置实参之前</value>
  </data>
  <data name="CannotUsebaseExpressionInThisContextMessage" xml:space="preserve">
    <value>不能在此上下文中使用 'base' 表达式</value>
  </data>
  <data name="CDoesntSupportrefOroutOptionalParameters" xml:space="preserve">
    <value>C# 不支持 'ref' 或 'out' 可选形参</value>
  </data>
  <data name="CompilerWarning_CS9099_Title" xml:space="preserve">
    <value>默认参数值在目标委托类型中不匹配。</value>
  </data>
  <data name="IntroduceOptionalParameters" xml:space="preserve">
    <value>引入可选形参</value>
  </data>
  <data name="PreferConcreteValueOverDefaultTitle" xml:space="preserve">
    <value>最好使用具体值而不是 'default' 或 'new()'</value>
  </data>
  <data name="UseIndexedPropertyInCOMImportTypesInsteadOfTheAccessorUsage" xml:space="preserve">
    <value>在 COM 导入类型中使用索引的属性而不是访问器用法</value>
  </data>
  <data name="TheParameterOfAUnaryOperatorMustBeOfTheContainingTypeMessage" xml:space="preserve">
    <value>一元运算符的形参必须为包含类型</value>
  </data>
  <data name="RangeVariable_Text" xml:space="preserve">
    <value>范围变量</value>
  </data>
  <data name="ConflictingVariableIsDefinedBelowMessage" xml:space="preserve">
    <value>下面定义了冲突的变量 '{0}'</value>
  </data>
  <data name="MergeSequentialNegatedNullPatternChecksIntoSingleRecursiveLogicalPatternCheck" xml:space="preserve">
    <value>将顺序求反的 null/模式检查合并到单个递归/逻辑模式检查中</value>
  </data>
  <data name="RedundantTypeArgumentsInsideNameofTitle" xml:space="preserve">
    <value>'nameof' 中的冗余类型实参</value>
  </data>
  <data name="LineDirectiveBadLineErrorMessage" xml:space="preserve">
    <value>行号必须在 1-16,707,565 范围内才能在 PDB 中正确表示</value>
  </data>
  <data name="CanBeDeclaredInInnerScopeMessage" xml:space="preserve">
    <value>{0} '{1}' 可以在内部作用域内声明</value>
  </data>
  <data name="OverridingDifferentRefnessMessage" xml:space="preserve">
    <value>形参 '{0} {1} {2}' 的引用种类修饰符与被重写或实现的成员中的相应形参 '{3} {4} {5}' 不匹配</value>
  </data>
  <data name="ExpressionIsAlwaystrueOrfalseAccordingToNullableReferenceTypesAnnotations" xml:space="preserve">
    <value>根据可以为 null 的引用类型的注解，表达式始终为 'true' 或 'false'</value>
  </data>
  <data name="AResultOfAstackallocExpressionCannotBeUsedInThisContextBecauseItMayBeExposedOutsideOfTheContainingMethodMessage" xml:space="preserve">
    <value>'stackalloc' 表达式的结果不能在此上下文中使用，因为它可能在包含方法以外公开</value>
  </data>
  <data name="UnnecessaryWhitespaceMessage" xml:space="preserve">
    <value>不必要的空格</value>
  </data>
  <data name="EmptyCharacterLiteralMessage" xml:space="preserve">
    <value>空字符文字</value>
  </data>
  <data name="InlineArrayConversionToSpanNotSupportedMessage" xml:space="preserve">
    <value>不能将表达式转换为 '{0}'，因为它不是可赋值变量</value>
  </data>
  <data name="ConversionOperatorMustHaveExactlyParameterMessage" xml:space="preserve">
    <value>转换运算符必须只有 1 个形参</value>
  </data>
  <data name="AnExpressionWhichCanHavenullValueIsAssignedToAnEntityMarkedWithValueCannotBeNullAttributeInParticularThisCanHappenWhenPassingSuchValueToAMethodWhoseParameterIsMarkedWithValueCannotBeNullAttribute" xml:space="preserve">
    <value>可以具有 'null' 值的表达式被赋给使用 '值不能为 null' 特性标记的实体。特别是，在将此类值传递给其形参使用 '值不能为 null' 特性标记的方法时，可能会发生这种情况。</value>
  </data>
  <data name="CodeCleanupTask_CSMakeAutoPropertyGetOnly" xml:space="preserve">
    <value>如果可能，将自动属性设为只获取</value>
  </data>
  <data name="CannotApplyEqualityOperatorToTypeMarkedByCannotApplyEqualityOperatorAttributeAttributeMessage" xml:space="preserve">
    <value>不能将相等运算符应用于通过 'CannotApplyEqualityOperatorAttribute' 特性标记的类型</value>
  </data>
  <data name="unsafeStatementIsRedundantMessage" xml:space="preserve">
    <value>'unsafe' 语句冗余</value>
  </data>
  <data name="UseNameofForDependencyPropertyTitle" xml:space="preserve">
    <value>注册 DependencyProperty 时使用 'nameof' 表达式</value>
  </data>
  <data name="ValueParameterSameNameAsExtensionTypeParameterErrorMessage" xml:space="preserve">
    <value>'value': 自动生成的形参名称与扩展类型形参名称冲突</value>
  </data>
  <data name="EitherParameterOrReturnTypeMustBeMessage" xml:space="preserve">
    <value>形参或返回值类型必须为 '{0}'</value>
  </data>
  <data name="SyntaxErrorMessage" xml:space="preserve">
    <value>语法错误</value>
  </data>
  <data name="RedundantAccessorBody" xml:space="preserve">
    <value>冗余的访问器体</value>
  </data>
  <data name="PossibleSystemArgumentOutOfRangeExceptionStartIndexShouldBeLessThanOrEqualToEndIndexMessage" xml:space="preserve">
    <value>可能出现 'System.ArgumentOutOfRangeException'。开始索引应小于或等于结束索引。</value>
  </data>
  <data name="CompilerWarning_CS9124_Title" xml:space="preserve">
    <value>形参被捕获到封闭类型状态，它的值也用于初始化字段、属性或事件。</value>
  </data>
  <data name="RedundantpartialModifierOnMethodDeclaration" xml:space="preserve">
    <value>方法声明中存在冗余的 'partial' 修饰符</value>
  </data>
  <data name="TheSetterOfAPropertyOrIndexerDoesNotUseItsvalueParameterAlsoAppliesToAddersAndRemoversOfEvents" xml:space="preserve">
    <value>属性或索引器的 setter 不使用其 'value' 形参。这也适用于事件的 adder 和 remover。</value>
  </data>
  <data name="ConstructorWithMustDisposeResourceAttributeBaseIsNotAnnotatedMessage" xml:space="preserve">
    <value>[MustDisposeResource] 注解不是继承自基构造函数</value>
  </data>
  <data name="IncorrectNumberOfTypeParametersInReferenceToMessage" xml:space="preserve">
    <value>{0} '{1}' 引用中的类型形参的数量不正确</value>
  </data>
  <data name="CompilerWarning_CS8387_Title" xml:space="preserve">
    <value>类型参数与外部方法中的类型参数有相同的类型。</value>
  </data>
  <data name="AdjustModifiersDeclarationOrder_Caption" xml:space="preserve">
    <value>调整修饰符声明顺序</value>
  </data>
  <data name="AnnotatingVoidMethodByMustUseReturnValueIsMeaninglessMessage" xml:space="preserve">
    <value>使用 [MustUseReturnValue] 注解 'void' 方法毫无意义</value>
  </data>
  <data name="CSharpFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_LINQ_queries" xml:space="preserve">
    <value>LINQ 查询周围</value>
  </data>
  <data name="PossibleMistakenEmptyStatementMessage" xml:space="preserve">
    <value>空语句可能有错误</value>
  </data>
  <data name="TheNullableAnnotationOnBaseTypeConstraintIsRedundantBecauseTypeParameterIsConstrainedByAnotherNonNullableBaseType" xml:space="preserve">
    <value>基类型约束上的可以为 null 的注解冗余，因为类型形参受另一个不可以为 null 的基类型约束</value>
  </data>
  <data name="ReplaceAsyncAwaitCodeWithTaskReturn" xml:space="preserve">
    <value>将 'async' 方法或匿名函数替换为返回 'Task'/'ValueTask' 值而不是等待它的普通非 'async' 代码。这会更改代码的异常处理语义。</value>
  </data>
  <data name="OperatorisTypeOfIsCanBeUsedInsteadOfComparingObjectsGetTypeAndInstanceOfSystemTypeObject" xml:space="preserve">
    <value>可以使用 'is'/'Type Of ... Is ...' 运算符替代将对象 GetType() 与 System.Type 对象的实例进行比较</value>
  </data>
  <data name="AssignmentInsteadOfDiscardTitle" xml:space="preserve">
    <value>具有类似弃元名称的变量的可疑使用</value>
  </data>
  <data name="CompilerWarning_CS1064_Title" xml:space="preserve">
    <value>与集合初始值设定项元素最匹配的重载 Add 方法已过时</value>
  </data>
  <data name="LambdaExpressionAnonymousMethodMustBeStaticToAvoidAllocations" xml:space="preserve">
    <value>lambda 表达式/匿名方法必须为 'static' 以避免分配</value>
  </data>
  <data name="ImplicitlyTypedDefaultParameterMessage" xml:space="preserve">
    <value>隐式类型化 lambda 形参 '{0}' 不能具有默认值</value>
  </data>
  <data name="ArgumentNameDoesNotMatchTheParameterThatWasChecked" xml:space="preserve">
    <value>实参名称与检查的形参不匹配</value>
  </data>
  <data name="MethodWithparamsIsInvokedWhileMoreSpecificMethodIsAvailable" xml:space="preserve">
    <value>在可以使用更具体的方法的情况下调用了带有 'params' 的方法</value>
  </data>
  <data name="FromPackage__Text" xml:space="preserve">
    <value>(来自软件包 {0})</value>
  </data>
  <data name="CompilerWarning_CS8643_Title" xml:space="preserve">
    <value>显式接口说明符中引用类型的 Null 性与该类型实现的接口不匹配。</value>
  </data>
  <data name="ArithmeticOverflowCheckingContextContainsNoOperatorsOrConversionsWithOverflowChecks" xml:space="preserve">
    <value>算术溢出检查上下文不包含带有溢出检查的运算符或转换</value>
  </data>
  <data name="ArrayCreationCanBeReplacedWithArrayInitializer" xml:space="preserve">
    <value>数组创建可被替换为数组初始值设定项</value>
  </data>
  <data name="OverriddenGetHashCodeCallsBaseObjectGetHashCode18" xml:space="preserve">
    <value>被重写的 GetHashCode 调用基 'Object.GetHashCode()'</value>
  </data>
  <data name="CompilerWarning_CS0219_Title" xml:space="preserve">
    <value>变量已被赋值，但从未使用过它的值</value>
  </data>
  <data name="InterceptorLineCharacterMustBePositiveMessage" xml:space="preserve">
    <value>提供给 InterceptsLocationAttribute 的行号和字符编号必须为正值</value>
  </data>
  <data name="InvalidXMLIncludeElementMessage" xml:space="preserve">
    <value>XML include 元素无效: {0}</value>
  </data>
  <data name="ExtensionMethodDefinedOnValueTypeCannotBeUsedToCreateDelegateMessage" xml:space="preserve">
    <value>在值类型上定义的扩展方法不能用于创建委托</value>
  </data>
  <data name="Constructors_Caption" xml:space="preserve">
    <value>构造函数</value>
  </data>
  <data name="CompilerWarning_CS1718_Title" xml:space="preserve">
    <value>对同一变量进行了比较</value>
  </data>
  <data name="ConvertToExpressionMessage" xml:space="preserve">
    <value>转换为 '||' 表达式</value>
  </data>
  <data name="InterceptorCannotBeGenericMessage" xml:space="preserve">
    <value>方法 '{0}' 必须为非泛型才能与 '{1}' 匹配</value>
  </data>
  <data name="ReplaceWithSingleCallToAny_Text" xml:space="preserve">
    <value>替换为对 Any(..) 的单个调用</value>
  </data>
  <data name="SuggestToReplaceObjectSequentialAssignmentsToNewlyCreatedObjectFieldsByObjectInitializer" xml:space="preserve">
    <value>建议通过对象初始值设定项将对象顺序赋值替换为新建的对象字段</value>
  </data>
  <data name="EmptyforLoopIsRedundant" xml:space="preserve">
    <value>空 'for' 循环冗余</value>
  </data>
  <data name="ImplementingInternalInterfaceIsNotAllowedInWinRTMessage" xml:space="preserve">
    <value>WinRT 中不允许实现内部接口</value>
  </data>
  <data name="ReturnValueOfPureMethodIsNotUsed" xml:space="preserve">
    <value>纯方法的返回值未使用</value>
  </data>
  <data name="PossibleMultipleEnumerationOfIEnumerableOrIAsyncEnumerableT" xml:space="preserve">
    <value>可能多次枚举 IEnumerable 或 IAsyncEnumerable&lt;T&gt;</value>
  </data>
  <data name="CSharpFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_semicolon" xml:space="preserve">
    <value>分号周围</value>
  </data>
  <data name="ObjectOrCollectionInitializerImplicitlyDereferencesPossiblyNullMemberMessage" xml:space="preserve">
    <value>对象或集合初始值设定项隐式解引用可能为 null 的成员 '{0}.{1}'</value>
  </data>
  <data name="CompilerWarning_CS3016_Title" xml:space="preserve">
    <value>作为特性参数的数组不符合 CLS</value>
  </data>
  <data name="DoNotUseThisIsReservedForCompilerUsageMessage" xml:space="preserve">
    <value>请勿使用“{0}”。这是保留给编译器使用的。</value>
  </data>
  <data name="NotDisposedResourceIsReturnedByPropertyTitle" xml:space="preserve">
    <value>属性的返回值必须由被调用者处置</value>
  </data>
  <data name="CompilerWarning_CS3003_Title" xml:space="preserve">
    <value>类型不符合 CLS</value>
  </data>
  <data name="AnonymusFunctions_Caption" xml:space="preserve">
    <value>匿名函数</value>
  </data>
  <data name="CanBeDeclaredAsNonNullableMessage" xml:space="preserve">
    <value>'{0}' 可被声明为不可以为 null 的</value>
  </data>
  <data name="CompilerWarning_CS8073_Title" xml:space="preserve">
    <value>由于此类型的值永不等于 "null"，该表达式的结果始终相同</value>
  </data>
  <data name="UseArrayEmptyMessage" xml:space="preserve">
    <value>使用 '{0}.{1}&lt;{2}&gt;()' 以避免数组分配</value>
  </data>
  <data name="WhenArrayTypeCanBeInferredFromInitializerArrayCreationExpressionCanBeConvertedToImplicitlyTyped" xml:space="preserve">
    <value>在可以从初始值设定项推断数组类型时，可以使用隐式类型化数组</value>
  </data>
  <data name="OtherValues_Caption" xml:space="preserve">
    <value>其他值</value>
  </data>
  <data name="OnlyOneCompilationUnitCanHaveTopLevelStatementsMessage" xml:space="preserve">
    <value>只有一个编译单元可具有顶级语句</value>
  </data>
  <data name="NonStaticStructMemberCannotHaveInitializerMessage" xml:space="preserve">
    <value>非 static 结构成员不能具有初始值设定项</value>
  </data>
  <data name="CompilerWarning_CS8512_Title" xml:space="preserve">
    <value>不要对大小写常量使用 "_"。</value>
  </data>
  <data name="FunctionIsRecursiveOnAllExecutionPaths" xml:space="preserve">
    <value>函数在所有执行路径上都是递归的</value>
  </data>
  <data name="RefReadonlyParameterDefaultValueMessage" xml:space="preserve">
    <value>为 'ref readonly' 形参 '{0}' 指定了默认值，但 'ref readonly' 应仅用于引用。请考虑将该形参声明为 'in'</value>
  </data>
  <data name="RedundantEmptySwitchSectionMessage" xml:space="preserve">
    <value>冗余的空 switch 部分</value>
  </data>
  <data name="ConvertSwitchStatementToSwitchExpressionMessage" xml:space="preserve">
    <value>将 '{0}' 语句转换为 '{0}' 表达式</value>
  </data>
  <data name="MergeCastWithTypePatternMessage" xml:space="preserve">
    <value>将转换与类型模式合并</value>
  </data>
  <data name="IdentifierOrASimpleMemberAccessExpectedMessage" xml:space="preserve">
    <value>应为标识符或简单成员访问</value>
  </data>
  <data name="BackingFieldIsAssignedButNeverUsedMessage" xml:space="preserve">
    <value>支持字段已被赋值，但从未被使用</value>
  </data>
  <data name="NullabilityOfReferenceTypesInReturnTypeDoesntMatchImplementedMemberMessage" xml:space="preserve">
    <value>返回值类型中引用类型的为 null 性与被实现的成员 '{0}' 不匹配</value>
  </data>
  <data name="InterceptorScopedMismatchMessage" xml:space="preserve">
    <value>无法拦截对具有 '{1}' 的 '{0}' 的调用，因为 'scoped' 修饰符或 '[UnscopedRef]' 特性不同</value>
  </data>
  <data name="MisplacedSlicePatternMessage" xml:space="preserve">
    <value>切片模式只能在列表模式中直接使用一次</value>
  </data>
  <data name="ThereIsNoTargetTypeForCollectionExpression_Text" xml:space="preserve">
    <value>集合表达式没有目标类型</value>
  </data>
  <data name="FixedPointerDeclarationIsRedundantBecauseAccessingElementsOfFixedSizeBufferDoesntRequirePinning" xml:space="preserve">
    <value>固定指针声明冗余，因为访问固定大小缓冲区的元素时不需要固定</value>
  </data>
  <data name="ConvertIfSimpleTypeNotAnArrayAndDoes_Text" xml:space="preserve">
    <value>如果为简单类型(不是数组且没有泛型形参)则转换</value>
  </data>
  <data name="FileLocalTypeDisallowedInTypeArgumentMessage" xml:space="preserve">
    <value>file-local 类型 '{0}' 不能用作非 file-local {1} '{2}' 中的类型实参</value>
  </data>
  <data name="MismatchOfOptionalParameterValueInOverriddenMethod" xml:space="preserve">
    <value>被重写的方法中的可选形参值不匹配</value>
  </data>
  <data name="MultipleSequentialOrderByInvocation" xml:space="preserve">
    <value>多个顺序 'OrderBy' 调用</value>
  </data>
  <data name="RedundantAttributeSuffixMessage" xml:space="preserve">
    <value>冗余的 'Attribute' 后缀</value>
  </data>
  <data name="CannotResolveCandidatesAreMessage" xml:space="preserve">
    <value>无法解析{0}:{3}{4}{1}{3}候选项为:{2}</value>
  </data>
  <data name="TheExpressionBeingAssignedToEnumMemberMustBeConstantMessage" xml:space="preserve">
    <value>赋给 '{0}' 枚举成员的表达式必须为常量</value>
  </data>
  <data name="AbstractAccessorCannotBePrivateMessage" xml:space="preserve">
    <value>abstract 访问器不能为 private</value>
  </data>
  <data name="SuppressNullableWarningsExpressionDoesntSuppressAnyWarningsAndIsAppliedToAnAlreadyNonNullableOperand" xml:space="preserve">
    <value>可以为 null 警告禁止表达式不禁止任何警告并应用于已不可以为 null 的操作数</value>
  </data>
  <data name="CompilerWarning_CS8848_Title" xml:space="preserve">
    <value>由于优先级，无法在此处使用运算符。</value>
  </data>
  <data name="ValueAssignedToAPropertyOfNonVariableQualifierExpressionCanBeLost" xml:space="preserve">
    <value>赋给非变量限定符表达式属性的值可能丢失</value>
  </data>
  <data name="AtLeastXFoldedElements_Text" xml:space="preserve">
    <value>≥{0} 个{0:choice:one#元素|other#元素}</value>
  </data>
  <data name="CqrsNamingRecommendationTitle" xml:space="preserve">
    <value>CQRS 实体命名不一致</value>
  </data>
  <data name="DoesNotHaveTypeParametersMessage" xml:space="preserve">
    <value>{0} '{1}' 没有类型形参</value>
  </data>
  <data name="DuplicatedSequentialIfBodiesDescription" xml:space="preserve">
    <value>考虑合并重复的连续 'if' 分支以减少冗余</value>
  </data>
  <data name="TheEnumeratorCancellationAttributeAppliedToParameterHasNoEffectTheAttributeIsOnlyEffectiveOnAParameterOfTypeCancellationTokenInAnAsyncIteratorMethodReturningIAsyncEnumerableMessage" xml:space="preserve">
    <value>应用于形参 '{0}' 的 'EnumeratorCancellation' 特性不起任何作用。该特性仅对返回 'IAsyncEnumerable&lt;&gt;' 的异步迭代器方法中 'CancellationToken' 类型的形参有效。</value>
  </data>
  <data name="ApplicationEntryPointsCannotBeAttributedWithUnmanagedCallersOnlyMessage" xml:space="preserve">
    <value>应用程序入口点不能具有 'UnmanagedCallersOnly' 特性</value>
  </data>
  <data name="CompilerWarning_CS1590_Title" xml:space="preserve">
    <value>XML 包含元素无效</value>
  </data>
  <data name="CannotUseVoidAsStackAllocTypeMessage" xml:space="preserve">
    <value>不能将 'void' 用作 'stackalloc' 的类型</value>
  </data>
  <data name="UseNullPropagationSettingApplyStyleHeuristicsTitle" xml:space="preserve">
    <value>应用代码样式启发</value>
  </data>
  <data name="FieldInWinRTStructCannotHaveInitializerMessage" xml:space="preserve">
    <value>WinRT 结构中的字段不能有初始值设定项</value>
  </data>
  <data name="ParenthesesCanBeSafelyAddedToExpressionsToClarifyPrecedence" xml:space="preserve">
    <value>可以在表达式中安全地添加圆括号以澄清优先级</value>
  </data>
  <data name="MemberMustHaveWhenExitingMessage" xml:space="preserve">
    <value>退出时成员 {0} 必须具有非 null 值</value>
  </data>
  <data name="CannotReturnByReferenceBecauseItIsNotArefVariableMessage" xml:space="preserve">
    <value>不能通过引用返回{0} '{1}'，因为它不是 'ref' 变量</value>
  </data>
  <data name="WhenArrayInitializerHasTheSameNumberOfElementsAsSpecifiedInSizeExpressionExplicitSizeSpecificationIsRedundant" xml:space="preserve">
    <value>当数组初始值设定项具有的元素数量与大小表达式中指定的数量相同时，显式大小规范冗余</value>
  </data>
  <data name="FunctionMustBeCalledOnClientSideDescription" xml:space="preserve">
    <value>报告不可转换为 SQL，并且在数据库上下文中调用时会产生运行时异常的方法</value>
  </data>
  <data name="InDeconstructionDeclarations" xml:space="preserve">
    <value>在析构声明中</value>
  </data>
  <data name="SpecifyStringComparisonExplicitly" xml:space="preserve">
    <value>显式指定字符串比较</value>
  </data>
  <data name="RawStringCanBeSimplified_Title" xml:space="preserve">
    <value>原始字符串可以简化</value>
  </data>
  <data name="MissingPredefinedMemberMessage" xml:space="preserve">
    <value>缺少编译器必需成员 '{0}'</value>
  </data>
  <data name="RedundantExplicitTupleComponentName" xml:space="preserve">
    <value>冗余的显式元组组件名称</value>
  </data>
  <data name="CompilerWarning_CS0437_Title" xml:space="preserve">
    <value>类型与导入命名空间冲突</value>
  </data>
  <data name="ArgumentMustBeAnAssignableVariableFieldOrAnArrayElementMessage" xml:space="preserve">
    <value>{0}'{1}' 实参必须为可赋值变量、字段或数组元素</value>
  </data>
  <data name="CompilerWarning_CS9195_Title" xml:space="preserve">
    <value>实参应与 'in' 关键字一起传递</value>
  </data>
  <data name="CompilerWarning_CS8425_Title" xml:space="preserve">
    <value>异步迭代器成员具有一个或多个 'CancellationToken' 类型的形参，但所有这些形参均未使用 'EnumeratorCancellation' 特性装饰，因此将取消使用来自生成的 'IAsyncEnumerable&lt;&gt;.GetAsyncEnumerator' 的取消令牌形参</value>
  </data>
  <data name="LeftOperandIsNeverNullMessage" xml:space="preserve">
    <value>'??' 左操作数永远不为 null</value>
  </data>
  <data name="ANamedCannotBeDeclaredInThisScopeBecauseItWouldGiveADifferentMeaningToWhichIsAlreadyUsedInAParentOrCurrentScopeToDenoteSomethingElseMessage" xml:space="preserve">
    <value>不能在此作用域内声明名为 '{1}' 的{0}，因为这会赋予 '{1}' 不同的含义，该含义已在父作用域或当前作用域中用于表示其他内容</value>
  </data>
  <data name="RedundantCatchClause" xml:space="preserve">
    <value>冗余 catch 子句</value>
  </data>
  <data name="SuggestToReplaceCollectionObjectConstructionWithCollectionExpressionSyntax" xml:space="preserve">
    <value>建议将集合对象构造和条目添加替换为 C# 12 集合表达式语法</value>
  </data>
  <data name="StructCannotContainExplicitParameterlessConstructorMessage" xml:space="preserve">
    <value>结构不能包含显式无形参构造函数</value>
  </data>
  <data name="SimplifyNegatedPatternMessage" xml:space="preserve">
    <value>简化求反模式</value>
  </data>
  <data name="CompilerWarning_CS3011_Title" xml:space="preserve">
    <value>只有符合 CLS 的成员才能是抽象的</value>
  </data>
  <data name="SpecifyStringCultureExplicitlyMessage" xml:space="preserve">
    <value>显式指定字符串区域性</value>
  </data>
  <data name="CannotAccessSymbolInTextArgument" xml:space="preserve">
    <value>不能访问文本实参中的符号</value>
  </data>
  <data name="NullabilityMismatchInParameterTypeOnInterceptorMessage" xml:space="preserve">
    <value>拦截器方法 '{1}' 的形参 '{0}' 的类型中的引用类型为 null 性与可拦截方法 '{2}' 不匹配</value>
  </data>
  <data name="WinRTTypeCannotContainBothStaticAndInstanceWithNameMessage" xml:space="preserve">
    <value>WinRT 类型不能同时包含名为 '{1}' 的 static 和实例{0}</value>
  </data>
  <data name="InconsistentAccessibilityAccessorIsLessAccessibleThanBaseAccessorMessage" xml:space="preserve">
    <value>可访问性不一致: 访问器 '{0}' 的可访问性低于基访问器</value>
  </data>
  <data name="CollectionBuilderAttributeMethodNameIsInvalid_Text" xml:space="preserve">
    <value>'CollectionBuilderAttribute' 方法名称必须为常量非空字符串或 'nameof' 表达式</value>
  </data>
  <data name="ExpressionCannotBeUsedInAnArgumentToNameofMessage" xml:space="preserve">
    <value>表达式不能在 nameof 的实参中使用</value>
  </data>
  <data name="CompilerWarning_CS9080_Title" xml:space="preserve">
    <value>在此上下文中使用变量可能会在变量声明范围以外公开所引用的变量</value>
  </data>
  <data name="ForeachIterationVariable_Text" xml:space="preserve">
    <value>foreach 迭代变量</value>
  </data>
  <data name="CompilerWarning_CS8359_Title" xml:space="preserve">
    <value>筛选器表达式是常量 “false”</value>
  </data>
  <data name="CannotJumpOutOfTheFinallyBlockMessage" xml:space="preserve">
    <value>不能跳出 finally 块</value>
  </data>
  <data name="ifReturnStatementCanBeReWrittenAsreturnStatement" xml:space="preserve">
    <value>'if-return' 语句可被重写为 'return' 语句</value>
  </data>
  <data name="AsyncCannotHaveParametersMessage" xml:space="preserve">
    <value>async {0}不能有 '{1}' 形参</value>
  </data>
  <data name="HidesOuterWithTheSameNameMessage" xml:space="preserve">
    <value>{0} '{1}' 会隐藏同名的外部{2}</value>
  </data>
  <data name="TheCallerArgumentExpressionAttributeAppliedToParameterWillHaveNoEffectBecauseItsSelfReferentialMessage" xml:space="preserve">
    <value>应用于形参 '{1}' 的 [{0}] 特性不起任何作用，因为它是自引用特性</value>
  </data>
  <data name="PartialMemberDeclarationsMustHaveMatchingRefReturnValuesMessage" xml:space="preserve">
    <value>分部成员声明必须具有匹配的 ref 返回值</value>
  </data>
  <data name="RedundantMethodOverloadUseAnotherMethodWithOptionalParameters" xml:space="preserve">
    <value>冗余的方法重载。请使用另一个具有可选形参的方法。</value>
  </data>
  <data name="MethodsMarkedWithOperationContractAttributeAsOneWayOperationsMustNotReturnValues" xml:space="preserve">
    <value>使用 OperationContract 特性标记的作为单向运算的方法不得返回值</value>
  </data>
  <data name="RedundantIEnumerableCastTOrIEnumerableOfTypeTCall5" xml:space="preserve">
    <value>冗余的 'IEnumerable.Cast&lt;T&gt;' 或 'IEnumerable.OfType&lt;T&gt;' 调用</value>
  </data>
  <data name="AssignmentCantBeOfTypeMessage" xml:space="preserve">
    <value>赋值不能为 '{0}' 类型</value>
  </data>
  <data name="AusingVariableCannotBeDeclaredDirectlyWithinAswitchSectionConsiderUsingBracesMessage" xml:space="preserve">
    <value>不能在 'switch' 部分直接声明 'using' 变量(请考虑使用大括号)</value>
  </data>
  <data name="DereferencingAnExpressionWhichCanHavenullValueThisWarningIsDetectedEitherWhenThereIsAComparisonWithnullEarlierInTheCodeOrWhenThisValueIsReturnedByAMemberMarkedWithValueCanBeNullAttribute" xml:space="preserve">
    <value>正在取消引用可以具有 'null' 值的表达式。当前面在代码中与 'null' 进行比较时，或者当此值由被标记为 'Value can be null' 特性的成员返回时，会检测到此警告。</value>
  </data>
  <data name="ExpressionTreeContainsInlineArrayOperationMessage" xml:space="preserve">
    <value>表达式树可能不包含内联数组访问或转换</value>
  </data>
  <data name="CompilerWarning_CS1522_Title" xml:space="preserve">
    <value>空的 switch 块</value>
  </data>
  <data name="PossibleMistakenSystemTypeArgumentMessage" xml:space="preserve">
    <value>可能存在 'System.Type' 类型的错误实参</value>
  </data>
  <data name="PatternIsAlwaystrueOrAlwaysfalse" xml:space="preserve">
    <value>模式始终为 'true' 或始终为 'false'</value>
  </data>
  <data name="UseExplicitOrImplicitModifierDefinitionForTypeMembers" xml:space="preserve">
    <value>对类型成员使用显式或隐式修饰符定义</value>
  </data>
  <data name="AmbiguousDocReferenceMessage" xml:space="preserve">
    <value>文档中的引用 '{0}' 不明确。{1}候选项为:{2}</value>
  </data>
  <data name="PossiblyMisleadingDefaultValueAttributeUsageToDefineOptionalParameterValueDefaultParameterValueAttributeShouldBeUsedInstead" xml:space="preserve">
    <value>可能使用误导性 'DefaultValueAttribute' 来定义可选形参值。应改为使用 'DefaultParameterValueAttribute'。</value>
  </data>
  <data name="AutoPropertyGetAccessorIsReadonlyBy_Text" xml:space="preserve">
    <value>自动属性 'get' 访问器默认为 'readonly'</value>
  </data>
  <data name="Method_ReturnType_Text" xml:space="preserve">
    <value>方法 '{0}' 返回值类型</value>
  </data>
  <data name="OperatorisCannotBeAppliedToOperandOfTypedefaultMessage" xml:space="preserve">
    <value>运算符 'is' 不能应用于 'default' 类型的操作数</value>
  </data>
  <data name="SeparateLocalFunctionsWithJumpStatementPluralMessage" xml:space="preserve">
    <value>使用显式 '{0}' 语句分隔局部函数</value>
  </data>
  <data name="CannotOverrideBecauseDoesNotHaveAnOverridableAccessorMessage" xml:space="preserve">
    <value>'{0}': 不能重写，因为 '{1}' 没有 overridable {2} 访问器</value>
  </data>
  <data name="CompilerWarning_CS0672_Title" xml:space="preserve">
    <value>成员将重写过时的成员</value>
  </data>
  <data name="CollectionExpressionEscapeErrorMessage" xml:space="preserve">
    <value>不能在此上下文中使用 '{0}' 类型的集合表达式，因为它可能会在当前作用域以外公开</value>
  </data>
  <data name="FeaturedefaultInterfaceImplementationIsNotAvailablePleaseUseLanguageVersionOrGreaterAndTargetRuntimeNETCoreOrGreaterMessage" xml:space="preserve">
    <value>“默认接口实现”功能不可用。请使用语言版本 8.0 或更高版本和目标运行时 .NET Core 3.0 或更高版本。</value>
  </data>
  <data name="RedundantEmptyTypeDeclarationBodyMessage" xml:space="preserve">
    <value>冗余的空 {0} 声明主体</value>
  </data>
  <data name="ComponentOfTheTupleIsNeverUsed" xml:space="preserve">
    <value>元组的组件从未被使用</value>
  </data>
  <data name="ACharacterMayOnlyBeEscapedByDoubling_Text" xml:space="preserve">
    <value>'}' 字符只能通过在内插字符串中加倍 '}}' 来转义</value>
  </data>
  <data name="CompilerWarning_CS8123_Title" xml:space="preserve">
    <value>由于分配目标指定了其他名称或未指定名称，因此元组元素名称被忽略。</value>
  </data>
  <data name="CompilerWarning_CS9198_Title" xml:space="preserve">
    <value>形参的引用种类修饰符与目标中的相应形参不匹配</value>
  </data>
  <data name="InconsistentAccessibilityParameterTypeIsLessAccessibleThanMessage" xml:space="preserve">
    <value>可访问性不一致: 形参类型 '{0}' 的可访问性低于{1} '{2}'</value>
  </data>
  <data name="TheGivenExpressionOfisOperatorMatchesTheProvidedTypeOnAnyNonNullValueConsiderComparingWithnullInstead" xml:space="preserve">
    <value>'is' 运算符的表达式与任何非 null 值上提供的类型匹配。请考虑改为与 'null' 进行比较。</value>
  </data>
  <data name="IncompleteDataMainDescription" xml:space="preserve">
    <value>高亮显示有问题的 Entity Framework 查询，其中原始实体的导航属性可能会返回不完整的数据</value>
  </data>
  <data name="ThisCodeCanHaveDifferentBehaviorWhenCompiledWithDifferentVersionsOfCompilerSeeChangesForforeachLoopInCAndVisualBasic" xml:space="preserve">
    <value>使用其他版本的编译器进行编译时，此代码可能具有不同的行为。请参阅 C# 5.0 和 Visual Basic 11 中 'foreach' 循环的更改。</value>
  </data>
  <data name="FileLocalTypeWithExplicitAccessibilityMessage" xml:space="preserve">
    <value>file-local 类型 '{0}' 不能使用可访问性修饰符</value>
  </data>
  <data name="StaticConstructor_Text" xml:space="preserve">
    <value>static 构造函数</value>
  </data>
  <data name="RequiredBaseTypeConflictingAnotherType" xml:space="preserve">
    <value>所需的基类型与另一个类型冲突</value>
  </data>
  <data name="AnExpressionTreeMayNotContainAByRefLikeTypeMessage" xml:space="preserve">
    <value>表达式树不能包含 ref 结构或受限类型 '{0}' 的值</value>
  </data>
  <data name="CSharpFormatterHighlightingProvider_InternalConfigurableSeverityItems_Line_should_be_indented_or_outdented_elsewhere" xml:space="preserve">
    <value>其他位置缺少缩进/减少缩进</value>
  </data>
  <data name="ValueAssignedIsNotUsedInAnyExecutionPathMessage" xml:space="preserve">
    <value>所赋的值未在任何执行路径中使用</value>
  </data>
  <data name="RemoveRedundantStatement_Text" xml:space="preserve">
    <value>移除冗余语句</value>
  </data>
  <data name="UsingDirectiveIsNotRequiredByTheCodeAndCanBeSafelyRemoved" xml:space="preserve">
    <value>代码不需要 using 指令，可以将其安全地移除</value>
  </data>
  <data name="RedundantBaseConstructorCall" xml:space="preserve">
    <value>冗余的基构造函数调用</value>
  </data>
  <data name="ParameterIsInferredAlwaysNotToBeNullConsiderAnnotatingItWithNotNullOrItemNotNullAttribute" xml:space="preserve">
    <value>形参被推断为始终非 null: 请考虑使用 [NotNull] 或 [ItemNotNull] 特性对其进行注解</value>
  </data>
  <data name="FunctionNeverReturnsMessage" xml:space="preserve">
    <value>函数从未返回</value>
  </data>
  <data name="ThereIsNoTargetTypeForMessage" xml:space="preserve">
    <value>"{0}" 没有目标类型</value>
  </data>
  <data name="UsageOfDefaultStructEquality_CheckNonUserTypes_Title" xml:space="preserve">
    <value>检查非用户类型</value>
  </data>
  <data name="UselessArithmeticalOperation" xml:space="preserve">
    <value>无意义的算术运算</value>
  </data>
  <data name="NullabilityOfReferenceTypesInTypeDoesntMatchImplementedMemberMessage" xml:space="preserve">
    <value>类型中引用类型的为 null 性与被实现的成员 '{0}' 不匹配</value>
  </data>
  <data name="OneOrMoreTypesRequiredToCompileADynamicExpressionCannotBeFoundAreYouMissingReferencesToMicrosoftCSharpDllAndSystemCoreDllMessage" xml:space="preserve">
    <value>找不到编译动态表达式所需的一个或多个类型。您是否缺少对 Microsoft.CSharp.dll 和 System.Core.dll 的引用?</value>
  </data>
  <data name="ReplaceVariableForAsExpressionTypeCheckAndTheFollowingCheckForItBeingNullWithNegatedCPatternMatchingExpression" xml:space="preserve">
    <value>将 'as' 表达式类型检查以及对它是否为 null 的后续检查的变量替换为求反的 C# 7.0 模式匹配表达式</value>
  </data>
  <data name="ReplaceWithSingleCallToSingle_Text" xml:space="preserve">
    <value>替换为对 Single(..) 的单个调用</value>
  </data>
  <data name="RefReturnOnlyParameterMemberMessage" xml:space="preserve">
    <value>不能经 ref 形参通过引用返回{0} '{1}' 的成员；它只能在 return 语句中返回</value>
  </data>
  <data name="FunctionBodyIsTooComplexToAnalyzeConsiderDecomposingItOrReducingNumberOfVariables" xml:space="preserve">
    <value>函数体太复杂，无法分析，请考虑将其分解或减少变量数</value>
  </data>
  <data name="CannotUseANullableReferenceTypeInObjectCreationMessage" xml:space="preserve">
    <value>无法在对象创建中使用可为 null 的引用类型</value>
  </data>
  <data name="ThePatternIsRedundantDescription" xml:space="preserve">
    <value>模式冗余，因为它不会在运行时产生任何实际检查。这通常表示模式匹配条件中存在错误。</value>
  </data>
  <data name="PartOfforeachForEachForVBNETStatementsBodyCanBeConvertedIntoALINQExpressionButAnotherGetEnumeratorMethodWillBeUsed" xml:space="preserve">
    <value>'foreach' (对于 VB.NET 为 'For Each')语句体的一部分可以转换为 LINQ 表达式，但将使用另一个 'GetEnumerator' 方法</value>
  </data>
  <data name="CorrespondingParameterIsOptionalAndHasTheSameValueSoArgumentCouldBeOmitted" xml:space="preserve">
    <value>相应的形参为可选形参并且具有相同的值，因此可以省略实参</value>
  </data>
  <data name="ThethisObjectCannotBeUsedBeforeAllOfItsFieldsAreAssignedToMessage" xml:space="preserve">
    <value>在给 'this' 对象的所有字段赋值之前不能使用该对象</value>
  </data>
  <data name="TrailingComma_Text" xml:space="preserve">
    <value>尾随逗号</value>
  </data>
  <data name="ExpressionHasIdenticalTrueAndFalseBranches8" xml:space="preserve">
    <value>'?:' 表达式具有相同的 true 和 false 分支</value>
  </data>
  <data name="CompilerWarning_CS8825_Title" xml:space="preserve">
    <value>由于参数为非 null，因此返回值必须为非 null。</value>
  </data>
  <data name="ReplaceAnEmptyArrayAllocationWithACallOfThePredefinedArrayEmptyTMethod" xml:space="preserve">
    <value>将空数组分配替换为调用预定义 'Array.Empty&lt;T&gt;()' 方法</value>
  </data>
  <data name="InlineArrayConversionToReadOnlySpanNotSupportedMessage" xml:space="preserve">
    <value>不能将表达式转换为 '{0}'，因为它可能无法通过引用传递或返回</value>
  </data>
  <data name="CompilerWarning_CS8962_Title" xml:space="preserve">
    <value>CallerArgumentExpressionAttribute 将不起任何作用；它由 CallerMemberNameAttribute 替代</value>
  </data>
  <data name="CompilerWarning_CS9192_Title" xml:space="preserve">
    <value>实参应与 'ref' 或 'in' 关键字一起传递</value>
  </data>
  <data name="TheAnnotationForNullableReferenceTypesShouldOnlyBeUsedInCodeWithinANullableAnnotationsContextAutoGeneratedCodeRequiresAnExplicitNullableDirectiveInSourceMessage" xml:space="preserve">
    <value>对可为 null 的引用类型的批注只应在 "#nullable" 批注上下文中的代码中使用。自动生成的代码要求在源中使用显式 "#nullable" 指令。</value>
  </data>
  <data name="ExceptionRethrowPossiblyIntendedMessage" xml:space="preserve">
    <value>可能打算重新抛出异常</value>
  </data>
  <data name="FormattingIsSpecifiedButInterpolatedStringExpressionIsNotIFormattableMessage" xml:space="preserve">
    <value>已指定格式设置，但内插字符串表达式不是 IFormattable</value>
  </data>
  <data name="RedundantEmptyArgumentListOnObjectCreationExpression" xml:space="preserve">
    <value>对象创建表达式中存在冗余的空实参列表</value>
  </data>
  <data name="AllFromContainerTypeKindAndName_Text" xml:space="preserve">
    <value>全部来自{0}</value>
  </data>
  <data name="ACharacterMustBeEscapedByDoublingIn_Text" xml:space="preserve">
    <value>'}' 字符必须在内插字符串中转义(通过加倍)</value>
  </data>
  <data name="InconsistentBracesStyleRedundantBracesMessage" xml:space="preserve">
    <value>大括号样式不一致: 大括号冗余</value>
  </data>
  <data name="PublicReadWritePropertyOrNonReadonlyFieldExpectedMessage" xml:space="preserve">
    <value>应为 public 读写属性或非只读字段</value>
  </data>
  <data name="KindNameIsReadOnlyExceptIn_Text" xml:space="preserve">
    <value>{0} 为只读(在 {1} 中除外)。</value>
  </data>
  <data name="RefReturnScopedParameterMemberMessage" xml:space="preserve">
    <value>不能通过引用返回{0} '{1}' 的成员，因为它的作用域仅限于当前方法</value>
  </data>
  <data name="DuplicateInitializationOfMemberMessage" xml:space="preserve">
    <value>成员“{0}”的初始化重复</value>
  </data>
  <data name="OperatorInExtensionOfStaticClassErrorMessage" xml:space="preserve">
    <value>扩展 static 类的 extension 块不能包含用户定义的运算符</value>
  </data>
  <data name="ConvertStaticMethodInvocationToExtensionMethodCall" xml:space="preserve">
    <value>将 static 方法调用转换为扩展方法调用</value>
  </data>
  <data name="UsePreferredArgumentStyleForStringLiteralValues" xml:space="preserve">
    <value>对字符串字面量值使用首选实参样式</value>
  </data>
  <data name="TypeCannotBeUsedInawaitForeachStatementBecauseItNeitherImplementsIAsyncEnumerableTNorHasSuitableGetAsyncEnumeratorMethodWhichReturnTypeHasCurrentPropertyAndMoveNextAsyncMethodMessage" xml:space="preserve">
    <value>只有类型 '{0}' 实现 'IAsyncEnumerable&lt;T&gt;'，或者具有合适的 'GetAsyncEnumerator' 方法(返回值类型具有 'Current' 属性和 'MoveNextAsync' 方法)，才能在 'await foreach' 语句中使用</value>
  </data>
  <data name="ConstantExpectedDescription" xml:space="preserve">
    <value>向使用 'ConstantExpectedAttribute' 注解的形参传递的实参无效</value>
  </data>
  <data name="TheFirstParameterOfTheExtensionMethodMustBeAValueTypeOrGenericTypeMessage" xml:space="preserve">
    <value>'{0}' 扩展方法的第一个形参必须为值类型或受结构体约束的泛型类型</value>
  </data>
  <data name="Methods_Caption" xml:space="preserve">
    <value>方法</value>
  </data>
  <data name="RefLocalAcrossAwait_Text" xml:space="preserve">
    <value>'ref' 局部变量无法跨 'await' 或 'yield' 边界保留</value>
  </data>
  <data name="UseWithExpressionToCreateAModifiedCopyOfATuple" xml:space="preserve">
    <value>使用 'with' 表达式创建元组的修改后副本</value>
  </data>
  <data name="ClassCannotBeInstantiated" xml:space="preserve">
    <value>类不能实例化</value>
  </data>
  <data name="NullabilityOfReferenceTypesInTypeOfParameterOfDoesntMatchTheParameterTypeOfTargetDelegatePossiblyBecauseOfNullabilityAttributesMessage" xml:space="preserve">
    <value>'{2}' 的形参 '{0} {1}' 类型中引用类型的为 null 性与目标委托 '{4}' 的形参类型 '{3}' 不匹配(可能是由于为 null 性特性)</value>
  </data>
  <data name="AConstOfReferenceTypeOtherThanStringCanOnlyBeInitializedWithNullMessage" xml:space="preserve">
    <value>字符串以外的引用类型的常量只能用 null 初始化</value>
  </data>
  <data name="SpecifyingSignatureInAnAnonymousMethodIsNotNecessaryBecauseNoneOfItsParametersAreUsedInTheBody" xml:space="preserve">
    <value>不需要在匿名方法中指定签名，因为它的所有形参均未在主体中使用</value>
  </data>
  <data name="nullIsNotAValidParameterNameToGetAccessToTheReceiverOfAnInstanceMethodUseTheEmptyStringAsTheParameterNameMessage" xml:space="preserve">
    <value>'null' 不是有效的形参名称。要访问实例方法的接收器，请使用空字符串作为形参名称。</value>
  </data>
  <data name="CompilerWarning_CS8624_Title" xml:space="preserve">
    <value>由于引用类型的可为 null 性差异，实参不能用作形参的输出。</value>
  </data>
  <data name="ExpectedCatchOrFinallyMessage" xml:space="preserve">
    <value>应输入 catch 或 finally</value>
  </data>
  <data name="TabulationCharactersAreNotAllowedMessage" xml:space="preserve">
    <value>不允许使用制表符</value>
  </data>
  <data name="CannotCreateAnInstanceOfTheAbstractClassMessage" xml:space="preserve">
    <value>不能创建 abstract 类 '{0}' 的实例</value>
  </data>
  <data name="CollectionExpressionFoundAddMethodIsStatic_Text" xml:space="preserve">
    <value>集合表达式的 'Add' 方法不能为 static。找到候选: '{0}'</value>
  </data>
  <data name="UseBracesToSeparateforeachStatementBody" xml:space="preserve">
    <value>使用大括号分隔 'foreach' 语句体</value>
  </data>
  <data name="thisParameterCannotBeDeclaredAsoutMessage" xml:space="preserve">
    <value>'this' 形参不能被声明为 'out'</value>
  </data>
  <data name="AThrowStatementWithNoArgumentsIsNotAllowedOutsideOfACatchClauseMessage" xml:space="preserve">
    <value>无参数的 throw 语句不允许在 catch 子句之外使用</value>
  </data>
  <data name="RedundantExplicitNullableTypeCreationMessage" xml:space="preserve">
    <value>冗余的显式可以为 null 的类型创建</value>
  </data>
  <data name="ConvertToMethodCallWithExpressionInsideMessage" xml:space="preserve">
    <value>转换为内部包含 '??' 表达式的方法调用</value>
  </data>
  <data name="DisallowedConditionalAccessAssignmentContextMessage" xml:space="preserve">
    <value>此上下文中不允许使用条件访问表达式</value>
  </data>
  <data name="StreamReadReturnValueIgnoredMessage" xml:space="preserve">
    <value>'{0}()' 的返回值会被忽略。请使用 '{1}()' 以确保从流中读取的字节数与预期值相等。</value>
  </data>
  <data name="AnExpressionTreeMayNotContainACoalescingOperatorWithAnullLeftHandSideMessage" xml:space="preserve">
    <value>表达式树不能包含左侧为 'null' 的合并运算符</value>
  </data>
  <data name="TypeUsedInAMustBeImplicitlyConvertibleToSystemIAsyncDisposableMessage" xml:space="preserve">
    <value>{1}中使用的类型 '{0}' 必须可隐式转换为 '{2}' 或实现合适的 '{3}' 方法。您是要使用 '{4}' 而不是 '{5}' 吗?</value>
  </data>
  <data name="CSharpFormatterHighlightingProvider_InternalConfigurableSeverityItems_Between_keyword_and_parenthesis" xml:space="preserve">
    <value>关键字和圆括号之间</value>
  </data>
  <data name="AnAttributeArgumentMustBeAConstantExpressiontypeofExpressionOrArrayCreationExpressionOfAnAttributeParameterTypeMessage" xml:space="preserve">
    <value>特性实参必须为常量表达式、'typeof()' 表达式或特性形参类型的数组创建表达式</value>
  </data>
  <data name="CompilerWarning_CS9057_Title" xml:space="preserve">
    <value>分析器程序集引用的编译器版本高于当前正在运行的版本。</value>
  </data>
  <data name="UseWithExpressionToCopyTupleMessage" xml:space="preserve">
    <value>使用 '{0}' 表达式复制元组</value>
  </data>
  <data name="PossibleUnintendedReferenceComparisonToGetAValueComparisonUseEqualsMethodMessage" xml:space="preserve">
    <value>可能非有意的引用比较。要获得值比较，请使用 'Equals' 方法。</value>
  </data>
  <data name="CanReplaceCastWithVariableTypeDescription" xml:space="preserve">
    <value>将转换表达式替换为显式变量类型以增强编译时安全性</value>
  </data>
  <data name="CompilerWarning_CS8885_Title" xml:space="preserve">
    <value>在对 "this" 对象的所有字段赋值之前，不能在构造函数中使用 "this" 对象。请考虑更新语言版本以自动默认未分配的字段。</value>
  </data>
  <data name="TheConstraintsForTypeArgumentsAreNotSatisfiednCandidatesAreMessage" xml:space="preserve">
    <value>类型实参的约束未满足。
候选项为:{0}</value>
  </data>
  <data name="ExtensionReceiverParameterCannotBeOfPointerTypeMessage" xml:space="preserve">
    <value>扩展的接收器形参不能为指针类型</value>
  </data>
  <data name="DuplicatedSwitchExpressionArmsMessage" xml:space="preserve">
    <value>重复的 'switch' arm</value>
  </data>
  <data name="RedundantSpreadElementMessage" xml:space="preserve">
    <value>冗余的 spread 元素</value>
  </data>
  <data name="ConvertConstructorToPrimaryConstructor" xml:space="preserve">
    <value>将构造函数转换为主构造函数</value>
  </data>
  <data name="AbstractEventCannotHaveInitializerMessage" xml:space="preserve">
    <value>abstract 事件不能有初始值设定项</value>
  </data>
  <data name="AnnotationConflictInHierarchy" xml:space="preserve">
    <value>层次结构中存在注解冲突</value>
  </data>
  <data name="NPlusOneUsageMessage" xml:space="preserve">
    <value>可能对数据库进行多次查询(N+1 问题)</value>
  </data>
  <data name="CompilerWarning_CS8614_Title" xml:space="preserve">
    <value>参数类型中引用类型的为 Null 性与隐式实现的成员不匹配。</value>
  </data>
  <data name="RedundantCast" xml:space="preserve">
    <value>冗余转换</value>
  </data>
  <data name="EnforceBracesInifStatement" xml:space="preserve">
    <value>在 'if' 语句中强制使用大括号</value>
  </data>
  <data name="DefaultParameterValueForMustBeACompileTimeConstantMessage" xml:space="preserve">
    <value>“{0}”的默认参数值必须是编译时常量</value>
  </data>
  <data name="RefReturningPropertiesCannotBeRequiredMessage" xml:space="preserve">
    <value>Ref 返回属性不能为必需</value>
  </data>
  <data name="OnlyClassOrInterfaceCouldBeSpecifiedAsConstraintMessage" xml:space="preserve">
    <value>只能将类或接口指定为约束</value>
  </data>
  <data name="MergeIntoLogicalPatternMessage" xml:space="preserve">
    <value>合并到逻辑模式中</value>
  </data>
  <data name="PossibleIncorrectImplementationOfDoubleCheckLockingPossibleMultipleWriteAccessToCheckedFieldMessage" xml:space="preserve">
    <value>可能错误地实现了双重检查锁定。可能对 checked 字段进行了多次写入访问。</value>
  </data>
  <data name="LocalFunctionHidesMethod" xml:space="preserve">
    <value>局部函数会隐藏方法</value>
  </data>
  <data name="JoinNullCheckWithAssignment" xml:space="preserve">
    <value>将 null 检查与赋值联接在一起</value>
  </data>
  <data name="InconsistentArgumentStyleNameIdentifierMessage" xml:space="preserve">
    <value>实参样式不一致: {0}名称标识符</value>
  </data>
  <data name="ModifiersOrderMustRespectReferenceOrder_Text" xml:space="preserve">
    <value>声明修饰符的顺序与代码样式设置不匹配</value>
  </data>
  <data name="CompilerWarning_CS8371_Title" xml:space="preserve">
    <value>此语言版本中不支持自动属性的字段针对特性。</value>
  </data>
  <data name="InvalidObjectCreationMessage" xml:space="preserve">
    <value>对象创建无效</value>
  </data>
  <data name="CannotConvertnullToBecauseItIsANonNullableValueTypeMessage" xml:space="preserve">
    <value>不能将 'null' 转换为 '{0}' ，因为它是不可以为 null 的值类型</value>
  </data>
  <data name="PartialMethodMustHaveAccessibilityModifiersBecauseItHasoutParametersMessage" xml:space="preserve">
    <value>分部方法“{0}”必须具有可访问性修饰符，因为它具有 "out" 参数</value>
  </data>
  <data name="CannotUseParameterInsideMessage" xml:space="preserve">
    <value>不能在{2}内使用 '{0}' 形参 '{1}'</value>
  </data>
  <data name="ListPatternRequiresLengthMessage" xml:space="preserve">
    <value>列表模式不能用于 '{0}' 类型的值。找不到合适的 'Length' 或 'Count' 属性。</value>
  </data>
  <data name="DuplicatedStatementsMessage" xml:space="preserve">
    <value>重复语句</value>
  </data>
  <data name="NullabilityOfTypeArgumentMustMatchnotnullConstraintInOrderToUseItAsParameterMessage" xml:space="preserve">
    <value>类型实参 '{0}' 的为 null 性必须与 'notnull' 约束匹配才能将其用作形参 '{1}'</value>
  </data>
  <data name="MethodLacksDoesNotReturnAnnotationInOrderToMatchOverriddenMemberMessage" xml:space="preserve">
    <value>方法 '{0}' 缺少匹配被重写的成员所需的 '[DoesNotReturn]' 注解</value>
  </data>
  <data name="SomeStatement_Text" xml:space="preserve">
    <value>'{0}' 语句</value>
  </data>
  <data name="ConstantShiftExpressionWithNonZeroOperandsResultsInZeroValueMessage" xml:space="preserve">
    <value>具有非零操作数的常量位移表达式导致零值</value>
  </data>
  <data name="CompilerWarning_CS8621_Title" xml:space="preserve">
    <value>返回类型中引用类型的为 Null 性与目标委托不匹配(可能是由于为 Null 性特性)。</value>
  </data>
  <data name="OverloadsWithTheSameNumberOfParametersAreNotAllowedPleaseMarkOneOfThemWithDefaultOverloadAttributeMessage" xml:space="preserve">
    <value>不允许使用具有相同数量形参的重载。请将其中一个标记为 'DefaultOverloadAttribute'。</value>
  </data>
  <data name="CannotUsevoidAsAFunctionPointerReturnTypeMessage" xml:space="preserve">
    <value>不能将 'void' 用作函数指针返回值类型</value>
  </data>
  <data name="EmptyDestructorIsRedundantMessage" xml:space="preserve">
    <value>空析构函数冗余</value>
  </data>
  <data name="InvalidModifierInOperatorDeclarationMessage" xml:space="preserve">
    <value>运算符声明中存在无效的修饰符 '{0}'</value>
  </data>
  <data name="AnExpressionTreeMayNotContainAnInterpolatedStringHandlerConversionMessage" xml:space="preserve">
    <value>表达式树不能包含内插字符串处理程序转换</value>
  </data>
  <data name="ConvertTheFollowingCodepreIfXNullXExprPreTopreXExprPre" xml:space="preserve">
    <value>将以下代码:
&lt;pre&gt;
  if (x = null) x = expr;
&lt;/pre&gt;
转换为:
&lt;pre&gt;
   x ??= expr;
&lt;/pre&gt;</value>
  </data>
  <data name="TypesAttribute_Text" xml:space="preserve">
    <value>类型//特性</value>
  </data>
  <data name="CheckedOperatorNotValidInExpressionTreeMessage" xml:space="preserve">
    <value>表达式树不能包含 checked 运算符 '{0}'</value>
  </data>
  <data name="MoveToExistingPositionalDeconstructionPattern" xml:space="preserve">
    <value>移动到现有位置析构模式</value>
  </data>
  <data name="PropertiesAndVariablesParameter_RiderPresentableName" xml:space="preserve">
    <value>属性和变量//形参</value>
  </data>
  <data name="TypeModifiersCodeStyleRule_TitleCaption" xml:space="preserve">
    <value>对类型使用显式或隐式修饰符定义</value>
  </data>
  <data name="InterceptorCharacterOutOfRangeMessage" xml:space="preserve">
    <value>为字符 '{1}' 配置了拦截器 '{0}'，该字符编号大于给定文件中的字符数 '{2}'</value>
  </data>
  <data name="XMLCommentIsNotPlacedOnAValidLanguageElementMessage" xml:space="preserve">
    <value>XML 注释没有放在有效语言元素上</value>
  </data>
  <data name="MergeSequentialNullTypeChecksInOrExpressionsIntoSingleConditionalAccessCheck" xml:space="preserve">
    <value>将 &amp;&amp; 或 || 表达式中的顺序 null/类型检查合并到单个条件访问检查中</value>
  </data>
  <data name="MemberCannotBeUsedInThisAttributeMessage" xml:space="preserve">
    <value>成员 {0} 不能在此特性中使用</value>
  </data>
  <data name="CannotConvertExpressionOfType_ToType_Text" xml:space="preserve">
    <value>不能将 '{0}' 类型的表达式转换为 '{1}' 类型</value>
  </data>
  <data name="BodyIsTooComplexToAnalyzeConsiderDecomposingItMessage" xml:space="preserve">
    <value>{0}体太复杂，无法分析，请考虑将其分解</value>
  </data>
  <data name="MightNotBeInitializedBeforeAccessingMessage" xml:space="preserve">
    <value>{0}在访问之前可能未被初始化</value>
  </data>
  <data name="MergeSequentialChecksIntoSingleConditionalAccessCheck" xml:space="preserve">
    <value>将顺序检查合并到单个条件访问检查中</value>
  </data>
  <data name="MergeAndPatternOperandsMessage" xml:space="preserve">
    <value>合并 'and' 模式操作数</value>
  </data>
  <data name="PreferWhetherToUseVarKeywordForDiscards_Text" xml:space="preserve">
    <value>首选为弃元使用 'var' 关键字</value>
  </data>
  <data name="CompilerWarning_CS8602_Title" xml:space="preserve">
    <value>解引用可能出现空引用。</value>
  </data>
  <data name="NonNullableNotInitializedInAnyExecutionPathMessage" xml:space="preserve">
    <value>不可以为 null 的{0} '{1}' 未在任何执行路径中初始化</value>
  </data>
  <data name="NullabilityOfReturnTypeOfDoesntMatchOverriddenMemberPossiblyBecauseOfNullabilityAttributesMessage" xml:space="preserve">
    <value>{0}的返回值类型的为 null 性与被重写的成员 '{1}' 不匹配(可能是由于为 null 性特性)</value>
  </data>
  <data name="CannotReturnByReferenceAMemberOfBecauseItWasInitializedToAValueThatCannotBeReturnedByReferenceMessage" xml:space="preserve">
    <value>“{0}”已初始化为不能通过引用返回的值，因此无法通过引用返回其成员</value>
  </data>
  <data name="CompilerWarning_CS8617_Title" xml:space="preserve">
    <value>参数类型中引用类型的为 Null 性与实现的成员不匹配。</value>
  </data>
  <data name="LineDirectiveCharacterNumberExpectedMessage" xml:space="preserve">
    <value>字符数应在 1-65,536 范围内</value>
  </data>
  <data name="AsyncMethodsCannotHaveArglistParametersMessage" xml:space="preserve">
    <value>async 方法不能有 '__arglist' 形参</value>
  </data>
  <data name="ConvertIfStatementToSwitchStatementSettingAssumeOpenTypeHierarchyTitle" xml:space="preserve">
    <value>假定类型可以通过外部代码扩展</value>
  </data>
  <data name="SlicePatternRequiresSystemRangeIndexerMessage" xml:space="preserve">
    <value>切片模式不能用于 '{0}' 类型的值。找不到合适的范围索引器或 'Slice' 方法。</value>
  </data>
  <data name="ExtensionReceiverParameterMustBeAValueTypeOrGenericTypeMessage" xml:space="preserve">
    <value>扩展的 '{0}' 接收器形参必须为值类型或受结构体约束的泛型类型</value>
  </data>
  <data name="RedundantExplicitNullableTypeCreation" xml:space="preserve">
    <value>冗余的显式可以为 null 的类型创建</value>
  </data>
  <data name="RedundantConstructorDeclarationMessage" xml:space="preserve">
    <value>冗余的构造函数声明</value>
  </data>
  <data name="SolutionCallGraph_Text" xml:space="preserve">
    <value>解决方案(调用图)</value>
  </data>
  <data name="WinRTOutParametersOfArrayTypeCannotBeAnnotatedWithReadOnlyArrayAttributeSinceTheContentsOfOutputArraysAreWritableMessage" xml:space="preserve">
    <value>不能使用 'ReadOnlyArrayAttribute' 注解数组类型的 WinRT out 形参，因为输出数组的内容是可写的</value>
  </data>
  <data name="Redundantis" xml:space="preserve">
    <value>冗余的 'is'</value>
  </data>
  <data name="InterceptorNameNotInvokedMessage" xml:space="preserve">
    <value>无法拦截可能的方法名称 '{0}'，因为它未被调用</value>
  </data>
  <data name="CodeCleanupTask_ArrangeBraces" xml:space="preserve">
    <value>添加/移除 'if-else'、'for'、'foreach'、'while'、'do-while'、'using'、'lock'、'fixed' 中的单条语句的大括号</value>
  </data>
  <data name="EnforceBracesInUsingStatement_Caption" xml:space="preserve">
    <value>在 'using' 语句中强制使用大括号</value>
  </data>
  <data name="SuggestForInterfaceTargetTypesDescription" xml:space="preserve">
    <value>当目标类型是集合接口类型(如 'IEnumerable&lt;T&gt;'、'IList&lt;T&gt;' 或 'IReadOnlyCollection&lt;T&gt;')时，建议使用集合表达式。请注意，将其替换为集合表达式会更改用于实现集合接口类型的实际运行时类型并引入额外的对象分配 – 这可能会在运行时观察到，并导致程序语义发生变化。</value>
  </data>
  <data name="RedundantObjectToStringCallMessage" xml:space="preserve">
    <value>冗余的 'Object.ToString()' 调用</value>
  </data>
  <data name="CannotUsethisModifierOnFirstParameterOfMethodDeclarationWithoutAReferenceToSystemCoreDllAddAReferenceToSystemCoreDllOrRemovethisModifierFromTheMethodDeclarationMessage" xml:space="preserve">
    <value>在不引用 System.Core.dll 的情况下，不能在方法声明的第一个形参上使用 'this' 修饰符。请添加对 System.Core.dll 的引用或从方法声明中移除 'this' 修饰符。</value>
  </data>
  <data name="OnlyAutoPropertyCanHaveInitializerMessage" xml:space="preserve">
    <value>只有自动属性和带支持字段的属性才能具有初始值设定项</value>
  </data>
  <data name="TypeParameterInheritsConflictingConstraintsclassAndMessage" xml:space="preserve">
    <value>类型形参 '{0}' 继承冲突的约束 'class' 和 '{1}'</value>
  </data>
  <data name="CodeCleanupTask_RemoveRedundantParentheses" xml:space="preserve">
    <value>移除冗余括号</value>
  </data>
  <data name="ExtensionReceiverParameterWithDefaultValueErrorMessage" xml:space="preserve">
    <value>扩展的接收器形参不能有默认值</value>
  </data>
  <data name="NoFoldedElements_Text" xml:space="preserve">
    <value>无元素</value>
  </data>
  <data name="RefReturnScopedParameterMessage" xml:space="preserve">
    <value>不能通过引用返回{0} '{1}'，因为它的作用域仅限于当前方法</value>
  </data>
  <data name="EventInInterfaceCannotHaveAddOrRemoveAccessorsMessage" xml:space="preserve">
    <value>接口中的事件不能有 add 或 remove 访问器</value>
  </data>
  <data name="TypeCastIsRedundantMessage" xml:space="preserve">
    <value>类型转换冗余</value>
  </data>
  <data name="MergeConditionalExpressionIntoConditionalAccess" xml:space="preserve">
    <value>将条件 ?: 表达式合并到条件访问中</value>
  </data>
  <data name="ConvertTheFollowingCodepreIfConditionXExprElseXExprPreTopreXConditionExprExprPre" xml:space="preserve">
    <value>将以下代码:
&lt;pre&gt;
  if (condition) x = expr1;
  else x = expr2;
&lt;/pre&gt;
转换为:
&lt;pre&gt;
  x = condition ? expr1 : expr2;
&lt;/pre&gt;</value>
  </data>
  <data name="CompilerWarning_CS8767_Title" xml:space="preserve">
    <value>参数类型中引用类型的为 Null 性与隐式实现的成员不匹配(可能是由于为 Null 性特性)。</value>
  </data>
  <data name="SourceFileCanNotContainBothFileScopedAndBlockScopedNamespacesMessage" xml:space="preserve">
    <value>源文件不得同时包含文件作用域命名空间和块作用域命名空间</value>
  </data>
  <data name="DoesNotContainADefinitionForAppendFormattedMethodMessage" xml:space="preserve">
    <value>'{0}' 不包含 'AppendFormatted' 方法的定义</value>
  </data>
  <data name="CompilerWarning_CS8608_Title" xml:space="preserve">
    <value>类型中引用类型的为 Null 性与重写成员不匹配。</value>
  </data>
  <data name="NeitherisNorasAreValidOnVoidTypeMessage" xml:space="preserve">
    <value>'is' 和 'as' 对 void 类型均无效</value>
  </data>
  <data name="BreakStatementIsMissingMessage" xml:space="preserve">
    <value>缺少 break 语句</value>
  </data>
  <data name="CommandInvasionTitle" xml:space="preserve">
    <value>CQRS 上下文交集。命令从“查询”上下文调用。</value>
  </data>
  <data name="IsLooksLikeAnInvertedisExpressionButInsteadAppliesNullableWarningSuppressionOperatorToItsOperand" xml:space="preserve">
    <value>'!is' 似乎是反转的 'is' 表达式，但却将可以为 null 警告禁止运算符应用于其操作数</value>
  </data>
  <data name="newCannotBeUsedWithValueTupleTypeUseATupleLiteralExpressionInsteadMessage" xml:space="preserve">
    <value>'new' 不能与值元组类型一起使用。请改用元组字面量表达式。</value>
  </data>
  <data name="NullabilityOfReferenceTypesInReturnTypeDoesntMatchImplementedMemberPossiblyBecauseOfNullabilityAttributesMessage" xml:space="preserve">
    <value>返回值类型中引用类型的为 null 性与被实现的成员 '{0}' 不匹配(可能是由于为 null 性特性)</value>
  </data>
  <data name="InstanceFieldOrReadablePropertyExpectedMessage" xml:space="preserve">
    <value>应为实例字段或可读属性</value>
  </data>
  <data name="CannotApplyIndexingToAnExpressionOfTypeMessage" xml:space="preserve">
    <value>不能将索引应用于 '{0}' 类型的表达式</value>
  </data>
  <data name="InvertedConstantExpectedAnnotation_Message" xml:space="preserve">
    <value>{0} 和 {1} 值被反转</value>
  </data>
  <data name="CannotAssignTousingVariableMessage" xml:space="preserve">
    <value>不能给 'using variable' 赋值</value>
  </data>
  <data name="OverridesObsoleteAddTheObsoleteAttributeToMessage" xml:space="preserve">
    <value>{0} '{1}' 重写过时的{2} '{3}'。请将 Obsolete 特性添加到 '{4}'。</value>
  </data>
  <data name="InterpolatedStringHandlerArgumentDisallowedErrorMessage" xml:space="preserve">
    <value>此上下文中不允许使用插值字符串处理程序实参</value>
  </data>
  <data name="RemoveRedundantPatternMatchingParentheses" xml:space="preserve">
    <value>移除冗余的模式匹配圆括号</value>
  </data>
  <data name="EmbeddedAttributeMustFollowPatternMessage" xml:space="preserve">
    <value>类型 '{0}' 必须为非泛型、internal、sealed、非 static，具有无形参构造函数，从 '{1}' 继承，并且能够应用于任何类型。</value>
  </data>
  <data name="ReplaceWithSingleCallToLastOrDefault_Text" xml:space="preserve">
    <value>替换为对 LastOrDefault(..) 的单个调用</value>
  </data>
  <data name="ThreadStaticDoesNothingWithInstanceFields" xml:space="preserve">
    <value>[ThreadStatic] 对实例字段不执行任何操作</value>
  </data>
  <data name="ReplaceDirectComparisonToNullAndEmptyStringWithStringIsNullOrEmptyCall" xml:space="preserve">
    <value>将与 null 和空字符串的直接比较替换为 'String.IsNullOrEmpty' 调用</value>
  </data>
  <data name="CompilerWarning_CS8769_Title" xml:space="preserve">
    <value>参数类型中引用类型的为 Null 性与实现的成员不匹配(可能是由于为 Null 性特性)。</value>
  </data>
  <data name="OfNamedAttributeArgumentMustBePublicMessage" xml:space="preserve">
    <value>命名特性实参的{0}必须为 public</value>
  </data>
  <data name="InlineOutVariableDeclaration" xml:space="preserve">
    <value>内联 'out' 变量声明</value>
  </data>
  <data name="PossiblyUnintendedSideEffectsInsideConditionalInvocationTitle" xml:space="preserve">
    <value>条件调用中可能发生的意外修改</value>
  </data>
  <data name="CompilerWarning_CS1701_Title" xml:space="preserve">
    <value>假定程序集引用与标识匹配</value>
  </data>
  <data name="BackingFieldOfPropertyWithfieldKeywordIsAssignedButNeverUsed" xml:space="preserve">
    <value>带有 'field' 关键字的属性的支持字段已被赋值，但从未被使用</value>
  </data>
  <data name="CompilerWarning_CS2002_Title" xml:space="preserve">
    <value>多次指定源文件</value>
  </data>
  <data name="PossibleAmbiguityWhileAccessingByThisInterfaceMessage" xml:space="preserve">
    <value>通过此接口访问时可能存在多义性:{0}</value>
  </data>
  <data name="FixedVariable_Text" xml:space="preserve">
    <value>固定变量</value>
  </data>
  <data name="TheTypeOfALocalDeclaredInAFixedStatementMustBeAPointerTypeMessage" xml:space="preserve">
    <value>fixed 语句中声明的局部变量类型必须是指针类型</value>
  </data>
  <data name="TypesRecordStruct_RiderPresentableName" xml:space="preserve">
    <value>类型//记录结构</value>
  </data>
  <data name="CompilerWarning_CS0168_Title" xml:space="preserve">
    <value>声明了变量，但从未使用过</value>
  </data>
  <data name="LocalFunctionMustDeclareABodyBecauseItIsNotMarkedstaticExternMessage" xml:space="preserve">
    <value>局部函数必须声明主体，因为它未被标记为 'static extern'</value>
  </data>
  <data name="ConvertTheFollowingCodepreVarXExprIfXNullXExprPreTopreVarXExprExprPre" xml:space="preserve">
    <value>将以下代码:
&lt;pre&gt;
  var x = expr1;
  if (x = null) x = expr2;
&lt;/pre&gt;
转换为:
&lt;pre&gt;
  var x = expr1 ?? expr2;
&lt;/pre&gt;</value>
  </data>
  <data name="RedundantScopedParameterModifierTitle" xml:space="preserve">
    <value>冗余的 'scoped' 形参修饰符</value>
  </data>
  <data name="UsePreferredArgumentStyleForLiteralValues" xml:space="preserve">
    <value>对字面量值使用首选实参样式</value>
  </data>
  <data name="WhenExtensionMethodIsInvokedAsStaticMethodConvertInvocationToExtensionMethodSyntax" xml:space="preserve">
    <value>当扩展方法作为 static 方法进行调用时，将调用转换为扩展方法语法</value>
  </data>
  <data name="NonNullableNotSatisfiedInConstructorConsiderDeclaringAsNullableFieldsMessage" xml:space="preserve">
    <value>在退出构造函数时，不可为 null 的字段 {0} 必须包含非 null 值。请考虑添加 '{1}' 修饰符或将字段声明为可以为 null。</value>
  </data>
  <data name="AnExpressionTreeMayNotContainAThrowExpressionMessage" xml:space="preserve">
    <value>表达式树不能包含 throw 表达式</value>
  </data>
  <data name="CompilerWarning_CS8605_Title" xml:space="preserve">
    <value>取消装箱可能为 null 的值。</value>
  </data>
  <data name="FixedSizeBufferElementTypeShouldBeOneOfSbyteByteShortUshortIntUintLongUlongCharFloatDoubleOrBoolMessage" xml:space="preserve">
    <value>固定大小的缓冲区元素类型应为 sbyte、byte、short、ushort、int、uint、long、ulong、char、float、double 或 bool 之一</value>
  </data>
  <data name="LocalConstant_Text" xml:space="preserve">
    <value>局部常量</value>
  </data>
  <data name="CollectionBuilderAttributeBuilderTypeMustBeNonGenericClassOrStruct_Text" xml:space="preserve">
    <value>'CollectionBuilderAttribute' 构建器类型必须为非泛型类或结构</value>
  </data>
  <data name="AttributesAreNotAllowedOnLocalFunctionParametersOrTypeParametersMessage" xml:space="preserve">
    <value>属性在本地函数参数或类型参数中不被允许</value>
  </data>
  <data name="StaticMemberInitializerRefersToStaticMemberBelowOrInOtherTypePartMessage" xml:space="preserve">
    <value>static 成员初始值设定项引用以下或其他类型部分中的 static 成员</value>
  </data>
  <data name="foreachStatementCannotOperateOnRefEnumeratorsInasyncOrIteratorMethodsMessage" xml:space="preserve">
    <value>'foreach' 语句不能在 'async' 或迭代器方法中的 ref 枚举器上执行</value>
  </data>
  <data name="AnonymousMethodParameterCannotBeparamsMessage" xml:space="preserve">
    <value>匿名方法形参不能是 'params'</value>
  </data>
  <data name="ConcreteBaseTypeIsRequiredByBaseTypeRequiredAttribute" xml:space="preserve">
    <value>'[BaseTypeRequired]' 特性需要具体的基类型</value>
  </data>
  <data name="TheFirstParameterOfAnExtensionMethodCannotBeDeclaredAsMessage" xml:space="preserve">
    <value>扩展方法的第一个形参不能被声明为 '{0}'</value>
  </data>
  <data name="EnforceBracesInfixedStatement" xml:space="preserve">
    <value>在 'fixed' 语句中强制使用大括号</value>
  </data>
  <data name="LambdaExpressionAnonymousMethodShouldNotHaveCapturesOfTheContainingContext" xml:space="preserve">
    <value>Lambda 表达式/匿名方法不应捕获包含上下文</value>
  </data>
  <data name="EntityFramework_UnlimitedStringLengthHighlighting_Description_Text" xml:space="preserve">
    <value>报告长度不受限的实体字符串属性</value>
  </data>
  <data name="UsageOfDefaultStructEqualityMessage" xml:space="preserve">
    <value>使用低效运行时提供的实现检查结构 '{0}' 的相等性</value>
  </data>
  <data name="CapturedVariableIsModifiedInTheOuterScopeMessage" xml:space="preserve">
    <value>捕获的变量已在外部作用域内修改</value>
  </data>
  <data name="TargetRuntimeDoesntSupportStaticAbstractMembersInInterfacesMessage" xml:space="preserve">
    <value>目标运行时不支持接口中的 static abstract 成员</value>
  </data>
  <data name="PossibleAmbiguityWhileAccessingMemberByInterface2" xml:space="preserve">
    <value>通过接口访问成员时可能存在多义性</value>
  </data>
  <data name="CannotPassArgumentWithDynamicTypeToParamsParameterOfLocalFunctionMessage" xml:space="preserve">
    <value>不能将具有动态类型的实参传递给局部函数 '{1}' 的 params 形参 '{0}'</value>
  </data>
  <data name="CannotAccessHereMessage" xml:space="preserve">
    <value>不能在此处访问{0} '{1}'</value>
  </data>
  <data name="UseNotNullPatternInsteadOfATypeCheckSucceedingOnAnyNotNullValueMessage" xml:space="preserve">
    <value>在任何非 null 值之后使用非 null 模式而非类型检查</value>
  </data>
  <data name="StaticInGenericTypeMessage" xml:space="preserve">
    <value>泛型类型中存在 static {0}</value>
  </data>
  <data name="RedundantstringFormatCall4" xml:space="preserve">
    <value>冗余的 'string.Format()' 调用</value>
  </data>
  <data name="FeatureIsNotAvailablePleaseUseLanguageVersionOrGreaterMessage8" xml:space="preserve">
    <value>功能 '{0}' 不可用。请使用语言版本 4.0 或更高版本。</value>
  </data>
  <data name="FeatureIsNotAvailablePleaseUseLanguageVersionOrGreaterMessage9" xml:space="preserve">
    <value>功能 '{0}' 不可用。请使用语言版本 5.0 或更高版本。</value>
  </data>
  <data name="TurnOffResourcesDisposePoints_Text" xml:space="preserve">
    <value>关闭资源处置点</value>
  </data>
  <data name="CompilerWarning_CS0253_Title" xml:space="preserve">
    <value>可能非有意的引用比较；右侧需要强制转换</value>
  </data>
  <data name="ArgumentToNameofOperatorIsMissingMessage" xml:space="preserve">
    <value>缺少 nameof 运算符的实参</value>
  </data>
  <data name="BadCompileConstantValueMessage" xml:space="preserve">
    <value>错误的编译常量值</value>
  </data>
  <data name="ThereExistBothImplicitConversionsFromAndAndFromToMessage" xml:space="preserve">
    <value>存在从 '{0}' 到 '{1}' 和从 '{1}' 到 '{0}' 的隐式转换</value>
  </data>
  <data name="ConvertToAutoPropertyMessage" xml:space="preserve">
    <value>转换为自动属性</value>
  </data>
  <data name="TheConstraintsForTypeArgumentsForAreNotSatisfiedMessage" xml:space="preserve">
    <value>{0} '{1}' 的类型实参的约束未满足</value>
  </data>
  <data name="UseWithExpressionToCreateAModifiedCopyOfAnAnonymousObject" xml:space="preserve">
    <value>使用 'with' 表达式创建匿名对象的修改后副本</value>
  </data>
  <data name="PrimaryConstructorParameterIsShadowedByMemberFromBase" xml:space="preserve">
    <value>主构造函数形参 '{0}' 被基中的成员隐藏</value>
  </data>
  <data name="MethodSpecifiesAdefaultConstraintForTypeParameterButCorrespondingTypeParameterOfOverriddenOrExplicitlyImplementedMethodIsConstrainedToAReferenceTypeOrAValueTypeMessage" xml:space="preserve">
    <value>方法 '{0}' 为类型形参 '{1}' 指定了 'default' 约束，但被重写或显式实现的方法 '{3}' 的相应类型形参 '{2}' 被约束为引用类型或值类型</value>
  </data>
  <data name="ArgumentMustBeAReadableVariableFieldOrAnArrayElementMessage" xml:space="preserve">
    <value>{0}'{1}' 实参必须为可读变量、字段或数组元素</value>
  </data>
  <data name="WinRTMethodCannotBeGenericMessage" xml:space="preserve">
    <value>WinRT 方法不能为泛型</value>
  </data>
  <data name="AbstractInheritedMember_IsNotImplemented_Text" xml:space="preserve">
    <value>abstract 继承成员 '{0}' 未实现</value>
  </data>
  <data name="CompilerWarning_CS1702_Title" xml:space="preserve">
    <value>假定程序集引用与标识匹配</value>
  </data>
  <data name="UseWithExpressionToCopyStructMessage" xml:space="preserve">
    <value>使用 '{0}' 表达式复制结构</value>
  </data>
  <data name="ObjectAndCollectionInitializerExpressionsCannotBeAppliedToADelegateCreationExpressionMessage" xml:space="preserve">
    <value>对象和集合初始值设定项表达式不能应用于委托创建表达式</value>
  </data>
  <data name="TheReturnTypeOfAnAsyncAnonymousFunctionMustBeMessage" xml:space="preserve">
    <value>'async' 匿名函数的返回值类型必须为 {0}</value>
  </data>
  <data name="EmptyFormatSpecifierMessage" xml:space="preserve">
    <value>空格式说明符</value>
  </data>
  <data name="PossiblyMistakenUseOfCancellationTokenDescription" xml:space="preserve">
    <value>使用了来自外部作用域的 'CancellationToken'</value>
  </data>
  <data name="EnumerableSumInvocationInExplicitUncheckedContext23" xml:space="preserve">
    <value>在显式 unchecked 上下文中调用 'Enumerable.Sum'</value>
  </data>
  <data name="LoopControlVariableIsNeverChangedInsideLoop" xml:space="preserve">
    <value>循环控制变量在循环内从未更改过</value>
  </data>
  <data name="InvalidValueForArgumentToAttributeMessage" xml:space="preserve">
    <value>“{0}”特性的参数值无效</value>
  </data>
  <data name="LoopCanBeConvertedIntoLINQExpressionButAnotherGetEnumeratorMethodWillBeUsedMessage" xml:space="preserve">
    <value>循环可以转换为 LINQ 表达式，但将使用另一个 'GetEnumerator' 方法</value>
  </data>
  <data name="GCSuppressFinalizeIsInvokedForTypeWithoutDestructor22" xml:space="preserve">
    <value>为不带析构函数的类型调用了 'GC.SuppressFinalize'</value>
  </data>
  <data name="EmptyStaticConstructorIsRedundantMessage" xml:space="preserve">
    <value>空 static 构造函数冗余</value>
  </data>
  <data name="CannotCreateAnArrayWithANegativeSizeMessage" xml:space="preserve">
    <value>无法创建大小为负值的数组</value>
  </data>
  <data name="UsageOfDefaultStructEqualityDescription" xml:space="preserve">
    <value>结构的 'Equals' 和 'GetHashCode' 方法的默认实现基于反射，性能不佳</value>
  </data>
  <data name="CompilerWarning_CS1589_Title" xml:space="preserve">
    <value>无法包括 XML 段落</value>
  </data>
  <data name="WinRTDoNotSupportsoutParametersOnConstructorsMessage" xml:space="preserve">
    <value>WinRT 不支持构造函数上的 'out' 形参</value>
  </data>
  <data name="unsafeStatementIsNotAllowedAtThisPointMessage" xml:space="preserve">
    <value>此时不允许使用 'unsafe' 语句</value>
  </data>
  <data name="CqrsNamingRecommendationMessage" xml:space="preserve">
    <value>'{0}' 不符合 CQRS 命名约定。建议的名称为 '{1}'。</value>
  </data>
  <data name="WithAnIteratorBlockMustBeasyncToReturnMessage" xml:space="preserve">
    <value>具有迭代器块的{0}必须为 'async' 才能返回 '{1}'</value>
  </data>
  <data name="ComparisonWithIsRedundantMessage" xml:space="preserve">
    <value>与 {0} 的比较冗余</value>
  </data>
  <data name="ReplaceExplicitFieldDeclarationWithAfieldKeywordUsageInCorrespondingPropertyDeclarationAnonymousField" xml:space="preserve">
    <value>在相应的属性声明(匿名字段)中将显式字段声明替换为 'field' 关键字用法</value>
  </data>
  <data name="EmptyfinallyBlockIsRedundant" xml:space="preserve">
    <value>空 'finally' 块冗余</value>
  </data>
  <data name="ReplaceOrderingAndTakingFirstOrLastWithMinByOrMaxByInvocation" xml:space="preserve">
    <value>将排序并获取 'First' 或 'Last' 替换为 'MinBy' 或 'MaxBy' 调用</value>
  </data>
  <data name="InterfaceIsAlreadyListedInTheInterfaceListOnAsMessage" xml:space="preserve">
    <value>接口 '{0}' 已在{1} '{2}' 上的接口列表中作为 '{3}&gt;' 列出</value>
  </data>
  <data name="RefReturnOnlyParameterMemberWarningMessage" xml:space="preserve">
    <value>这会经 ref 形参通过引用返回{0} '{1}' 的成员；但它只能在 return 语句中安全返回</value>
  </data>
  <data name="CompilerWarning_CS8032_Title" xml:space="preserve">
    <value>无法创建分析器实例</value>
  </data>
  <data name="RedundantMemberInitializer" xml:space="preserve">
    <value>冗余的成员初始值设定项</value>
  </data>
  <data name="ArrayCreationExpressionParameterTypeShouldBeintuintlongOrulongMessage" xml:space="preserve">
    <value>数组创建表达式形参类型应为 'int'、'uint'、'long' 或 'ulong'</value>
  </data>
  <data name="IncorrectNumberOfTypeParametersCandidatesAreMessage" xml:space="preserve">
    <value>类型形参的数量不正确。候选项为:{0}</value>
  </data>
  <data name="PropertyWithTheSameNameAndDefaultImplementationExistsInAnImplementedInterface" xml:space="preserve">
    <value>实现的接口中存在具有相同名称和默认实现的属性</value>
  </data>
  <data name="SuggestToReplaceBoolResultXIfYResultTrueToBoolResultXY" xml:space="preserve">
    <value>建议将
            bool result = x &gt; 0;
            if (y &gt; 0) result = true;
            替换为
            bool result = x &gt; 0 || y &gt; 0;</value>
  </data>
  <data name="CannotSpecifyBothdefaultAndTypeConstraintMessage" xml:space="preserve">
    <value>不能同时指定 'default' 和 '{0}' 类型约束</value>
  </data>
  <data name="UseLambdaExpressionMessage" xml:space="preserve">
    <value>使用 lambda 表达式</value>
  </data>
  <data name="SeparateControlTransferStatementWithBlankLine" xml:space="preserve">
    <value>使用空行分隔控制传输语句</value>
  </data>
  <data name="PossibleMultipleEnumeration" xml:space="preserve">
    <value>可能多次枚举</value>
  </data>
  <data name="PartialMemberParameterParamsModifiersMismatchMessage" xml:space="preserve">
    <value>两个分部成员声明都必须使用 params 形参，或者都不使用 params 形参</value>
  </data>
  <data name="InterceptorFilePathCannotBeNullMessage" xml:space="preserve">
    <value>拦截器不能具有 'null' 文件路径</value>
  </data>
  <data name="NullabilityOfReferenceTypesInDoesntMatchOverriddenMemberMessage" xml:space="preserve">
    <value>{0}中引用类型的为 null 性与被重写的成员 '{1}' 不匹配</value>
  </data>
  <data name="UseFileScopedOrBlockScopedNamespaceBody" xml:space="preserve">
    <value>使用文件作用域或块作用域命名空间主体</value>
  </data>
  <data name="ExceptionRethrowPossiblyIntended" xml:space="preserve">
    <value>可能打算重新抛出异常</value>
  </data>
  <data name="LiteralValueArgumentCodeStyleRule_Description" xml:space="preserve">
    <value>传递布尔、数字、'byte' 或 'char' 字面量值时，首选使用命名/位置实参</value>
  </data>
  <data name="ForceMergeSequentialOrChecksSettingTitle" xml:space="preserve">
    <value>尽可能合并顺序 '||' 检查(禁用启发式)</value>
  </data>
  <data name="RedundantVirtualModifier" xml:space="preserve">
    <value>冗余的 'virtual' 修饰符</value>
  </data>
  <data name="UsePreferredStyleOfDefaultValueExpressionWhenTypeIsNotEvident" xml:space="preserve">
    <value>当类型不明确时，使用首选的默认值表达式样式</value>
  </data>
  <data name="MultipleSequentialOrderByInvocationIsMeaninglessProbablyThenByIsImplied" xml:space="preserve">
    <value>多个顺序 'OrderBy' 调用毫无意义，您的意思可能是 'ThenBy'</value>
  </data>
  <data name="CompilerWarning_CS1692_Title" xml:space="preserve">
    <value>无效数字</value>
  </data>
  <data name="PartialMethodDeclarationsOfHaveInconsistentConstraintsForTypeParameterMessage" xml:space="preserve">
    <value>“{0}”的分部方法声明对类型参数“{1}”的约束不一致</value>
  </data>
  <data name="_RefType_Text" xml:space="preserve">
    <value>{0} '{1}' 类型</value>
  </data>
  <data name="CompilerWarning_CS1687_Title" xml:space="preserve">
    <value>源文件已超过在 PDB 中可表示的 16,707,565 行的限制；调试信息将不正确</value>
  </data>
  <data name="ExtractCommonBranchingCodeBeforeMessage" xml:space="preserve">
    <value>提取 '{0}' 语句前的通用代码</value>
  </data>
  <data name="IteratorNeverReturns" xml:space="preserve">
    <value>迭代器从未返回</value>
  </data>
  <data name="DisposeOnUsingVariableDescription" xml:space="preserve">
    <value>不处置 'using' 语句捕获的变量，因为其处置状态在其他地方可能不明显</value>
  </data>
  <data name="EmptyForLoopIsRedundantMessage" xml:space="preserve">
    <value>空 '{0}' 循环冗余</value>
  </data>
  <data name="ChangeCqrsSettings" xml:space="preserve">
    <value>更改 CQRS 设置</value>
  </data>
  <data name="AssignmentExpressionInsideMemberInitializerLooksSuspiciousCommaIsProbablyMissingMessage" xml:space="preserve">
    <value>成员初始值设定项中的赋值表达式看上去可疑。可能缺少逗号。</value>
  </data>
  <data name="TheGivenExpressionCannotBeUsedInAfixedStatementMessage" xml:space="preserve">
    <value>表达式不能在 'fixed' 语句中使用</value>
  </data>
  <data name="PossibleUnintendedReferenceComparison28" xml:space="preserve">
    <value>可能非有意的引用比较</value>
  </data>
  <data name="AnonymousFunctionValueArgumentCodeStyleRule_Description" xml:space="preserve">
    <value>传递匿名函数(lambda 或委托)时，首选使用命名/位置实参</value>
  </data>
  <data name="RedundantArgumentPassedToCallerArgumentExpressionParameter" xml:space="preserve">
    <value>冗余实参被传递给调用方实参表达式形参</value>
  </data>
  <data name="UsingStatementResourceInitializationExpressionTitle" xml:space="preserve">
    <value>初始化 'using' 变量时，对象初始值设定项表达式可能会抛出异常</value>
  </data>
  <data name="CompilerWarning_CS0414_Title" xml:space="preserve">
    <value>字段已被赋值，但它的值从未被使用</value>
  </data>
  <data name="RawStringCanBeSimplifiedMessage" xml:space="preserve">
    <value>原始字符串可以简化</value>
  </data>
  <data name="CannotCreateAnInstanceOfTheInterfaceMessage" xml:space="preserve">
    <value>不能创建接口 '{0}' 的实例</value>
  </data>
  <data name="InterpolatedStringInsertIsUsedHaveYouIntendedToUseAFormatStringPlaceholderMessage" xml:space="preserve">
    <value>使用了内插字符串。您是想使用格式字符串占位符吗?</value>
  </data>
  <data name="RawStringCanBeSimplified_Description" xml:space="preserve">
    <value>字符串表示有多余的引号或美元符号</value>
  </data>
  <data name="BothContextDeclaredTitle" xml:space="preserve">
    <value>方法在两种 CQRS 上下文中声明</value>
  </data>
  <data name="CompilerWarning_CS9181_Title" xml:space="preserve">
    <value>内联数组索引器不会用于元素访问表达式。</value>
  </data>
  <data name="RequiredBaseType_ConflictingType_From_Text" xml:space="preserve">
    <value>必需基类型 '{0}' 与特性 '{2}' 中的类型 '{1}' 冲突</value>
  </data>
  <data name="ReplaceVariableForAsExpressionTypeCheckAndTheFollowingCheckForItBeingNotNullWithCPatternMatchingExpression" xml:space="preserve">
    <value>将 'as' 表达式类型检查以及对它是否不为 null 的后续检查的变量替换为 C# 7.0 模式匹配表达式</value>
  </data>
  <data name="TypesAlias_RiderPresentableName" xml:space="preserve">
    <value>类型//类</value>
  </data>
  <data name="UseBracesToSeparateDoWhileStatement_Text" xml:space="preserve">
    <value>使用大括号分隔 'do-while' 语句体</value>
  </data>
  <data name="ADeclarationIsNotAllowedInThisContextMessage" xml:space="preserve">
    <value>此上下文中不允许使用声明</value>
  </data>
  <data name="CannotUseAsTypeParameterConstraintMessage" xml:space="preserve">
    <value>不能将 '{0}' 用作类型形参约束</value>
  </data>
  <data name="BuiltInTypeReferenceIsInconsistentWithSelectedCodeStyleMessage" xml:space="preserve">
    <value>内置类型引用与代码样式设置不一致</value>
  </data>
  <data name="RemoveUnnecessaryWhitespaceAtTheEndOfLine" xml:space="preserve">
    <value>移除行尾不必要的空格</value>
  </data>
  <data name="TheKeywordAbstractIsRedundantMessage" xml:space="preserve">
    <value>关键字 '{0}' 冗余</value>
  </data>
  <data name="LineDirectiveSpaceRequiredErrorMessage" xml:space="preserve">
    <value>指令值必须用空格分隔</value>
  </data>
  <data name="ReplaceWithFieldKeywordMessage" xml:space="preserve">
    <value>替换为 '{0}' 关键字</value>
  </data>
  <data name="foreachStatementCannotOperateOnEnumeratorsOfTypeInasyncOrIteratorMethodsBecauseIsArefStructMessage" xml:space="preserve">
    <value>'foreach' 语句不能在 'async' 或迭代器方法中 '{0}' 类型的枚举器上执行，因为 '{0}' 是 'ref' 结构</value>
  </data>
  <data name="SealedMemberInSealedClass" xml:space="preserve">
    <value>sealed 类中存在 sealed 成员</value>
  </data>
  <data name="TypeTestPatternRequiresVariableDesignationOrDiscardAfterMessage" xml:space="preserve">
    <value>类型测试模式要求后面紧跟变量指定或弃元</value>
  </data>
  <data name="TheGivenExpressionOfisOperatorIsAlwaysOfTheProvidedType" xml:space="preserve">
    <value>'is' 运算符的给定表达式始终为提供的类型</value>
  </data>
  <data name="ExternCannotDeclareABodyMessage" xml:space="preserve">
    <value>extern {0}不能声明主体</value>
  </data>
  <data name="RedundantExplicitCollectionCreationInArgumentOfParamsParameter" xml:space="preserve">
    <value>'params' 形参的实参中存在冗余的显式集合创建</value>
  </data>
  <data name="TypeParameterVarianceDiffersFromDeclaredInOtherPartsMessage" xml:space="preserve">
    <value>类型形参差异与其他部分中声明的不同</value>
  </data>
  <data name="AddParenthesesToAvoidNonObviousPrecedence_Caption" xml:space="preserve">
    <value>添加圆括号以避免不明显的优先级</value>
  </data>
  <data name="WinRTEnumerationTypeShouldBeBackedByValuesOfTypeIntOrUintMessage" xml:space="preserve">
    <value>WinRT 枚举类型应当受 int 或 uint 类型的值支持</value>
  </data>
  <data name="CompilerWarning_CS7095_Title" xml:space="preserve">
    <value>筛选器表达式是常量 “true”</value>
  </data>
  <data name="AnExpressionTreeMayNotContainANamedArgumentSpecificationMessage" xml:space="preserve">
    <value>表达式树不能包含命名实参规范</value>
  </data>
  <data name="IndexersMustHaveAtLeastOneParameterMessage" xml:space="preserve">
    <value>索引器必须至少有一个参数</value>
  </data>
  <data name="PreferUsingNamedPositionalArgumentForAllExpressionsExceptLiteralNamedAndAnonymousFunction" xml:space="preserve">
    <value>对除字面量、命名和匿名函数外的所有表达式首选使用命名/位置实参</value>
  </data>
  <data name="UnsafeInRegularUsingDirectiveMessage" xml:space="preserve">
    <value>只有 “using static” 或 “using alias” 才能为 “unsafe”</value>
  </data>
  <data name="TheTypeCannotBeDeclaredConstMessage" xml:space="preserve">
    <value>不能将类型“{0}”声明为 const</value>
  </data>
  <data name="PossibleLossOfFraction" xml:space="preserve">
    <value>分数可能丢失</value>
  </data>
  <data name="UsePreferredStyleForTrailingCommaWhenTheLastElementIsNotFollowedByANewLine" xml:space="preserve">
    <value>当最后一个元素后面没有新行时，对尾随逗号使用首选样式</value>
  </data>
  <data name="SpecifyingSignatureIsNotNecessaryBecauseNoneOfItsParametersAreUsedInTheBodyMessage" xml:space="preserve">
    <value>不需要指定签名，因为它的所有形参均未在主体中使用</value>
  </data>
  <data name="PossibleSystemArgumentOutOfRangeExceptionStartIndexShouldBeLessThanOrEqualToEndIndex" xml:space="preserve">
    <value>可能出现 'System.ArgumentOutOfRangeException'。开始索引应小于或等于结束索引。</value>
  </data>
  <data name="YouMustProvideAnInitializerInAusingDeclarationMessage" xml:space="preserve">
    <value>必须在 'using' 声明中提供初始值设定项</value>
  </data>
  <data name="InterceptorPathNotInCompilationMessage" xml:space="preserve">
    <value>无法拦截: 编译不包含路径为 '{0}' 的文件</value>
  </data>
  <data name="MoveLocalFunctionAfterJumpStatement_Description" xml:space="preserve">
    <value>将局部函数移动到其包含作用域的末尾，并使用显式 'return'、'continue' 或 'yield break' 将其与可执行代码分开。这可以提高代码的可读性，因为可执行代码将与不在其声明点执行的帮助函数清楚地区分开。</value>
  </data>
  <data name="CompilerWarning_CS0728_Title" xml:space="preserve">
    <value>对局部变量的赋值可能不正确，该变量是 using 或 lock 语句的参数</value>
  </data>
  <data name="RedundantUsingDirective" xml:space="preserve">
    <value>冗余的 using 指令</value>
  </data>
  <data name="ConvertChainOfConditionalExpressionsToSwitchExpressionMessage" xml:space="preserve">
    <value>将条件 ?: 表达式链转换为 '{0}' 表达式</value>
  </data>
  <data name="AllUnderscoreLocalParameterNameMessage" xml:space="preserve">
    <value>'{0}' 名称通常为无用法的形参所保留</value>
  </data>
  <data name="LeftOperandIsNeverNullAccordingToNullableReferenceTypesAnnotationsMessage" xml:space="preserve">
    <value>根据可以为 null 的引用类型的注解，'??' 左操作数永远不为 null</value>
  </data>
  <data name="AdjustModifiersDeclarationOrder" xml:space="preserve">
    <value>调整修饰符声明顺序</value>
  </data>
  <data name="JoinOrSeparateAttributesIsSection_Caption" xml:space="preserve">
    <value>在部分中联接或分隔特性</value>
  </data>
  <data name="DuplicateKeyCollectionInitializationTitle" xml:space="preserve">
    <value>在初始化字典/集合时发现重复键</value>
  </data>
  <data name="ReturnValueMustBeNonNullBecauseParameterIsNonNullMessage" xml:space="preserve">
    <value>返回值必须为非 null，因为参数“{0}”为非 null</value>
  </data>
  <data name="SimplifyLINQExpressionUseAll" xml:space="preserve">
    <value>简化 LINQ 表达式(使用 'All')</value>
  </data>
  <data name="SimplifyLINQExpressionUseAny" xml:space="preserve">
    <value>简化 LINQ 表达式(使用 'Any')</value>
  </data>
  <data name="CannotUseSealedClassAsTypeParameterConstraintMessage" xml:space="preserve">
    <value>不能将 sealed 类 '{0}' 用作类型形参约束</value>
  </data>
  <data name="CanSimplifySetAddingWithSingleCallDescription" xml:space="preserve">
    <value>在集合上的 'Add' 之前调用 'Contains' 是冗余的，可以使用单个 'Add' 调用进行简化</value>
  </data>
  <data name="withExpressionIsUsedInsteadOfObjectInitializer" xml:space="preserve">
    <value>使用了 'with' 表达式而不是对象初始值设定项</value>
  </data>
  <data name="RedundantSetsRequiredMembersAttributeTitle" xml:space="preserve">
    <value>冗余特性 [SetsRequiredMembers]</value>
  </data>
  <data name="InDynamicMethodArgMessage" xml:space="preserve">
    <value>带有 "in" 修饰符的参数不能用于动态调度的表达式</value>
  </data>
  <data name="CodeCleanupTask_ArrangeAttributes" xml:space="preserve">
    <value>添加/移除多个特性的中括号</value>
  </data>
  <data name="CompilerWarning_CS0659_Title" xml:space="preserve">
    <value>类型重写 Object.Equals(object o)，但不重写 Object.GetHashCode()</value>
  </data>
  <data name="CannotawaitInTheFilterExpressionOfAcatchClauseMessage" xml:space="preserve">
    <value>不能在 'catch' 子句的筛选器表达式中 'await'</value>
  </data>
  <data name="CannotUsefieldKeywordInsidenameofExpressionsMessage" xml:space="preserve">
    <value>不能在 'nameof' 表达式内使用 'field' 关键字</value>
  </data>
  <data name="CompilerWarning_CS9074_Title" xml:space="preserve">
    <value>参数的 “scoped” 修饰符与被替代或被实现的成员不匹配。</value>
  </data>
  <data name="LambdaExpression_Text" xml:space="preserve">
    <value>lambda 表达式</value>
  </data>
  <data name="ExtensionReceiverParameterMustBeAValueTypeMessage" xml:space="preserve">
    <value>扩展的 '{0}' 接收器形参必须为值类型</value>
  </data>
  <data name="UseArgumentNullExceptionThrowIfNull" xml:space="preserve">
    <value>使用 'ArgumentNullException.ThrowIfNull'</value>
  </data>
  <data name="FieldLikeEventsAreNotAllowedInreadonlyStructsMessage" xml:space="preserve">
    <value>'readonly' 结构中不允许使用类似字段的事件</value>
  </data>
  <data name="APossibleNullValueMayNotBeUsedForATypeMarkedWithNotNullOrDisallowNullMessage" xml:space="preserve">
    <value>可能的 null 值不能用于标记为 [NotNull] 或 [DisallowNull] 的类型</value>
  </data>
  <data name="CannotUsePrimaryConversionFrom_To_InThisContextMessage" xml:space="preserve">
    <value>不能在此上下文中使用从 '{0}' 到 '{1}' 的转换</value>
  </data>
  <data name="CapturedPrimaryConstructorParameterInFieldInitializerMessage" xml:space="preserve">
    <value>形参 '{0}' 被捕获到封闭类型状态，它的值也用于初始化字段、属性或事件</value>
  </data>
  <data name="CompilerWarning_CS1695_Title" xml:space="preserve">
    <value>#pragma checksum 语法无效</value>
  </data>
  <data name="TypeRequiredBySomeAttributeMarkedWithBaseTypeRequiredConflictingTypeFromAnotherAttribute" xml:space="preserve">
    <value>某些特性(标有 BaseTypeRequired)所需的类型与另一个特性的类型冲突</value>
  </data>
  <data name="SimplifyNegatedRelationalPattern" xml:space="preserve">
    <value>简化求反关系模式</value>
  </data>
  <data name="ReplaceBuiltInTypeReferenceWithACLRTypeNameOrAKeyword" xml:space="preserve">
    <value>将内置类型引用替换为 CLR 类型名称或关键字</value>
  </data>
  <data name="PreferTrailingCommasBeforeNewLineIn_Caption" xml:space="preserve">
    <value>在多行列表中的新行前首选尾随逗号</value>
  </data>
  <data name="CompilerWarning_CS4026_Title" xml:space="preserve">
    <value>CallerMemberNameAttribute 将不起任何作用，因为它适用于不允许可选参数的上下文中使用的成员</value>
  </data>
  <data name="CapturedVariableIsDisposedInTheOuterScopeMessage" xml:space="preserve">
    <value>捕获的变量已在外部作用域内释放</value>
  </data>
  <data name="MethodHasAsInvalidReturnValueNameMessage" xml:space="preserve">
    <value>方法具有无效的返回值名称</value>
  </data>
  <data name="WhenCreatedTypeIsEvident_Caption" xml:space="preserve">
    <value>当创建的类型明显时</value>
  </data>
  <data name="OperatorWithoutMatchedCheckedOperatorTitle" xml:space="preserve">
    <value>没有匹配 checked 运算符的运算符</value>
  </data>
  <data name="TypeCastCanBeSafelyRemoved" xml:space="preserve">
    <value>可以安全地移除类型转换</value>
  </data>
  <data name="RequiredMemberMustBeSetInInterpolatedStringMessage" xml:space="preserve">
    <value>必需成员 '{0}' 必须设置</value>
  </data>
  <data name="InconsistentSynchronizationOnField" xml:space="preserve">
    <value>字段上的同步不一致</value>
  </data>
  <data name="CannotDeclareVirtualInMessage" xml:space="preserve">
    <value>不能在{2} '{3}' 中声明 virtual {0} '{1}'</value>
  </data>
  <data name="CompilerWarning_CS0028_Title" xml:space="preserve">
    <value>方法的签名错误，不能作为入口点</value>
  </data>
  <data name="LambdaExpressionParameterCannotBeparamsMessage" xml:space="preserve">
    <value>lambda 表达式形参不能为 'params'</value>
  </data>
  <data name="CompilerWarning_CS1591_Title" xml:space="preserve">
    <value>缺少对公共可见类型或成员的 XML 注释</value>
  </data>
  <data name="CallingConventionIsNotCompatibleWithMessage" xml:space="preserve">
    <value>调用惯例 '{0}' 与 '{1}' 不兼容</value>
  </data>
  <data name="RefAssignNarrowerWarningMessage" xml:space="preserve">
    <value>这会将 '{1}' 引用赋给 '{0}'，但 '{1}' 的转义作用域比 '{0}' 窄</value>
  </data>
  <data name="RewriteNullableTypeInShortForm" xml:space="preserve">
    <value>以简短形式重写可以为 null 的类型</value>
  </data>
  <data name="TheHasNoGetterMessage" xml:space="preserve">
    <value>{0} '{1}' 没有 getter</value>
  </data>
  <data name="CompilerWarning_CS0464_Title" xml:space="preserve">
    <value>与结构类型的 null 进行比较始终产生 "false"</value>
  </data>
  <data name="UseRangeIndexerMessage" xml:space="preserve">
    <value>使用范围索引器</value>
  </data>
  <data name="PropertiesAndVariablesStaticField_RiderPresentableName" xml:space="preserve">
    <value>属性和变量//static 字段</value>
  </data>
  <data name="WithRefReturn_Text" xml:space="preserve">
    <value>(带有 '{0}' 返回值)</value>
  </data>
  <data name="ReplaceNullCoalescingExpressionWithCompoundAssignment" xml:space="preserve">
    <value>将 null 合并表达式替换为复合赋值</value>
  </data>
  <data name="UseAwaitUsingMessage" xml:space="preserve">
    <value>使用 "{0}"</value>
  </data>
  <data name="NotDisposedResourceIsReturnedMessage" xml:space="preserve">
    <value>返回值应被处置，但 {0} 未使用 [{1}] 注解</value>
  </data>
  <data name="UseBracesToSeparateLockStatementBody_Text" xml:space="preserve">
    <value>使用大括号分隔 'lock' 语句体</value>
  </data>
  <data name="TheTypeNameOnlyContainsLowerCasedASCIICharactersSuchNamesMayBecomeReservedForTheLanguageMessage" xml:space="preserve">
    <value>类型名称 '{0}' 仅包含小写的 ASCII 字符。此类名称可能会保留给该语言</value>
  </data>
  <data name="CompilerWarning_CS3007_Title" xml:space="preserve">
    <value>仅未命名数组类型不同的重载方法不符合 CLS</value>
  </data>
  <data name="NullabilityAttributeUsageWithDeclarationOfVoidOrValueTypeDoesntAffectCodeAnalysis" xml:space="preserve">
    <value>具有 void 或值类型声明的为 null 性特性用法不影响代码分析</value>
  </data>
  <data name="NamedArgumentIsSpecifiedMultipleTimesMessage" xml:space="preserve">
    <value>多次指定了命名实参 '{0}'</value>
  </data>
  <data name="InterfacesMarkedAsServiceContractShouldDeclareAtLeastOneOperationContract" xml:space="preserve">
    <value>被标记为 ServiceContract 的接口应至少声明一个 OperationContract</value>
  </data>
  <data name="AttributeArgumentsMustPrecedePropertyAssignmentMessage" xml:space="preserve">
    <value>特性实参必须在属性赋值之前</value>
  </data>
  <data name="CollectionExpressionMissingAddMethodWithCandidate_Text" xml:space="preserve">
    <value>集合表达式目标类型 '{0}' 必须具有可以使用单个实参调用的适用实例或扩展方法 'Add'。找到的最佳候选: '{1}'</value>
  </data>
  <data name="TheAttributeEnumeratorCancellationCannotBeUsedOnMultipleParametersMessage" xml:space="preserve">
    <value>特性 '[EnumeratorCancellation]' 不能在多个形参上使用</value>
  </data>
  <data name="TheFirstParameterOfAnExtensionMethodCannotBeOfTypedynamicMessage" xml:space="preserve">
    <value>扩展方法的第一个形参不能为 'dynamic' 类型</value>
  </data>
  <data name="ExtractCommonPropertyPatternMessage" xml:space="preserve">
    <value>提取公用属性模式 '{0}'</value>
  </data>
  <data name="TypeParameterCouldBeDeclaredAsCovariantOrContravariant" xml:space="preserve">
    <value>类型形参可被声明为协变或逆变</value>
  </data>
  <data name="AccessorInExternCannotDeclareABodyMessage" xml:space="preserve">
    <value>extern {0} 中的访问器不能声明主体</value>
  </data>
  <data name="CanReplaceCastWithShorterTypeArgumentTitle" xml:space="preserve">
    <value>转换表达式可被替换为简化的类型实参</value>
  </data>
  <data name="NPlusOneUsageDescription" xml:space="preserve">
    <value>高亮显示可能会导致对数据库进行多次不必要的 SQL 查询(N+1 问题)的导航属性的用法</value>
  </data>
  <data name="CompilerWarning_CS1633_Title" xml:space="preserve">
    <value>无法识别的 #pragma 指令</value>
  </data>
  <data name="FileLocalTypeInConstraintMessage" xml:space="preserve">
    <value>file-local 类型 '{0}' 不能用作非 file-local {1} '{2}' 中的类型约束</value>
  </data>
  <data name="InconsistentOrderOfTakenLocks" xml:space="preserve">
    <value>获取的锁的顺序不一致</value>
  </data>
  <data name="BadlyFormedXMLInIncludedCommentsFileMessage" xml:space="preserve">
    <value>所包含的注释文件中有格式错误的 XML</value>
  </data>
  <data name="OptionalParametersMustAppearAfterAllRequiredParametersMessage" xml:space="preserve">
    <value>可选参数必须出现在所有必需参数之后</value>
  </data>
  <data name="ConvertToLocalFunctionWithPreferredBodyStyle" xml:space="preserve">
    <value>转换为具有首选主体样式的构局部函数</value>
  </data>
  <data name="TurnOffUnnamedTupleComponentTypeInlayHint_Text" xml:space="preserve">
    <value>隐藏未命名元组组件的类型提示</value>
  </data>
  <data name="ExtractCommonBranchingCodeDescription" xml:space="preserve">
    <value>从 'if' 或 'switch' 等分支语句中提取通用代码以简化和整合代码，确保无论采用哪种分支路径，都会执行共享逻辑</value>
  </data>
  <data name="RedundantCollectionCopyCallDescription" xml:space="preserve">
    <value>在已经属于目标类型的集合上调用 'ToArray'、'ToList'、'ToDictionary' 或 'ToHashSet' 冗余</value>
  </data>
  <data name="UseVerbatimStringMessage" xml:space="preserve">
    <value>使用逐字字符串</value>
  </data>
  <data name="ReplaceWithSingleCallToLast_Text" xml:space="preserve">
    <value>替换为对 Last(..) 的单个调用</value>
  </data>
  <data name="OptionalParameterDefaultValueDiffersFromParameterInBaseMessage" xml:space="preserve">
    <value>可选形参默认值与基{1} '{2}' 中的形参{0}不同</value>
  </data>
  <data name="DeclaringNewProtectedInSealedIsTheSameAsDeclaringItAsPrivateMessage" xml:space="preserve">
    <value>在 sealed {2}中声明新的 protected {0} '{1}' 与将其声明为 private 相同</value>
  </data>
  <data name="RedundantConditionalTernaryExpressionUsageMessage" xml:space="preserve">
    <value>冗余的条件三元表达式用法</value>
  </data>
  <data name="TypeArgumentIsMissingMessage" xml:space="preserve">
    <value>缺少类型实参</value>
  </data>
  <data name="CannotImplicitlyConvertType_To__Text" xml:space="preserve">
    <value>不能将类型 '{0}' 隐式转换为 '{1}'</value>
  </data>
  <data name="UseUtf8StringLiteralForGetBytesMessage" xml:space="preserve">
    <value>'Encoding.GetBytes' 调用可被替换为 UTF-8 字符串字面量</value>
  </data>
  <data name="CannotawaitInThecatchOrfinallyClauseOfAtryStatementMessage" xml:space="preserve">
    <value>不能在 'try' 语句的 'catch' 或 'finally' 子句中 'await'</value>
  </data>
  <data name="CompilerWarning_CS8029_Title" xml:space="preserve">
    <value>本地名称对于 PDB 太长</value>
  </data>
  <data name="JoinNullCheckWithAssignmentWhenPossible" xml:space="preserve">
    <value>将 null 检查与赋值联接在一起(如果可能)</value>
  </data>
  <data name="UsingSymbolRequiresOptingIntoPreviewFeatures_Text" xml:space="preserve">
    <value>{0}。使用 {1} 需要选择预览功能。</value>
  </data>
  <data name="AsyncVoidThrowExceptionMessage" xml:space="preserve">
    <value>'async void' {0}未处理的任何异常都可能导致进程崩溃</value>
  </data>
  <data name="RedundantpartialModifierOnTypeDeclaration" xml:space="preserve">
    <value>类型声明中存在冗余的 'partial' 修饰符</value>
  </data>
  <data name="InlineArraySliceNotUsedMessage" xml:space="preserve">
    <value>内联数组 'Slice' 方法不会用于元素访问表达式</value>
  </data>
  <data name="NonNullableOrRequiredTypeMemberIsNotInitializedInAnyExecutionPathOfTheConstructor" xml:space="preserve">
    <value>不可以为 null 或必需类型成员未在构造函数的任何执行路径中初始化</value>
  </data>
  <data name="AnExpressionOfTypeCanNeverMatchTheProvidedPatternMessage" xml:space="preserve">
    <value>'{0}' 类型的表达式永远不能与提供的模式匹配</value>
  </data>
  <data name="NonExistingArgumentInMessageTemplateMessage" xml:space="preserve">
    <value>消息模板中有不存在的实参</value>
  </data>
  <data name="ConstantExpected_Message" xml:space="preserve">
    <value>为了获得最佳性能，实参值应保持恒定</value>
  </data>
  <data name="InstanceFields_Text" xml:space="preserve">
    <value>实例字段</value>
  </data>
  <data name="SimplifyIsInstanceOfTypeMessage" xml:space="preserve">
    <value>简化 '{0}()' 调用</value>
  </data>
  <data name="InvalidInlineArrayFieldsMessage" xml:space="preserve">
    <value>内联数组结构必须声明一个且仅有一个实例字段</value>
  </data>
  <data name="RedundantSemicolonAfterTypeOrNamespaceDeclaration" xml:space="preserve">
    <value>类型或命名空间声明之后存在冗余的分号</value>
  </data>
  <data name="ComparisonWithCanBeSimplifiedMessage" xml:space="preserve">
    <value>与 {0} 的比较可以简化</value>
  </data>
  <data name="DuplicateValueTypeConstraintMessage" xml:space="preserve">
    <value>重复的值类型约束</value>
  </data>
  <data name="MethodMustHaveAReturnTypeMessage" xml:space="preserve">
    <value>方法必须具有返回类型</value>
  </data>
  <data name="CompilerWarning_CS8981_Title" xml:space="preserve">
    <value>该类型名称仅包含小写 ascii 字符。此类名称可能会成为该语言的保留值。</value>
  </data>
  <data name="DuplicateParameterMessage" xml:space="preserve">
    <value>重复的形参 '{0}'</value>
  </data>
  <data name="CSharpFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_comma_in_lists" xml:space="preserve">
    <value>列表中的逗号周围</value>
  </data>
  <data name="CompilerWarning_CS9018_Title" xml:space="preserve">
    <value>在显式分配之前，将读取自动实现的属性，从而导致前面的隐式分配为 'default'。</value>
  </data>
  <data name="TypesAndAliasesShouldNotBeNamedrecordMessage" xml:space="preserve">
    <value>类型和别名不应被命名为 'record'</value>
  </data>
  <data name="TheEventCanOnlyAppearOnTheLeftHandSideOfOrExceptWhenUsedFromWithinTheMessage" xml:space="preserve">
    <value>事件 '{0}' 只能出现在 += 或 -= 的左侧(除非从{1} '{2}' 内部使用时)</value>
  </data>
  <data name="RedundantAttributeUsageAttributePropertyAssignment" xml:space="preserve">
    <value>冗余的 [AttributeUsage] 特性属性赋值</value>
  </data>
  <data name="BothPartialMemberDeclarationsMustHaveIdenticalCombinationsOfvirtualoverridesealedAndnewModifiersMessage" xml:space="preserve">
    <value>两个分部成员声明必须具有 'virtual'、'override'、'sealed' 和 'new' 修饰符的相同组合</value>
  </data>
  <data name="CompilerWarning_CS9042_Title" xml:space="preserve">
    <value>不应要求使用 'ObsoleteAttribute' 特性化的成员，除非包含类型已过时或所有构造函数已过时。</value>
  </data>
  <data name="MemberHidesStaticMemberFromOuterClass9" xml:space="preserve">
    <value>成员会隐藏外部类中的 static 成员</value>
  </data>
  <data name="MergeTwoOperandsOfTheAndPatternIntoSinglePattern" xml:space="preserve">
    <value>将 'and' 模式的两个操作数合并到单个模式中</value>
  </data>
  <data name="__CannotImplement_FromInterface_Type_Text" xml:space="preserve">
    <value>{0} '{1}' 不能从接口 '{3}' 实现{2}。类型应为 '{4}'。</value>
  </data>
  <data name="ArglistIsNotAllowedInTheParameterListOfAsyncMessage" xml:space="preserve">
    <value>async {0}的形参列表中不允许使用 __arglist</value>
  </data>
  <data name="HeuristicallyUnreachableCodeDetected" xml:space="preserve">
    <value>检测到启发式不可到达的代码</value>
  </data>
  <data name="RedundantNullnessAttributeWithNullableReferenceTypesSettingKeepRedundantJetBrainsAnnotationsOnPublicAPIDescription" xml:space="preserve">
    <value>如果除了可以为 null 引用类型的语法之外，您还想在公共 API 上保留 [NotNull] 和 [CanBeNull] 属性，请选中此选项。如果您希望程序集的使用者在反编译源和代码补全中显式看到它们，这可能很有用。</value>
  </data>
  <data name="RedundantNullableDirectiveTitle" xml:space="preserve">
    <value>冗余的可以为 null 的指令</value>
  </data>
  <data name="TheawaitExpressionMayOnlyBeUsedInAQueryExpressionWithinTheFirstCollectionExpressionOfTheInitialfromClauseOrWithinTheCollectionExpressionOfAjoinClauseMessage" xml:space="preserve">
    <value>'await' 表达式只能用于初始 'from' 子句的第一个集合表达式或 'join' 子句的集合表达式中的查询表达式</value>
  </data>
  <data name="SimplifyNegativeEqualityExpressionMessage" xml:space="preserve">
    <value>简化负的相等表达式</value>
  </data>
  <data name="RuntimeDoesNotSupportRefFieldsMessage" xml:space="preserve">
    <value>目标运行时不支持 ref 字段</value>
  </data>
  <data name="YouCanOnlyTakeTheAddressOfAnUnfixedExpressionInsideOfAFixedStatementInitializerMessage" xml:space="preserve">
    <value>只能获取 fixed 语句初始值设定项内的未固定表达式的地址</value>
  </data>
  <data name="ShiftExpressionWithZeroLeftOperandEqualsZero" xml:space="preserve">
    <value>左操作数为零的移位表达式等于零</value>
  </data>
  <data name="AllowsRefStructConstraintMustBeLastMessage" xml:space="preserve">
    <value>'allows ref struct' 约束必须是指定的最后一个约束</value>
  </data>
  <data name="CompilerWarning_CS3015_Title" xml:space="preserve">
    <value>类型没有只使用符合 CLS 类型的可访问的构造函数</value>
  </data>
  <data name="PrimaryConstructorParameterCaptureDisallowedTitle" xml:space="preserve">
    <value>不允许捕获主构造函数形参</value>
  </data>
  <data name="DoubleNegationIsMeaninglesspreboolBConditionPre" xml:space="preserve">
    <value>双重求反毫无意义 &lt;pre&gt;bool b = !!condition;&lt;/pre&gt;</value>
  </data>
  <data name="PartialPropertyAccessor_MustHaveAnImplementationPartMessage" xml:space="preserve">
    <value>分部{0}访问器 '{1}' 已声明，但没有实现部分</value>
  </data>
  <data name="AParamsParameterMustBeTheLastParameterInAFormalParameterListMessage" xml:space="preserve">
    <value>params 参数必须是形参表中的最后一个参数</value>
  </data>
  <data name="BuiltInTypeReferenceForMemberAccessCodeStyleRule_DescriptionText" xml:space="preserve">
    <value>CLR 类型名称和对应的 C# 关键字可互换，不影响代码语义</value>
  </data>
  <data name="UseIndexFromEndExpressionMessage" xml:space="preserve">
    <value>使用从结尾索引表达式</value>
  </data>
  <data name="CompilerWarning_CS9084_Title" xml:space="preserve">
    <value>结构成员通过引用返回 'this' 或其他实例成员</value>
  </data>
  <data name="CompilerWarning_CS9266_Title" xml:space="preserve">
    <value>属性 '{1}' 的 '{0}' 访问器应使用 'field'，因为另一个访问器正在使用它。</value>
  </data>
  <data name="WhenTypeIsSimple" xml:space="preserve">
    <value>当类型为简单类型时</value>
  </data>
  <data name="AssignmentResultsAreFullyDiscardedMessage" xml:space="preserve">
    <value>赋值结果被完全舍弃</value>
  </data>
  <data name="CompilerWarning_CS8963_Title" xml:space="preserve">
    <value>CallerArgumentExpressionAttribute 采用了无效的参数名。</value>
  </data>
  <data name="ParameterMustHaveWhenExitingWithMessage" xml:space="preserve">
    <value>以 '{1}' 退出时形参 {0} 必须具有非 null 值</value>
  </data>
  <data name="UseTypeAnnotationSyntax" xml:space="preserve">
    <value>使用类型注解语法</value>
  </data>
  <data name="Operator_With_Operand_Text" xml:space="preserve">
    <value>带有 '{1}' 操作数的运算符 {0}</value>
  </data>
  <data name="CSharpFormatterHighlightingProvider_InternalConfigurableSeverityItems_Blank_lines_are_missing_elsewhere" xml:space="preserve">
    <value>其他位置缺少空行</value>
  </data>
  <data name="InconsistentArgumentsPassedToMathClampMethod" xml:space="preserve">
    <value>传递给 'Math.Clamp()' 方法的实参不一致</value>
  </data>
  <data name="InterfaceImplementationIsMissingAccessorImplementationMessage" xml:space="preserve">
    <value>接口实现 '{0}' 缺少访问器 '{1}' 实现</value>
  </data>
  <data name="RedundantDictionaryContainsKeyBeforeAddingDescription" xml:space="preserve">
    <value>在将条目添加到字典之前，'ContainsKey' 调用冗余。</value>
  </data>
  <data name="QueryExpression_Text" xml:space="preserve">
    <value>查询表达式</value>
  </data>
  <data name="CastExpressionCanBeReplacedWithTypeSafeAlternative" xml:space="preserve">
    <value>转换表达式可被替换为静态类型语言构造</value>
  </data>
  <data name="ObsoleteMembersShouldNotBeRequiredMessage" xml:space="preserve">
    <value>所需成员 '{0}' 不应被添加 'ObsoleteAttribute' 特性，除非包含类型已过时或所有构造函数已过时</value>
  </data>
  <data name="FieldKeywordIsAmbiguousMessage" xml:space="preserve">
    <value>在语言版本预览中，'{0}' 关键字绑定到属性的合成支持字段。为了避免生成合成支持字段和引用现有成员，请改用 '{1}.{2}' 或 '{3}'。</value>
  </data>
  <data name="TheModifierIsNotValidForMessage" xml:space="preserve">
    <value>修饰符 '{0}' 对{1} '{2}' 无效</value>
  </data>
  <data name="UserDefinedOperatorsCannotReturnVoidMessage" xml:space="preserve">
    <value>用户定义的运算符不能返回 void</value>
  </data>
  <data name="CqrsFeatureSuggester_ShortDescription" xml:space="preserve">
    <value>您的代码似乎正在使用 CQRS 模式</value>
  </data>
  <data name="RedundantAttributeUsagePropertyAssignmentMessage" xml:space="preserve">
    <value>冗余的 [AttributeUsage] 属性赋值: {0}</value>
  </data>
  <data name="AnExpressionTreeLambdaMayNotContainACallToAMethodPropertyOrIndexerThatReturnsByReferenceMessage" xml:space="preserve">
    <value>表达式树 lambda 不能包含对通过引用返回的方法、属性或索引器的调用</value>
  </data>
  <data name="CompilerWarning_CS1573_Title" xml:space="preserve">
    <value>参数在 XML 注释中没有匹配的 param 标记(但其他参数有)</value>
  </data>
  <data name="OnlyReplaceReadonlyFieldsTitle" xml:space="preserve">
    <value>仅替换 'readonly' 字段</value>
  </data>
  <data name="QualifierIsMissingMessage" xml:space="preserve">
    <value>缺少限定符</value>
  </data>
  <data name="UsageOfTabulationCharacterForIndentationIsProhibited" xml:space="preserve">
    <value>禁止使用制表符缩进</value>
  </data>
  <data name="UseWithExpressionToCopyAnonymousObject" xml:space="preserve">
    <value>使用 'with' 表达式复制匿名对象</value>
  </data>
  <data name="ReplaceUsingStatementOrDeclarationWithAwaitUsingForm" xml:space="preserve">
    <value>将 'using' 语句或声明替换为 'await using' 表单</value>
  </data>
  <data name="yieldReturnStatementCannotAppearInTryCatchBlockMessage" xml:space="preserve">
    <value>'yield return' 语句不能出现在 try/catch 块中</value>
  </data>
  <data name="AvoidUsingasyncLambdaWhenDelegateTypeReturnsvoidMessage" xml:space="preserve">
    <value>当委托类型返回 'void' 时，避免使用 'async' lambda: lambda 未处理的任何异常都可能导致进程崩溃</value>
  </data>
  <data name="PossibleIncorrectImplementationOfDoubleCheckLockingCheckedFieldMustBeVolatileOrAssignedFromLocalVariableAfterThreadMemoryBarrierCall" xml:space="preserve">
    <value>可能错误地实现了双重检查锁定。checked 字段必须为 volatile 或在 'Thread.MemoryBarrier()' 调用之后从局部变量中赋值。</value>
  </data>
  <data name="RedundantNullableAnnotationOnclassConstraintOfTypeParameterConstrainedByNonNullableBaseType" xml:space="preserve">
    <value>受不可以为 null 的基类型约束的类型形参的 'class?' 约束上存在冗余的可以为 null 的注解</value>
  </data>
  <data name="ThereIsNoCodeInspectionIssueDisabledByThisCommentOrAttributeMessage" xml:space="preserve">
    <value>没有此注释或特性禁用的代码检查问题</value>
  </data>
  <data name="PartialPropertyInitializerDuplicatedMessage" xml:space="preserve">
    <value>分部属性不能在定义和实现上都具有初始值设定项</value>
  </data>
  <data name="UseBracesToSeparateFixedStatementBody_Text" xml:space="preserve">
    <value>使用大括号分隔 'fixed' 语句体</value>
  </data>
  <data name="PutAssignmentExpressionIntoBlockMessage" xml:space="preserve">
    <value>将赋值表达式放入块中</value>
  </data>
  <data name="MethodWithOptionalOrparamsParameterIsHiddenByOverload" xml:space="preserve">
    <value>带有可选或 'params' 形参的方法被重载隐藏</value>
  </data>
  <data name="NoBestTypeFoundForImplicitlyTypedArrayMessage" xml:space="preserve">
    <value>找不到隐式类型数组的最佳类型</value>
  </data>
  <data name="OneOfTheParametersOfABinaryOperatorMustBeOfTheContainingTypeMessage" xml:space="preserve">
    <value>二进制运算符的其中一个形参必须为包含类型</value>
  </data>
  <data name="IsNotAValidCallingConventionTypeForUnmanagedCallersOnlyMessage" xml:space="preserve">
    <value>'{0}' 不是 'UnmanagedCallersOnly' 的有效调用惯例类型</value>
  </data>
  <data name="NonNullableBackingFieldsAreUninitializedInConstructorConsiderDeclaringTheAsNullableOrUseAttributesMessage" xml:space="preserve">
    <value>在退出构造函数时，不可为 null 的属性{0}必须包含非 null 值。请考虑添加 '{1}' 修饰符或将属性声明为可以为 null{2}。</value>
  </data>
  <data name="AccessorInInterfaceCannotDeclareABodyMessage" xml:space="preserve">
    <value>interface {0} 中的访问器不能声明主体</value>
  </data>
  <data name="ConvertConstructorToMemberInitializersMessage" xml:space="preserve">
    <value>将构造函数转换为成员初始值设定项</value>
  </data>
  <data name="RedundantNullabilityAttributeUsedWithDeclarationThatCannotBeDirectlyReferencedFromOtherCode" xml:space="preserve">
    <value>冗余的为 null 性特性与不能从其他代码直接引用的声明一起使用</value>
  </data>
  <data name="BackingFieldIsUsedButNeverAssignedMessage" xml:space="preserve">
    <value>支持字段已被使用，但从未被赋值</value>
  </data>
  <data name="CompilerWarning_CS1974_Title" xml:space="preserve">
    <value>动态调度的调用可能会在运行时失败，因为一个或多个适用的重载为条件方法</value>
  </data>
  <data name="EntityFramework_ModelCircularDependencyHighlighting_ToolTip_Text" xml:space="preserve">
    <value>此属性定义的关系可能导致依赖关系循环</value>
  </data>
  <data name="VarUsageInDeconstructionDeclarations_Text" xml:space="preserve">
    <value>析构声明中的 'var' 用法</value>
  </data>
  <data name="CannotUseInMemberInitializerMessage" xml:space="preserve">
    <value>不能在成员初始值设定项中使用 '{0}'</value>
  </data>
  <data name="TheKeywordnewIsRequiredOnBecauseItHidesMessage" xml:space="preserve">
    <value>'{1}' 上需要关键字 '{0}'，因为它会隐藏{2} '{3}'</value>
  </data>
  <data name="AccessModifierIsNotAllowedForStaticConstructorMessage" xml:space="preserve">
    <value>static 构造函数不允许使用访问修饰符</value>
  </data>
  <data name="ConditionalAccessQualifierExpressionIsKnownToBeNullOrNotNull" xml:space="preserve">
    <value>条件访问限定符表达式已知为 null 或非 null</value>
  </data>
  <data name="ParameterOfUnaryOperatorMustBeOfContainingTypeMessage" xml:space="preserve">
    <value>一元运算符的形参必须为包含类型</value>
  </data>
  <data name="NotNullable_Text" xml:space="preserve">
    <value>不可为 null</value>
  </data>
  <data name="DoesNotContainADefinitionForAppendLiteralMethodMessage" xml:space="preserve">
    <value>'{0}' 不包含 'AppendLiteral' 方法的定义</value>
  </data>
  <data name="TypeDoesNotExtendSystemExceptionMessage" xml:space="preserve">
    <value>类型 '{0}' 不扩展 'System.Exception'</value>
  </data>
  <data name="UseBracesToSeparateForStatementBody_Text" xml:space="preserve">
    <value>使用大括号分隔 'for' 语句体</value>
  </data>
  <data name="ConflictCqrsAttributeDescription" xml:space="preserve">
    <value>CQRS 实体使用冲突的特性进行注解</value>
  </data>
  <data name="InvalidBaseTypeMessage" xml:space="preserve">
    <value>无效的基类型</value>
  </data>
  <data name="NonReadonlyReferencedInGetHashCodeMessage" xml:space="preserve">
    <value>'GetHashCode()' 中引用了非只读 {0}</value>
  </data>
  <data name="SuggestToReplaceExprExprToExprExprExprExprToExprExpr" xml:space="preserve">
    <value>建议将
          !(expr1 != expr2) 替换为 expr1 == expr2
          !(expr1 == expr2) 替换为 expr1 != expr2</value>
  </data>
  <data name="PossibleSystemNullReferenceExceptionMessage" xml:space="preserve">
    <value>可能的 '{0}.{1}'</value>
  </data>
  <data name="CompilerWarning_CS8909_Title" xml:space="preserve">
    <value>不比较函数指针值</value>
  </data>
  <data name="TypeCannotBeUsedInUsingStaticDirectiveMessage" xml:space="preserve">
    <value>'{0}' 类型不能用于 'using static' 指令</value>
  </data>
  <data name="CompilerWarning_CS9196_Title" xml:space="preserve">
    <value>形参的引用种类修饰符与被重写或实现的成员中的相应形参不匹配</value>
  </data>
  <data name="TypeParameterInheritsConflictingConstraintsstructAndMessage" xml:space="preserve">
    <value>类型形参 '{0}' 继承冲突的约束 'struct' 和 '{1}'</value>
  </data>
  <data name="getsetOrinitExpectedMessage" xml:space="preserve">
    <value>应为 'get'、'set' 或 'init'</value>
  </data>
  <data name="PossibleAmbiguityWhileAccessingMemberByInterface" xml:space="preserve">
    <value>通过接口访问成员时可能存在多义性</value>
  </data>
  <data name="EmptyRegionTitle" xml:space="preserve">
    <value>空区域</value>
  </data>
  <data name="PartialMethodMustHaveAnImplementationPartBecauseItHasAccessibilityModifiersMessage" xml:space="preserve">
    <value>分部方法“{0}”必须具有实现部分，因为它具有可访问性修饰符</value>
  </data>
  <data name="CompilerWarning_CS9090_Title" xml:space="preserve">
    <value>这将按引用返回作用域为当前方法的参数的成员</value>
  </data>
  <data name="TheTypeMustBeANonNullableValueTypeInOrderToUseItAsParameterMessage" xml:space="preserve">
    <value>类型 '{0}' 必须为不可以为 null 的值类型才能将其用作形参 '{1}'</value>
  </data>
  <data name="AssignmentInConditionalExpressionDidYouMeanToUseInsteadOf" xml:space="preserve">
    <value>条件表达式中存在赋值；您是要使用 '==' 而不是 '=' 吗?</value>
  </data>
  <data name="EntityFramework_NavigationPropertyInitializationHighlighting_Title_Text" xml:space="preserve">
    <value>初始化属性以避免可能的运行时错误</value>
  </data>
  <data name="PossibleIncorrectImplementationOfDoubleCheckLockingPatternPossibleMultipleWriteAccessToCheckedField20" xml:space="preserve">
    <value>可能错误地实现了双重检查锁定模式。可能对 checked 字段进行了多次写入访问。</value>
  </data>
  <data name="BackingFieldOfPropertyWithfieldKeywordIsUsedButNeverAssigned" xml:space="preserve">
    <value>带有 'field' 关键字的属性的支持字段已被使用，但从未被赋值</value>
  </data>
  <data name="CannotResolveSymbolMessage" xml:space="preserve">
    <value>无法解析符号'{0}'</value>
  </data>
  <data name="CannotBeVirtualMessage" xml:space="preserve">
    <value>{0}不能为 virtual</value>
  </data>
  <data name="PartialHasEventInitializerMessage" xml:space="preserve">
    <value>分部事件不能具有初始值设定项</value>
  </data>
  <data name="PartOfLoopsBodyCanBeConvertedIntoLINQExpressionButAnotherGetEnumeratorMethodWillBeUsedMessage" xml:space="preserve">
    <value>循环体的一部分可以转换为 LINQ 表达式，但将使用另一个 'GetEnumerator' 方法</value>
  </data>
  <data name="NotDisposedEnumeratorTitle" xml:space="preserve">
    <value>'GetEnumerator' 方法调用的返回值永远不会被处置</value>
  </data>
  <data name="ConvertsPropertyDeclarationToCAutoPropertySyntaxWithPrivateSetterDeclared" xml:space="preserve">
    <value>将属性声明转换为声明了 private setter 的 C# 自动属性语法</value>
  </data>
  <data name="CompilerWarning_CS8001_Title" xml:space="preserve">
    <value>命令行开关尚未实现</value>
  </data>
  <data name="MultipleCqrsEntityDescription" xml:space="preserve">
    <value>无法识别 CQRS 实体，因为其名称、实现的接口或特性之间存在冲突</value>
  </data>
  <data name="UnusedParameterOfLocalFunction" xml:space="preserve">
    <value>局部函数的未使用形参</value>
  </data>
  <data name="ReplaceChainOfTernaryExpressionsWithSwitchExpression" xml:space="preserve">
    <value>将三元表达式链替换为 'switch' 表达式</value>
  </data>
  <data name="RedundantAnonymousTypePropertyExplicitName" xml:space="preserve">
    <value>冗余的匿名类型属性显式名称</value>
  </data>
  <data name="DuplicatedStatementsTitle" xml:space="preserve">
    <value>重复语句</value>
  </data>
  <data name="KindNameIsGetOnly_Text" xml:space="preserve">
    <value>{0} 为只获取。</value>
  </data>
  <data name="InterpolatedStringHandlerMethodIsMalformedItDoesNotReturnvoidOrboolMessage" xml:space="preserve">
    <value>内插字符串处理程序方法 '{0}' 格式错误。它不返回 'void' 或 'bool'。</value>
  </data>
  <data name="CompilerWarning_CS8620_Title" xml:space="preserve">
    <value>由于引用类型的可为 null 性差异，实参不能用于形参。</value>
  </data>
  <data name="KindNameReturnsReadOnlyReference_Text" xml:space="preserve">
    <value>{0} 返回只读引用。</value>
  </data>
  <data name="PartOfTheCodeCannotBeParsedBecauseOfDeepNesting" xml:space="preserve">
    <value>由于深度嵌套，部分代码不能解析</value>
  </data>
  <data name="InvalidInlineArrayLayoutMessage" xml:space="preserve">
    <value>内联数组结构不得具有显式布局</value>
  </data>
  <data name="ThenotnullConstraintIsRedundantBecauseTypeParameterIsConstrainedByNonNullableBaseType" xml:space="preserve">
    <value>'notnull' 约束冗余，因为类型形参受不可以为 null 的基类型约束</value>
  </data>
  <data name="UsingStatementResourceInitializationTitle" xml:space="preserve">
    <value>不为 'using' 变量使用对象初始值设定项</value>
  </data>
  <data name="PossibleCallToMethodIsInvalidForTheObjectsCurrentState" xml:space="preserve">
    <value>对于对象的当前状态，可能的方法调用无效</value>
  </data>
  <data name="AttributeArgumentCannotUseTypeParametersMessage" xml:space="preserve">
    <value>特性实参不能使用类型形参</value>
  </data>
  <data name="CycleInConstantValueComputationMessage" xml:space="preserve">
    <value>常量值计算中存在循环</value>
  </data>
  <data name="RedundantExplicitPositionalPropertyDeclaration" xml:space="preserve">
    <value>冗余的显式位置属性声明</value>
  </data>
  <data name="CompilerWarning_CS8669_Title" xml:space="preserve">
    <value>对可为 null 的引用类型的批注只应在 "#nullable" 批注上下文中的代码中使用。自动生成的代码要求在源中使用显式 "#nullable" 指令。</value>
  </data>
  <data name="CompilerWarning_CS0278_Title" xml:space="preserve">
    <value>类型不实现集合模式；成员不明确</value>
  </data>
  <data name="CannotInitializeAByValueWithAReferenceMessage" xml:space="preserve">
    <value>不能使用引用初始化按值{0}</value>
  </data>
  <data name="ItIsNotLegalToUseNullableReferenceTypeInAnIsTypeExpressionUseTheUnderlyingTypeInsteadMessage" xml:space="preserve">
    <value>在 is-type 表达式中使用可以为 null 的引用类型 '{0}' 不合法；请改用基础类型 '{1}'</value>
  </data>
  <data name="TheTypeCannotBeUsedAsATypeArgumentMessage" xml:space="preserve">
    <value>类型 '{0}' 不能用作类型实参</value>
  </data>
  <data name="EmptyRegionDescription" xml:space="preserve">
    <value>区域不包含任何代码，可以移除</value>
  </data>
  <data name="IntegralConstantIsTooLargeMessage" xml:space="preserve">
    <value>整数常量太大</value>
  </data>
  <data name="ACopyConstructorInARecordMustCallACopyConstructorOfTheBaseOrAParameterlessObjectConstructorIfTheRecordInheritsFromObjectMessage" xml:space="preserve">
    <value>如果记录继承自 object，则记录中的复制构造函数必须调用基对象的复制构造函数，或者调用无参数的对象构造函数</value>
  </data>
  <data name="DefaultParameterValueAttributeShouldBeUsedInConjunctionWithOptionalAttributeMessage" xml:space="preserve">
    <value>'DefaultParameterValueAttribute' 应与 'OptionalAttribute' 结合使用</value>
  </data>
  <data name="Operator_With_Operands_Text" xml:space="preserve">
    <value>带有({1})操作数的运算符 {0}</value>
  </data>
  <data name="StaticClassCannotHaveabstractModifierMessage" xml:space="preserve">
    <value>static 类 '{0}' 不能有 'abstract' 修饰符</value>
  </data>
  <data name="CallingConventionCanOnlyBeSpecifiedForunmanagedFunctionPointerMessage" xml:space="preserve">
    <value>只能为 'unmanaged' 函数指针指定调用惯例</value>
  </data>
  <data name="RedundantBracesInCollectionInitializer" xml:space="preserve">
    <value>集合初始值设定项中存在冗余的大括号</value>
  </data>
  <data name="BracesAndOperatorsBraces_RiderPresentableName" xml:space="preserve">
    <value>大括号和运算符//大括号</value>
  </data>
  <data name="EXPERIMENTALParameterIsInferredToBeNullableConsiderAnnotatingItWithCanBeNullOrItemCanBeNullAttributeThisInspectionSometimesProducesUnsoundResults" xml:space="preserve">
    <value>[EXPERIMENTAL] 形参被推断为可以为 null: 请考虑使用 [CanBeNull] 或 [ItemCanBeNull] 注解特性。该检查有时会产生不合理的结果。</value>
  </data>
  <data name="InstanceCannotImplementFromInterfaceMessage" xml:space="preserve">
    <value>实例{0} '{1}' 不能从接口 {2} 实现{3}{0}</value>
  </data>
  <data name="NonObviousPrecedenceMessage" xml:space="preserve">
    <value>优先级不明显</value>
  </data>
  <data name="TypeCannotBeUsedInawaitForeachStatementBecauseItNeitherImplementsIAsyncEnumerableTNorHasSuitableGetAsyncEnumeratorMethodWhichReturnTypeHasCurrentPropertyAndMoveNextAsyncMethodDidYouMeanToUseforeachInsteadOfawaitForeachMessage" xml:space="preserve">
    <value>只有类型 '{0}' 实现 'IAsyncEnumerable&lt;T&gt;'，或者具有合适的 'GetAsyncEnumerator' 方法(返回值类型具有 'Current' 属性和 'MoveNextAsync' 方法)，才能在 'await foreach' 语句中使用。您是要使用 'foreach' 而不是 'await foreach' 吗?</value>
  </data>
  <data name="CompilerWarning_CS8610_Title" xml:space="preserve">
    <value>参数类型中引用类型的为 Null 性与重写成员不匹配。</value>
  </data>
  <data name="CannotDeconstructATupleOfElementsIntoVariablesMessage" xml:space="preserve">
    <value>不能将 '{0}' 元素元组析构为 '{1}' 变量</value>
  </data>
  <data name="BadExtensionContainingTypeErrorMessage" xml:space="preserve">
    <value>扩展必须在顶层、非泛型、static 类中声明</value>
  </data>
  <data name="InterceptorContainingTypeCannotBeGenericMessage" xml:space="preserve">
    <value>方法 '{0}' 不能用作拦截器，因为它的包含类型具有类型形参</value>
  </data>
  <data name="ReplaceAutoPropertyWithComputedPropertyMessage" xml:space="preserve">
    <value>将自动属性替换为计算所得属性</value>
  </data>
  <data name="PreprocessorDirectivesAreNotAllowedInsideStringInterpolationMessage" xml:space="preserve">
    <value>字符串内插中不允许使用预处理程序指令</value>
  </data>
  <data name="AnAttributeIsUsedToDeclareTheNullabilityOfATypeNullableReferenceTypesAnnotationsMightBeUsedInstead" xml:space="preserve">
    <value>特性用于声明类型的为 null 性。可以改用可以为 null 的引用类型的注解。</value>
  </data>
  <data name="UseBracesToSeparateIfElseStatementBody_Text" xml:space="preserve">
    <value>使用大括号分隔 'if-else' 语句体</value>
  </data>
  <data name="CannotCallAnAbstractBaseMessage" xml:space="preserve">
    <value>不能调用 abstract 基{0} '{1}'</value>
  </data>
  <data name="CompilerWarning_CS1711_Title" xml:space="preserve">
    <value>XML 注释中有 typeparam 标记，但是没有该名称的类型参数</value>
  </data>
  <data name="KindNameParameterIsReadOnlyReference_Text" xml:space="preserve">
    <value>'{0}' {1} '{2}' 为只读引用。</value>
  </data>
  <data name="CompilerWarning_CS1762_Title" xml:space="preserve">
    <value>由于使用间接程序集引用，因此创建了对嵌入互操作程序集的引用</value>
  </data>
  <data name="CollectionExpressionFoundAddMethodWithRefOrOutParameters_Text" xml:space="preserve">
    <value>集合表达式的 'Add' 方法不能有 'ref' 或 'out' 形参。找到候选: '{0}'</value>
  </data>
  <data name="NotNullOrCanBeNullAttributeIsAppliedToATypeThatAlreadyHasTheSameAnnotationFromNullableReferenceTypes" xml:space="preserve">
    <value>[NotNull] 或 [CanBeNull] 特性应用于已具有来自可以为 null 的引用类型的相同注解的类型</value>
  </data>
  <data name="ArgumentIsvolatileFieldReferenceToItWillNotBeTreatedAsvolatileMessage" xml:space="preserve">
    <value>'{0}' 实参是 'volatile' 字段，对它的引用将不被视为 'volatile'</value>
  </data>
  <data name="FeatureextensionGetEnumeratorIsNotAvailablePleaseUseLanguageVersionOrGreaterMessage" xml:space="preserve">
    <value>“扩展 GetEnumerator”功能不可用。请使用语言版本 9.0 或更高版本。</value>
  </data>
  <data name="AssignmentInsteadOfDiscardMessage" xml:space="preserve">
    <value>该表达式看起来像弃元模式，但实际上分配了一个局部变量 '_'</value>
  </data>
  <data name="ParameterIsNotExplicitlyProvidedButIsUsedAsAnArgumentToTheInterpolatedStringHandlerConversionOnParameterSpecifyTheValueOfBeforeMessage" xml:space="preserve">
    <value>形参 '{0}' 未显式提供，但被用作形参 '{1}' 上内插字符串处理程序转换的实参。请在 '{1}' 之前指定 '{0}' 的值。</value>
  </data>
  <data name="XMLCommentOnHasADuplicateParamTagForMessage" xml:space="preserve">
    <value>'{0}' 上的 XML 注释具有 '{1}' 的重复 param 标记</value>
  </data>
  <data name="EnforceBracesIndoWhileStatement" xml:space="preserve">
    <value>在 'do-while' 语句中强制使用大括号</value>
  </data>
  <data name="PartiallyOpenedTypeIsNotPermittedIntypeofExpressionMessage" xml:space="preserve">
    <value>'typeof' 表达式中不允许使用部分打开的类型</value>
  </data>
  <data name="ConditionalAccessQualifierExpressionIsKnownToBeNotNullMessage" xml:space="preserve">
    <value>条件访问限定符表达式已知为非 null</value>
  </data>
  <data name="baseQualifierIsRedundantAndCanBeSafelyRemovedWithoutChangingCodeSemantics" xml:space="preserve">
    <value>'base.' 限定符冗余，可以安全地移除而不更改代码语义</value>
  </data>
  <data name="CannotAssignvoidToAnonymousTypePropertyMessage" xml:space="preserve">
    <value>不能将 'void' 赋给匿名类型属性</value>
  </data>
  <data name="AStaticLocalFunctionCannotContainAReferenceTothisOrbaseMessage" xml:space="preserve">
    <value>static 局部函数不能包含对 'this' 或 'base' 的引用</value>
  </data>
  <data name="PointersMayOnlyBeUsedInAnUnsafeContextMessage" xml:space="preserve">
    <value>只能在 unsafe 上下文中使用指针</value>
  </data>
  <data name="MethodsLocalFunction_RiderPresentableName" xml:space="preserve">
    <value>方法//局部函数</value>
  </data>
  <data name="ParameterIsInferredToBeNotNull" xml:space="preserve">
    <value>形参被推断为非 null</value>
  </data>
  <data name="BadSpecialByRefUsingMessage" xml:space="preserve">
    <value>'{0}' 类型的 using 语句资源不能用于异步方法或异步 lambda 表达式</value>
  </data>
  <data name="InterceptorArityNotCompatibleMessage" xml:space="preserve">
    <value>方法 '{0}' 必须为非泛型或具有 2 个参数才能与 '{1}' 匹配</value>
  </data>
  <data name="VariableCanBeDeclaredInsideLoopConditionMessage" xml:space="preserve">
    <value>可以在循环条件内声明变量 '{0}'</value>
  </data>
  <data name="MergeConditionalExpressionIntoConditionalAccessWhenPossible" xml:space="preserve">
    <value>将条件 ?: 表达式合并到条件访问中(如果可能)</value>
  </data>
  <data name="ExtensionReceiverParameterSameNameAsTypeParameterErrorMessage" xml:space="preserve">
    <value>'{0}': 接收器形参不能与扩展类型形参同名</value>
  </data>
  <data name="TheEnumerationMemberValueIsTooLargeToFitInItsUnderlyingTypeMessage" xml:space="preserve">
    <value>枚举成员值太大，不适合其基础类型</value>
  </data>
  <data name="QualifierThisIsMissingMessage" xml:space="preserve">
    <value>缺少限定符 '{0}.'</value>
  </data>
  <data name="IsMissingMessage" xml:space="preserve">
    <value>缺少 ';'</value>
  </data>
  <data name="MethodHasOverloadWithCancellationToken" xml:space="preserve">
    <value>方法具有带 'CancellationToken' 的重载</value>
  </data>
  <data name="MethodWithOptionalOrparamsParameterIsHiddenByOverload25" xml:space="preserve">
    <value>带有可选或 'params' 形参的方法被重载隐藏</value>
  </data>
  <data name="ConstraintsForOverrideMethodAreInheritedFromTheBaseMethodSoTheyCannotBeSpecifiedDirectlyMessage" xml:space="preserve">
    <value>重写方法的约束是从基方法继承的，因此不能直接指定</value>
  </data>
  <data name="ObjectCreation_CategoryText" xml:space="preserve">
    <value>对象创建</value>
  </data>
  <data name="EnforceBracesInForeachStatement_Caption" xml:space="preserve">
    <value>在 'foreach' 语句中强制使用大括号</value>
  </data>
  <data name="StringLiteralCanBeInlinedIntoInterpolation" xml:space="preserve">
    <value>字符串字面量可以内联到内插中</value>
  </data>
  <data name="TheSourceExpressionAlwaysMatchesTheProvidedPattern" xml:space="preserve">
    <value>源表达式始终与提供的模式匹配</value>
  </data>
  <data name="ReplaceMultipleAssignmentsWithSingleDeconstructingAssignmentToPerformSwapping" xml:space="preserve">
    <value>将多次赋值替换为单次析构赋值以执行交换</value>
  </data>
  <data name="TypesNamespace_RiderPresentableName" xml:space="preserve">
    <value>类型//命名空间</value>
  </data>
  <data name="CannotResolveCollectionExpressionCreateMethodMessage" xml:space="preserve">
    <value>'{0}' 不含具有以下预期签名的可访问 '{1}' 方法: 'public static {2} {1}({3})'</value>
  </data>
  <data name="IsNotAReferenceTypeAsRequiredByTheLockStatementMessage" xml:space="preserve">
    <value>“{0}”不是 lock 语句要求的引用类型</value>
  </data>
  <data name="AccessorDeclarationIsMissingMessage" xml:space="preserve">
    <value>缺少访问器声明</value>
  </data>
  <data name="AnExpressionTreeMayNotContainATupleLiteralMessage" xml:space="preserve">
    <value>表达式树不能包含元组字面量</value>
  </data>
  <data name="RedundantAttributeMessage" xml:space="preserve">
    <value>{0} 特性冗余</value>
  </data>
  <data name="RelationalPatternsMayNotBeUsedForAFloatingPointNaNMessage" xml:space="preserve">
    <value>关系模式不能用于浮点 NaN</value>
  </data>
  <data name="MethodHasAsyncOverloadWithCancellationToken" xml:space="preserve">
    <value>方法具有带 'CancellationToken' 的异步重载</value>
  </data>
  <data name="TypeOrNamespaceNameExpectedButNameFoundMessage" xml:space="preserve">
    <value>应为类型或命名空间名称，但实际为{0}名称</value>
  </data>
  <data name="CompilerWarning_CS8613_Title" xml:space="preserve">
    <value>返回类型中引用类型的为 Null 性与隐式实现的成员不匹配。</value>
  </data>
  <data name="MethodHasReturnValueNameThatDiffersFromImplementedInterfaceMethodReturnValueNamePleaseMakeSureThatTheNamesAreIdenticalMessage" xml:space="preserve">
    <value>方法的返回值名称与实现的接口方法返回值名称 '{0}' 不同。请确保名称相同。</value>
  </data>
  <data name="CannotUseAResultOfInThisContextBecauseItMayExposeVariablesReferencedByParameterOutsideOfTheirDeclarationScopeMessage" xml:space="preserve">
    <value>不能在此上下文中使用 '{0}' 的结果，因为它可能会在声明作用域以外公开形参 '{1}' 引用的变量</value>
  </data>
  <data name="CannotDynamicInvokeOnExpressionMessage" xml:space="preserve">
    <value>无法对类型为 '{0}' 的表达式执行动态调用</value>
  </data>
  <data name="CannotUseAnExtensionMethodWithAReceiverAsTheTargetOfAOperatorMessage" xml:space="preserve">
    <value>不能将接收器与扩展方法一起用作 '&amp;' 运算符的目标</value>
  </data>
  <data name="DuplicateModifierMessage" xml:space="preserve">
    <value>“{0}”修饰符重复</value>
  </data>
  <data name="DestructorCannotHaveParametersMessage" xml:space="preserve">
    <value>析构函数不能有形参</value>
  </data>
  <data name="EventAccessorCannotHaveModifiersMessage" xml:space="preserve">
    <value>事件访问器不能有修饰符</value>
  </data>
  <data name="TypeCannotBeUsedInforeachStatementBecauseItNeitherImplementsIEnumerableOrIEnumerableTNorHasSuitableGetEnumeratorMethodWhichReturnTypeHasCurrentPropertyAndMoveNextMethodMessage" xml:space="preserve">
    <value>只有类型 '{0}' 实现 'IEnumerable' 或 'IEnumerable&lt;T&gt;'，或者具有合适的 'GetEnumerator' 方法(返回值类型具有 'Current' 属性和 'MoveNext' 方法)，才能用于 'foreach' 语句</value>
  </data>
  <data name="CompilerWarning_CS8604_Title" xml:space="preserve">
    <value>引用类型参数可能为 null。</value>
  </data>
  <data name="UseCompoundAssignment" xml:space="preserve">
    <value>使用复合分配</value>
  </data>
  <data name="RemoveRedundantParentheses" xml:space="preserve">
    <value>移除冗余括号</value>
  </data>
  <data name="ReplaceWithSingleCallToFirstOrDefault_Text" xml:space="preserve">
    <value>替换为对 FirstOrDefault(..) 的单个调用</value>
  </data>
  <data name="TrueIsRedundantAsForStatementConditionMessage" xml:space="preserve">
    <value>'{0}' 作为 '{1}' 语句条件冗余</value>
  </data>
  <data name="CSharpFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_declaration_braces" xml:space="preserve">
    <value>声明大括号周围</value>
  </data>
  <data name="LocalVariableHidesMemberMessage" xml:space="preserve">
    <value>局部变量 '{0}' 会隐藏{1} '{2}'</value>
  </data>
  <data name="StreamReadReturnValueIgnoredDescription" xml:space="preserve">
    <value>请使用 'Stream.ReadExactly()' 而非 'Read()'，以确保从流中读取的字节数与预期值相等</value>
  </data>
  <data name="NamedArgumentIsUsedOutOfPositionButIsFollowedByAnUnnamedArgumentMessage" xml:space="preserve">
    <value>命名参数“{0}”的使用位置不当，但后跟一个未命名参数</value>
  </data>
  <data name="PreferSeparateDeclarationsForDeconstructed_Caption" xml:space="preserve">
    <value>为析构变量首选单独的声明</value>
  </data>
  <data name="sealedOrprivateMethodInInterfaceMustDeclareABodyMessage" xml:space="preserve">
    <value>接口中的 'sealed' 或 'private' 方法必须声明主体</value>
  </data>
  <data name="IncorrectBoundaryTypeConstantExpectedAnnotation_Message" xml:space="preserve">
    <value>值 {0}={1} 与形参类型 {2} 不兼容</value>
  </data>
  <data name="InvalidTypeSpecifiedInBaseTypeRequiredAttributeUsageOnlyClassesAndInterfacesSupported" xml:space="preserve">
    <value>'[BaseTypeRequired]' 特性用法中指定的类型无效。仅支持类和接口。</value>
  </data>
  <data name="ChangeFieldTypeToSystemThreadingLockDescription" xml:space="preserve">
    <value>可以将锁定字段的类型更改为 'System.Threading.Lock' 以表达字段意图</value>
  </data>
  <data name="UseTypeEmptyTypes" xml:space="preserve">
    <value>使用 'Type.EmptyTypes'</value>
  </data>
  <data name="PossiblyMistakenUseOfCancellationTokenMessage_AdditionMultiple" xml:space="preserve">
    <value>包含{0}声明以下变量:</value>
  </data>
  <data name="ConvertToFileScopedNamespaceMessage" xml:space="preserve">
    <value>转换为文件作用域的命名空间</value>
  </data>
  <data name="TheOperatorRequiresAMatchingOperatorToAlsoBeDefinedMessage" xml:space="preserve">
    <value>运算符“{0}”要求也要定义匹配的运算符“{1}”</value>
  </data>
  <data name="SourceFileCanOnlyContainSingleFileScopedNamespaceMessage" xml:space="preserve">
    <value>源文件只能包含单个文件作用域命名空间</value>
  </data>
  <data name="TypeParameterHasNoMatchingTypeparamTagInTheXMLCommentOnButOtherTypeParametersDoMessage" xml:space="preserve">
    <value>类型参数“{0}”在“{1}”的 XML 注释中没有匹配的 typeparam 标记(但其他类型参数有)</value>
  </data>
  <data name="RedundantnotnullConstraintOnTypeParameterConstrainedByNonNullableBaseType" xml:space="preserve">
    <value>受不可以为 null 的基类型约束的类型形参上存在冗余的 'notnull' 约束</value>
  </data>
  <data name="AddRemoveQualifierForStaticMembers" xml:space="preserve">
    <value>添加/移除 static 成员的限定符</value>
  </data>
  <data name="PartialMethodWithoutImplementingDeclarationMessage" xml:space="preserve">
    <value>不实现声明的分部方法</value>
  </data>
  <data name="PossibleLossOfPrecisionWhileRounding_Text" xml:space="preserve">
    <value>舍入值时可能出现精度损失</value>
  </data>
  <data name="CompilerWarning_CS1720_Title" xml:space="preserve">
    <value>由于类型的默认值为 null，因此表达式总会导致 System.NullReferenceException</value>
  </data>
  <data name="AddExplicitControlFlowJumpBeforeLocalFunctionInterlineHintActionScopedText" xml:space="preserve">
    <value>在局部函数之前添加显式跳转</value>
  </data>
  <data name="CompilerWarning_CS8619_Title" xml:space="preserve">
    <value>值中的引用类型的为 Null 性与目标类型不匹配。</value>
  </data>
  <data name="UseDiscardAssignmentMessage" xml:space="preserve">
    <value>使用弃元赋值</value>
  </data>
  <data name="InterceptorPathNotInCompilationWithCandidateMessage" xml:space="preserve">
    <value>无法拦截: 编译不包含路径为 '{0}' 的文件。您是要使用路径 '{1}' 吗?</value>
  </data>
  <data name="TheModifierIsNotValidForExplicitInterfaceImplementationMessage" xml:space="preserve">
    <value>修饰符 '{0}' 对显式接口实现无效</value>
  </data>
  <data name="NonNullableNotSatisfiedInConstructorConsiderDeclaringAsNullableMembersMessage" xml:space="preserve">
    <value>在退出构造函数时，不可为 null 的成员 {0} 必须包含非 null 值。请考虑添加 '{1}' 修饰符或将成员声明为可以为 null。</value>
  </data>
  <data name="RedundantclassKeywordInRecordDeclaration" xml:space="preserve">
    <value>记录声明中存在冗余的 'class' 关键字</value>
  </data>
  <data name="StructWithFieldInitializersMustIncludeAnExplicitlyDeclaredConstructorMessage" xml:space="preserve">
    <value>带有字段初始值设定项的结构必须包含显式声明的构造函数</value>
  </data>
  <data name="CannotMakeParameterOfTypeMessage" xml:space="preserve">
    <value>不能设置 '{1}' 类型的 '{0}' 形参</value>
  </data>
  <data name="RedundantReadonlyModifierMessage" xml:space="preserve">
    <value>冗余的 '{0}' 修饰符: {1}</value>
  </data>
  <data name="PossibleIncorrectImplementationOfDoubleCheckLockingPatternPossibleMultipleWriteAccessToCheckedField" xml:space="preserve">
    <value>可能错误地实现了双重检查锁定模式。可能对 checked 字段进行了多次写入访问。</value>
  </data>
  <data name="AccessToCapturedVariableFromAnonymousMethodWhenTheVariableIsModifiedExternally" xml:space="preserve">
    <value>在外部修改变量时，从匿名方法访问捕获变量</value>
  </data>
  <data name="UsePreferredArgumentStyle" xml:space="preserve">
    <value>使用首选实参样式</value>
  </data>
  <data name="ThepartialModifierCanOnlyAppearImmediatelyBeforeclassstructrecordinterfaceOrAMemberReturnTypeMessage" xml:space="preserve">
    <value>'partial' 修饰符只能紧挨在 'class'、'struct'、'record'、'interface'、'event'、实例构造函数名称或者成员、属性或索引器的返回值类型之前</value>
  </data>
  <data name="LINQQuerySyntaxorderbyClauseIsSortingIsAscendingByDefault" xml:space="preserve">
    <value>LINQ 查询语法 'orderby' 子句的排序默认为 'ascending'</value>
  </data>
  <data name="ReplaceThrowingOfArgumentNullExceptionObjectWithAnInvocationOfTheHelperMethod" xml:space="preserve">
    <value>将抛出 'ArgumentNullException' 对象替换为调用 helper 方法</value>
  </data>
  <data name="CompilerWarning_CS8321_Title" xml:space="preserve">
    <value>已声明本地函数，但从未使用过</value>
  </data>
  <data name="TypeDeclarationHasTheSameNameAsInterfaceGeneratedForTypeMessage" xml:space="preserve">
    <value>类型声明的名称与为类型 '{1}' 生成的接口 '{0}' 相同</value>
  </data>
  <data name="Configure_Text" xml:space="preserve">
    <value>配置</value>
  </data>
  <data name="FirstParameterOfShiftOperatorShouldBeMessage" xml:space="preserve">
    <value>移位运算符的第一个形参应为 '{0}'</value>
  </data>
  <data name="AnExpressionTreeCannotContainACallOrInvocationThatUsesOptionalArgumentsMessage" xml:space="preserve">
    <value>表达式树不能包含使用可选实参的调用</value>
  </data>
  <data name="SuggestToMergeCollectionAddsIntoCollectionExpressionSyntax" xml:space="preserve">
    <value>建议将集合条目添加合并到 C# 12 集合表达式语法中</value>
  </data>
  <data name="StaticClassCannotHaveExtendsListMessage" xml:space="preserve">
    <value>static 类 '{0}' 不能有 extends 列表</value>
  </data>
  <data name="UsePreferredvarStyle" xml:space="preserve">
    <value>使用首选的 'var' 样式</value>
  </data>
  <data name="CannotAssignToAnImplicitlyTypedLocalVariableMessage" xml:space="preserve">
    <value>不能将 '{0}' 赋给隐式类型化局部变量</value>
  </data>
  <data name="WhenCollectionInitializerElementHasOnlyOneExpressionTheBracesAreRedundant" xml:space="preserve">
    <value>当集合初始值设定项元素只有​​一个表达式时，大括号冗余</value>
  </data>
  <data name="Property_ProducedWithMustDisposeAnnotatedMethodIsNotDisposedMessage" xml:space="preserve">
    <value>属性 '{0}' 从未被处置</value>
  </data>
  <data name="ConvertToMessage" xml:space="preserve">
    <value>转换为 '??='</value>
  </data>
  <data name="TheReturnTypeOfIncrementDecrementOperatorMustBeOfExtendedTypeMessage" xml:space="preserve">
    <value>递增/递减运算符的返回值类型必须为扩展类型</value>
  </data>
  <data name="ReturnValueOrOutParametersOfMethodIsNotUsedJustificationMessage" xml:space="preserve">
    <value>方法的返回值和 '{0}' 形参均未使用。{1}</value>
  </data>
  <data name="DefinesOperatorOrOperatorButDoesNotOverrideObjectEqualsObjectOAndObjectGetHashCodeMessage" xml:space="preserve">
    <value>'{0}' 定义运算符 '==' 或运算符 '!='，但不重写 'Object.Equals(object o)' 和 'Object.GetHashCode()'</value>
  </data>
  <data name="CompilerWarning_CS8018_Title" xml:space="preserve">
    <value>在 cref 特性中，应限定泛型类型的嵌套类型</value>
  </data>
  <data name="AnExpressionOfTypeAlwaysMatchesTheProvidedPatternMessage" xml:space="preserve">
    <value>'{0}' 类型的表达式始终与提供的模式匹配</value>
  </data>
  <data name="InconsistentAccessibilityTypeIsLessAccessibleThanMessage" xml:space="preserve">
    <value>可访问性不一致: {0}类型 '{1}' 的可访问性低于{2} '{3}'</value>
  </data>
  <data name="LocalFunctionHidesMessage" xml:space="preserve">
    <value>局部函数 '{0}' 会隐藏{1} '{2}'</value>
  </data>
  <data name="CapturedPrimaryConstructorParameterPassedToBaseMessage" xml:space="preserve">
    <value>参数“{0}”捕获到封闭类型状态，其值也传递给基构造函数。该值也可能由基类捕获</value>
  </data>
  <data name="CompilerWarning_CS8601_Title" xml:space="preserve">
    <value>引用类型赋值可能为 null。</value>
  </data>
  <data name="TheOperatorMustBeAppliedToAPointerMessage6" xml:space="preserve">
    <value>'*' 运算符必须应用于指针</value>
  </data>
  <data name="InterfaceIsAlreadyListedInTheInterfaceListOnWithDifferentTupleElementNamesAsMessage" xml:space="preserve">
    <value>接口 '{0}' 已在具有不同元组元素名称的{1} '{2}' 上的接口列表中作为 '{3}&gt;' 列出</value>
  </data>
  <data name="AddressOfManagedTypeWarningMessage" xml:space="preserve">
    <value>这将获取托管类型('{0}')的地址、获取其大小或声明指向托管类型的指针</value>
  </data>
  <data name="MethodNameIsExpectedMessage" xml:space="preserve">
    <value>应为方法名称</value>
  </data>
  <data name="RefReturnScopedParameterWarningMessage" xml:space="preserve">
    <value>这会通过引用返回{0} '{1}'，但它的作用域仅限于当前方法</value>
  </data>
  <data name="InterceptedCallHintHighlighting_Tooltip" xml:space="preserve">
    <value>此调用被拦截**(ctrl+点击以导航)**</value>
  </data>
  <data name="TargetRuntimeDoesNotSupportCovariantReturnTypesInOverridesMessage" xml:space="preserve">
    <value>重写{0} '{1}' 时无法更改返回值类型，因为目标运行时在重写中不支持协变返回值类型</value>
  </data>
  <data name="RedundantClassKeywordInRecordDeclarationMessage" xml:space="preserve">
    <value>记录声明中存在冗余的 '{0}' 关键字</value>
  </data>
  <data name="TheReceiverTypeIsNotAValidRecordOrValueTypeMessage" xml:space="preserve">
    <value>接收器类型 '{0}' 不是有效的记录或值类型</value>
  </data>
  <data name="CompilerWarning_CS9200_Title" xml:space="preserve">
    <value>为 'ref readonly' 形参指定了默认值，但 'ref readonly' 应仅用于引用。请考虑将该形参声明为 'in'</value>
  </data>
  <data name="PatternMatchingExpressions_Text" xml:space="preserve">
    <value>模式匹配的表达式</value>
  </data>
  <data name="LocalVariableHasTheSameNameAsAPrimaryConstructorParameterAndHidesIt" xml:space="preserve">
    <value>局部变量与主构造函数形参同名，并将其隐藏</value>
  </data>
  <data name="ConvertToAwaitUsingStatementOrDeclaration" xml:space="preserve">
    <value>转换为 'await using' 语句或声明</value>
  </data>
  <data name="internalModifierCanBeSafelyAddedRemovedFromTypesWithoutChangingCodeSemantics" xml:space="preserve">
    <value>可以安全地在类型中添加/移除 'internal' 修饰符而不更改代码语义</value>
  </data>
  <data name="UseObjectOrCollectionInitializerWhenPossible" xml:space="preserve">
    <value>如果可能，使用对象或集合初始值设定项</value>
  </data>
  <data name="MethodSpecifiesAstructConstraintForTypeParameterButCorrespondingTypeParameterOfOverriddenOrExplicitlyImplementedMethodIsNotANonNullableValueTypeMessage" xml:space="preserve">
    <value>方法 '{0}' 为类型形参 '{1}' 指定了 'struct' 约束，但被重写或显式实现的方法 '{3}' 的相应类型形参 '{2}' 不是不可以为 null 的值类型</value>
  </data>
  <data name="PrivateFieldIsAlwaysAssignedBeforeBeingUsedAndCanBeConvertedToLocalVariable" xml:space="preserve">
    <value>private 字段总是在使用前赋值，并且可以转换为局部变量</value>
  </data>
  <data name="CSharpFormatterHighlightingProvider_InternalConfigurableSeverityItems_Line_indent_should_be_restored_to_the_previous_level_elsewhere" xml:space="preserve">
    <value>未还原缩进级别</value>
  </data>
  <data name="Capitalized_Property_Text" xml:space="preserve">
    <value>属性</value>
  </data>
  <data name="NullnessAnnotationConflictsWithAnnotationInSuperTypeMessage" xml:space="preserve">
    <value>Nullness 注解与超类型中的注解冲突</value>
  </data>
  <data name="WinRTTypesCanOnlyImplementOtherWinRTInterfacesMessage" xml:space="preserve">
    <value>WinRT 类型只能实现其他 WinRT 接口</value>
  </data>
  <data name="ReplaceWithSingleCallToSingleOrDefault_Text" xml:space="preserve">
    <value>替换为对 SingleOrDefault(..) 的单个调用</value>
  </data>
  <data name="OnlyAssignmentCallIncrementDecrementAwaitExpressionAndNewObjectExpressionsCanBeUsedAsAStatementMessage" xml:space="preserve">
    <value>只有赋值、调用、递增、递减、await 表达式和新建对象表达式才能用作语句</value>
  </data>
  <data name="TypeSpecifiedInBaseTypeRequiredAttributeConflictsWithAnotherType" xml:space="preserve">
    <value>'[BaseTypeRequired]' 特性中指定的类型与另一个类型冲突</value>
  </data>
  <data name="AssignmentInConditionalExpressionDidYouMeanToUseInsteadOfMessage" xml:space="preserve">
    <value>条件表达式中存在赋值；您是要使用 '==' 而不是 '=' 吗?</value>
  </data>
  <data name="RedundantLambdaExpressionParameterTypeSpecification" xml:space="preserve">
    <value>冗余的 lambda 表达式形参类型规范</value>
  </data>
  <data name="UserDefinedOperatorMustBeDeclaredStaticAndPublicMessage" xml:space="preserve">
    <value>用户定义的运算符必须被声明为 static 或 public</value>
  </data>
  <data name="CompilerWarning_CS3024_Title" xml:space="preserve">
    <value>约束类型不符合 CLS</value>
  </data>
  <data name="ConversionOperatorWithTheSameParameterAndReturnTypesMessage" xml:space="preserve">
    <value>具有相同形参和返回值类型的转换运算符</value>
  </data>
  <data name="RedundantIEnumerableCastTCallMessage" xml:space="preserve">
    <value>冗余的 'IEnumerable.Cast&lt;T&gt;' 调用</value>
  </data>
  <data name="CollectionExpressionTypeIsNotConstructible_Text" xml:space="preserve">
    <value>无法用集合表达式初始化类型 '{0}'，因为该类型不可构造</value>
  </data>
  <data name="PrimaryConstructorParameterCaptureDisallowedDescription" xml:space="preserve">
    <value>实例成员捕获主构造函数形参会导致隐式类型布局。如果您希望不允许捕获主形参，请使用此检查。</value>
  </data>
  <data name="TheExpressionIsAlwaysEvaluatedTonullAtThisPoint" xml:space="preserve">
    <value>此时，表达式求值结果始终为 'null'</value>
  </data>
  <data name="AmbiguousInvocation_Text" xml:space="preserve">
    <value>调用</value>
  </data>
  <data name="RedundantBoolCompare_SupportChecksForFalse_Description" xml:space="preserve">
    <value>建议将 'variable == false' 检查替换为 '!variable'</value>
  </data>
  <data name="ThegotoCaseValueIsNotImplicitlyConvertibleToTypeMessage" xml:space="preserve">
    <value>“goto case”值不可隐式转换为类型“{0}”</value>
  </data>
  <data name="ThreadStaticFieldHasInitializer" xml:space="preserve">
    <value>线程 static 字段具有初始值设定项</value>
  </data>
  <data name="ImplementsMoreThanOneInterfaceMemberPleaseMakeSureThisMemberOnlyImplementsOneInterfaceMemberMessage" xml:space="preserve">
    <value>{0} '{1}' 实现多个接口成员。请确保此成员仅实现一个接口成员。</value>
  </data>
  <data name="RedundantVerbatimPrefix" xml:space="preserve">
    <value>冗余的逐字字符串前缀</value>
  </data>
  <data name="TypeDeclarationBodyBlockExpectedMessage" xml:space="preserve">
    <value>应为类型声明主体块</value>
  </data>
  <data name="PointerTypeCannotBeUsedInObjectCreationMessage" xml:space="preserve">
    <value>不能在对象创建中使用指针类型 '{0}'</value>
  </data>
  <data name="BuiltInTypeReferenceCodeStyleRule_CategoryText" xml:space="preserve">
    <value>在局部变量、成员和形参中引用内置类型时，首选</value>
  </data>
  <data name="ConflictCqrsAttributeMessage" xml:space="preserve">
    <value>冲突的 CQRS 特性。该特性与其实现的实体名称或接口之间存在冲突。</value>
  </data>
  <data name="CannotUsevoidAsAFunctionPointerParameterTypeMessage" xml:space="preserve">
    <value>不能将 'void' 用作函数指针形参类型</value>
  </data>
  <data name="ForLoopCanBeConvertedIntoForeachLoopMessage" xml:space="preserve">
    <value>for 循环可以转换为 foreach 循环</value>
  </data>
  <data name="MustBeEitherrefReadonlyOrRegularVariableInOrderToBeAssignedFromBecauseItReturnsreadonlyReferenceMessage" xml:space="preserve">
    <value>'{0}' 必须为 'ref readonly' 或常规变量才能从 '{1}' 赋值，因为它会返回 'readonly' 引用</value>
  </data>
  <data name="SyntaxError_ToolTip" xml:space="preserve">
    <value>语法错误</value>
  </data>
  <data name="ReplacesIfStatementWithCodeUsingOperatorAndThrowExpression" xml:space="preserve">
    <value>将 if 语句替换为使用 ?? 运算符和 throw 表达式的代码</value>
  </data>
  <data name="InlineTemporaryVariable" xml:space="preserve">
    <value>内联临时变量</value>
  </data>
  <data name="CannotInstantiatedynamicObjectMessage" xml:space="preserve">
    <value>不能实例化 'dynamic' 对象</value>
  </data>
  <data name="RelationalPatternsMayNotBeUsedForAValueOfTypeMessage" xml:space="preserve">
    <value>关系模式不能用于 '{0}' 类型的值</value>
  </data>
  <data name="AFormatSpecifierMayNotContainTrailingWhitespaceMessage" xml:space="preserve">
    <value>格式说明符不能包含尾随空格</value>
  </data>
  <data name="InterfaceNameExpectedMessage" xml:space="preserve">
    <value>'{0}': 应为接口名称</value>
  </data>
  <data name="CompilerWarning_CS9216_Title" xml:space="preserve">
    <value>转换为其他类型后，'System.Threading.Lock' 类型的值将在 'lock' 语句中使用可能意想不到的基于监视器的锁定</value>
  </data>
  <data name="IteratorNeverReturnsMessage" xml:space="preserve">
    <value>迭代器从未返回</value>
  </data>
  <data name="NonGenericStruct_Text" xml:space="preserve">
    <value>非泛型结构</value>
  </data>
  <data name="UseUnsignedRightShiftOperator" xml:space="preserve">
    <value>使用无符号右移运算符 '&gt;&gt;&gt;'</value>
  </data>
  <data name="_IsDeclaredInTheFollowingReferenced_Text" xml:space="preserve">
    <value>{0} 已在以下引用的程序集中声明:</value>
  </data>
  <data name="AnExpressionTreeMayNotContainAwithExpressionMessage" xml:space="preserve">
    <value>表达式树不能包含 'with' 表达式</value>
  </data>
  <data name="UseIndexedProperty" xml:space="preserve">
    <value>使用索引的属性</value>
  </data>
  <data name="NullCheckingPatternRule_Caption" xml:space="preserve">
    <value>null 检查模式样式</value>
  </data>
  <data name="CSharpFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_square_brackets_within_a_statement" xml:space="preserve">
    <value>语句中的方括号周围</value>
  </data>
  <data name="CompilerWarning_CS0108_Title" xml:space="preserve">
    <value>成员隐藏继承的成员；缺少关键字 new</value>
  </data>
  <data name="UserDefinedConversionInAnInterfaceMustConvertToOrFromATypeParameterOnTheEnclosingTypeConstrainedToTheEnclosingTypeMessage" xml:space="preserve">
    <value>在约束为封闭类型的封闭类型上，接口中的用户定义转换必须转换为类型形参或从类型形参进行转换</value>
  </data>
  <data name="CheckedContextIsRedundantNoOperatorsOrConversionsWithOverflowChecksMessage" xml:space="preserve">
    <value>checked 上下文冗余: 没有带溢出检查的运算符或转换</value>
  </data>
  <data name="TypesEvent_RiderPresentableName" xml:space="preserve">
    <value>类型//事件</value>
  </data>
  <data name="MustAllowOverridingBecauseTheContainingRecordIsNotSealedMessage" xml:space="preserve">
    <value>'{0}' 必须允许重写，因为包含记录不是 sealed</value>
  </data>
  <data name="UseCancellationToken" xml:space="preserve">
    <value>使用取消令牌</value>
  </data>
  <data name="NamespaceAliasKindName" xml:space="preserve">
    <value>命名空间</value>
  </data>
  <data name="ARefOrOutValueMustBeAnAssignableVariableMessage" xml:space="preserve">
    <value>ref 或 out 值必须是可以赋值的变量</value>
  </data>
  <data name="RedundantWithCancellationMessage" xml:space="preserve">
    <value>冗余的 'WithCancellation()' 调用</value>
  </data>
  <data name="AVoidTaskOrTaskOfT__Text" xml:space="preserve">
    <value>一个 '{0}'、'{1}' 或 '{2}'</value>
  </data>
  <data name="MergeNullPatternValueChecksIntoOrAndPatterns" xml:space="preserve">
    <value>将 null/模式/值检查合并到 'or'/'and' 模式中</value>
  </data>
  <data name="MissingConfigureAwaitFalseInLibraryCode" xml:space="preserve">
    <value>库代码中缺少 '.ConfigureAwait(false)'</value>
  </data>
  <data name="UsingisToTestCompatibilityWithdynamicIsEssentiallyIdenticalToTestingCompatibilityWithObjectAndWillSucceedForAllNonNullValuesMessage" xml:space="preserve">
    <value>使用 'is' 测试与 'dynamic' 的兼容性在本质上同测试与 'Object' 的兼容性相同，对于所有非 null 值都将成功</value>
  </data>
  <data name="DuplicateInterceptorMessage" xml:space="preserve">
    <value>指示的调用被多次拦截</value>
  </data>
  <data name="UsePreferredStyleOfnewExpressionWhenCreatedTypeIsNotEvident" xml:space="preserve">
    <value>当创建的类型不明确时，使用首选的 'new' 表达式样式</value>
  </data>
  <data name="EmptyPublicConstructorDeclarationWithNoParametersIsRedundantTheCompilerGeneratesTheSameByDefault" xml:space="preserve">
    <value>没有形参的空 public 构造函数声明冗余。默认情况下，编译器生成相同的内容。</value>
  </data>
  <data name="MissingXMLCommentForTypeOrMemberMessage" xml:space="preserve">
    <value>类型或成员 '{0}' 缺少 XML 注释</value>
  </data>
  <data name="CannotBeSealedBecauseItIsNotAnOverrideMessage" xml:space="preserve">
    <value>{0}不能为 sealed，因为它不是 override</value>
  </data>
  <data name="LockingOverInstanceOfASynchronizationPrimitiveDidYouMeanToUseMembersInsteadMessage" xml:space="preserve">
    <value>锁定同步基元的实例；您是要改用 '{0}' 成员吗?</value>
  </data>
  <data name="DeclarationNullabilityInferred" xml:space="preserve">
    <value>推断声明为 null 性</value>
  </data>
  <data name="UseElsewhereMessage" xml:space="preserve">
    <value>使用{0}(其他地方)</value>
  </data>
  <data name="JoinNullCheckWithUsageSettingApplyStyleHeuristicsDescription" xml:space="preserve">
    <value>使用此选项，只有在更改不会影响可读性的情况下才会建议转换。例如，如果赋值目标是对多个变量求值的复杂表达式，它将禁止检查。</value>
  </data>
  <data name="ThenewConstraintCannotBeUsedWithThestructOrunmanagedConstraintMessage" xml:space="preserve">
    <value>'new()' 约束不能与 'struct' 或 'unmanaged' 约束一起使用</value>
  </data>
  <data name="ArgumentminIsAlwaysGreaterThanArgumentmaxMessage" xml:space="preserve">
    <value>实参 'min' 始终大于实参 'max'</value>
  </data>
  <data name="CompilerWarning_CS9209_Title" xml:space="preserve">
    <value>由于使用 '..' 展开运算符，集合表达式可能会导致意外堆分配</value>
  </data>
  <data name="NotResolvedParamsCollectionAddReferenceMessage" xml:space="preserve">
    <value>找不到 '{0}' 类型的任何 'Add' 方法来填充 'params' 集合</value>
  </data>
  <data name="EnumeratorObjectIsNotDisposedMessage" xml:space="preserve">
    <value>'GetEnumerator' 调用结果永远不会被处置</value>
  </data>
  <data name="CannotUseThisVersionOfImmutableArrayInCollectionExpression_Text" xml:space="preserve">
    <value>此版本的 '{0}' 不能与集合表达式一起使用，因为 'ImmutableCollectionsMarshal' 类中没有 'AsImmutableArray' 方法。请尝试使用更高版本的框架。</value>
  </data>
  <data name="RedundantArrayCreationExpressionMessage" xml:space="preserve">
    <value>冗余的数组创建表达式</value>
  </data>
  <data name="PossibleSystemArgumentOutOfRangeExceptionIndexMustBeANonNegativeIntegerMessage" xml:space="preserve">
    <value>可能为 '{0}'。索引必须为非负整数。</value>
  </data>
  <data name="CannotBeOfTypeMessage" xml:space="preserve">
    <value>{0}不能为 '{1}' 类型</value>
  </data>
  <data name="CompilerWarning_CS8776_Title" xml:space="preserve">
    <value>不能在此特性中使用此成员。</value>
  </data>
  <data name="StringLiteralValues_Caption" xml:space="preserve">
    <value>字符串字面量值</value>
  </data>
  <data name="InterceptorsFeatureNotEnabledMessage" xml:space="preserve">
    <value>未在此命名空间中启用 'interceptors' 功能。请将 '&lt;InterceptorsNamespaces&gt;$(InterceptorsNamespaces);{0}&lt;/InterceptorsNamespaces&gt;' 添加到您的项目。</value>
  </data>
  <data name="CompilerWarning_CS0472_Title" xml:space="preserve">
    <value>由于此类型的值永不等于 "null"，该表达式的结果始终相同</value>
  </data>
  <data name="StaticClassCannotHaveProtectedMembersMessage" xml:space="preserve">
    <value>static 类 '{0}' 不能有 protected 成员</value>
  </data>
  <data name="ConvertToExtensionBlockMessage" xml:space="preserve">
    <value>转换为扩展块</value>
  </data>
  <data name="BaseOfDiffersFromDeclaredInOtherPartsMessage" xml:space="preserve">
    <value>'{1}' 的基{0}与其他部分中声明的不同</value>
  </data>
  <data name="CannotUseACollectionOfdynamicTypeInAnawaitForeachMessage" xml:space="preserve">
    <value>不能在 'await foreach' 中使用 'dynamic' 类型集合</value>
  </data>
  <data name="CannotSpecifyreadonlyModifiersOnBothAccessorsOfInsteadPutAreadonlyModifierOnTheItselfMessage" xml:space="preserve">
    <value>不能在{0}的两个访问器上指定 'readonly' 修饰符。请改为在{1}上放置一个 'readonly' 修饰符。</value>
  </data>
  <data name="FunctionPointerSignatureExpected_ToolTip" xml:space="preserve">
    <value>应为函数指针签名</value>
  </data>
  <data name="CommentsLineComment_RiderPresentableName" xml:space="preserve">
    <value>注释//行注释</value>
  </data>
  <data name="CSharpFormatterHighlightingProvider_InternalConfigurableSeverityItems_Multiple_statements_on_one_line" xml:space="preserve">
    <value>一行有多条语句</value>
  </data>
  <data name="CannotBepartialMessage" xml:space="preserve">
    <value>{0}不能为 'partial'</value>
  </data>
  <data name="ThetypeofExpressionCannotBeUsedOnTheDynamicTypeMessage" xml:space="preserve">
    <value>'typeof' 表达式不能用于动态类型</value>
  </data>
  <data name="TheTargetRuntimeDoesntSupportExtensibleOrRuntimeEnvironmentDefaultCallingConventionsMessage" xml:space="preserve">
    <value>目标运行时不支持可扩展或运行时环境的默认调用惯例</value>
  </data>
  <data name="UseWithExpressionToCreateAModifiedInstanceOfARecord" xml:space="preserve">
    <value>使用 'with' 表达式创建记录的修改后实例</value>
  </data>
  <data name="CollectionExpressionRefStructSpreadMayAllocateMessage" xml:space="preserve">
    <value>由于使用 '..' 展开运算符，'{0}' 类型的集合表达式可能会导致意外堆分配。请考虑显式创建一个数组，然后转换为 '{0}' 以将该分配设为显式。</value>
  </data>
  <data name="NamespaceContainsNoDeclarationsMessage" xml:space="preserve">
    <value>命名空间 '{0}' 不含声明</value>
  </data>
  <data name="TheCanOnlyBeUsedInAMethodOrLambdaMarkedWithTheasyncModifierMessage" xml:space="preserve">
    <value>只能在使用 'async' 修饰符标记的方法或 lambda 中使用{0}</value>
  </data>
  <data name="ReplaceOrdinaryConstructorWithPrimaryConstructor" xml:space="preserve">
    <value>将普通构造函数替换为主构造函数</value>
  </data>
  <data name="AvoidUsingasyncsWithThevoidReturnTypeMessage" xml:space="preserve">
    <value>避免将 'async' 用于带有 'void' 返回值类型的{0}或捕获其中的所有异常: {0}未处理的任何异常都可能导致进程崩溃</value>
  </data>
  <data name="InvalidPreprocessorDirectiveMessage" xml:space="preserve">
    <value>预处理程序指令无效</value>
  </data>
  <data name="ApartialMemberCannotHaveabstractModifierMessage" xml:space="preserve">
    <value>'partial' 成员不能有 'abstract' 修饰符</value>
  </data>
  <data name="AnnotateWithAttributeMessage" xml:space="preserve">
    <value>使用 [{2}] 特性注解{0} '{1}'</value>
  </data>
  <data name="BadYieldInUnsafe_Text" xml:space="preserve">
    <value>不能在 'unsafe' 块中使用 'yield return'</value>
  </data>
  <data name="PossibleIncorrectImplementationOfDoubleCheckLockingCheckedFieldMustBeVolatileOrAssignedFromLocalVariableAfterThreadMemoryBarrierCall21" xml:space="preserve">
    <value>可能错误地实现了双重检查锁定。checked 字段必须为 volatile 或在 'Thread.MemoryBarrier()' 调用之后从局部变量中赋值。</value>
  </data>
  <data name="AppendToCollectionExpressionMessage" xml:space="preserve">
    <value>追加到集合表达式</value>
  </data>
  <data name="CqrsNamingRecommendationTakenMessage" xml:space="preserve">
    <value>'{0}' 不符合 CQRS 命名约定。建议的名称为 '{1}'，但该名称已存在。</value>
  </data>
  <data name="InvocationIsResolvedToMethodWithparamsButMoreSpecificMethodIsAvailableAndArgumentsPartiallyMatchIt" xml:space="preserve">
    <value>Invocation is resolved to method with 'params', but more specific method is available and arguments partially match it</value>
  </data>
  <data name="AttributesHaveToBeDeclaredInSeparateSectionsOrInASingleSections" xml:space="preserve">
    <value>必须在单独的部分或单个部分中声明特性</value>
  </data>
  <data name="NoBestTypeFoundForTheSwitchExpressionMessage" xml:space="preserve">
    <value>没有为 'switch' 表达式找到最佳类型</value>
  </data>
  <data name="RedundantSwitchExpressionArmMessage" xml:space="preserve">
    <value>冗余的 'switch' 表达式 arm</value>
  </data>
  <data name="CanSimplifyDictionaryTryGetValueWithGetValueOrDefaultMessage" xml:space="preserve">
    <value>可以使用 'GetValueOrDefault' 简化字典查找</value>
  </data>
  <data name="InterfaceIsMarkedAsServiceContractButDoesntContainAnyOperationContractsMessage" xml:space="preserve">
    <value>接口 '{0}' 被标记为 ServiceContract，但不包含任何运算协定</value>
  </data>
  <data name="CannotSpecifyAccessibilityModifiersForBothAccessorsOfTheMessage" xml:space="preserve">
    <value>不能为{0} '{1}' 的两个访问器指定可访问性修饰符</value>
  </data>
  <data name="EscapePartialAsAType_Text" xml:space="preserve">
    <value>'partial' 是返回值类型名称</value>
  </data>
  <data name="EnforceBracesInDoWhileStatement_Caption" xml:space="preserve">
    <value>在 'do-while' 语句中强制使用大括号</value>
  </data>
  <data name="CannotImplementBothAndBecauseTheyMayUnifyForSomeTypeParameterSubstitutionsMessage" xml:space="preserve">
    <value>{0} '{1}' 不能同时实现 '{2}' 和 '{3}'，因为它们对于某些类型形参替换可以进行统一</value>
  </data>
  <data name="IsNotAValidAttributeLocationForThisDeclarationAllAttributesInThisBlockWillBeIgnoredMessage" xml:space="preserve">
    <value>'{0}' 不是此声明的有效特性位置。将忽略此块中的所有特性。</value>
  </data>
  <data name="TryCatchAndTryFinallyStatementsCanBeMerged" xml:space="preserve">
    <value>可以合并 try-catch 和 try-finally 语句</value>
  </data>
  <data name="ScopedMismatchInParameterOfTargetDelegateMessage" xml:space="preserve">
    <value>形参 '{0}' 的 'scoped' 修饰符与目标 '{1}' 不匹配</value>
  </data>
  <data name="EmptyStatementIsRedundant8" xml:space="preserve">
    <value>空语句冗余</value>
  </data>
  <data name="TypeParameterConstraint_Text" xml:space="preserve">
    <value>类型形参约束</value>
  </data>
  <data name="TypesDelegate_RiderPresentableName" xml:space="preserve">
    <value>类型//委托</value>
  </data>
  <data name="CannotSpecifyDefaultParameterValueInConjunctionWithAttributes" xml:space="preserve">
    <value>不能同时指定默认参数值与 [{0}] 或 [{1}]</value>
  </data>
  <data name="AutoProperty_Text" xml:space="preserve">
    <value>自动属性</value>
  </data>
  <data name="AddParenthesesToAvoidNonObviousPrecedence" xml:space="preserve">
    <value>添加圆括号以避免不明显的优先级</value>
  </data>
  <data name="PreferRemovingRedundantCommasWhenThe_Caption" xml:space="preserve">
    <value>当最后一个元素后面没有新行时，首选移除冗余逗号</value>
  </data>
  <data name="TupleElementNameIsDisallowedAtAnyPositionMessage" xml:space="preserve">
    <value>任何位置都不允许使用元组元素名称“{0}”</value>
  </data>
  <data name="BracesAndOperatorsOperator_RiderPresentableName" xml:space="preserve">
    <value>大括号和运算符//运算符</value>
  </data>
  <data name="QueryInvasionTitle" xml:space="preserve">
    <value>CQRS 上下文交集。查询从“命令”上下文调用。</value>
  </data>
  <data name="BaseDestructorCannotBeCalledDirectlyMessage" xml:space="preserve">
    <value>请勿直接调用基类型 {0} 方法。它将从析构函数中自动调用。</value>
  </data>
  <data name="UseBracesToSeparatedoWhileStatementBody" xml:space="preserve">
    <value>使用大括号分隔 'do-while' 语句体</value>
  </data>
  <data name="OnlyOnePartOfApartialTypeCanDeclarePrimaryConstructorMessage" xml:space="preserve">
    <value>只有 'partial' 类型的一部分可以声明主构造函数</value>
  </data>
  <data name="MisplacedScopedKeywordMessage" xml:space="preserve">
    <value>意外的上下文关键字 'scoped'。您是指 'scoped ref' 还是 '@scoped'?</value>
  </data>
  <data name="FeatureIsNotAvailablePleaseUseLanguageVersionOrGreaterMessage" xml:space="preserve">
    <value>功能 '{0}' 不可用。请使用语言版本 3.0 或更高版本。</value>
  </data>
  <data name="ValueOfSomeContextTypeIsAlreadyProvided" xml:space="preserve">
    <value>已提供某些上下文类型的值</value>
  </data>
  <data name="AnonymousMethodSignatureIsNotNecessary" xml:space="preserve">
    <value>不需要匿名方法签名</value>
  </data>
  <data name="TheFirstOperandOfAnOverloadedShiftOperatorMustHaveTheSameTypeAsTheContainingTypeOrItsTypeParameterConstrainedToItMessage" xml:space="preserve">
    <value>重载的移位运算符的第一个操作数必须具有与包含类型或其约束的类型形参相同的类型</value>
  </data>
  <data name="DelegateConstructorIsInvokedWithArgumentSMessage" xml:space="preserve">
    <value>使用 {0} 个实参调用委托构造函数</value>
  </data>
  <data name="QueryInvasionMessage" xml:space="preserve">
    <value>CQRS 上下文交集。{0} 从“命令”上下文调用，但属于“查询”上下文。</value>
  </data>
  <data name="ConvertToMethodOrOperatorWithPreferredBodyStyle" xml:space="preserve">
    <value>转换为具有首选主体样式的方法或运算符</value>
  </data>
  <data name="ConditionalExpressionCanBeRewrittenAsNullCoalescingMessage" xml:space="preserve">
    <value>条件表达式可被重写为 null 合并</value>
  </data>
  <data name="BadNonVirtualInterfaceMemberAccessOnAllowsByRefLikeMessage" xml:space="preserve">
    <value>无法在允许 ref 结构的类型形参上访问非虚拟实例接口成员</value>
  </data>
  <data name="InvalidOperandForPatternMatchValueRequiredButFoundMessage" xml:space="preserve">
    <value>模式匹配的操作数无效: 需要一个值，但实际为 '{0}'</value>
  </data>
  <data name="AllPublicTypesShouldBelongToNamespacesWithACommonPrefixMessage" xml:space="preserve">
    <value>所有 public 类型都应属于具有共同前缀的命名空间</value>
  </data>
  <data name="MethodsAttributedWithUnmanagedCallersOnlyCannotHaveGenericTypeParametersAndCannotBeDeclaredInAGenericTypeMessage" xml:space="preserve">
    <value>具有 'UnmanagedCallersOnly' 特性的方法不能具有泛型类型形参，并且不能在泛型类型中声明</value>
  </data>
  <data name="SomeCasesAreNotProcessed_Text" xml:space="preserve">
    <value>一些 case 未处理:</value>
  </data>
  <data name="UseinheritdocOnRootLevelToInheritDocumentationFromBaseCandidateMessage" xml:space="preserve">
    <value>在根级别使用 &lt;inheritdoc /&gt; 可从基候选项继承文档</value>
  </data>
  <data name="Parameter_Text" xml:space="preserve">
    <value>参数</value>
  </data>
  <data name="ThisAsyncMethodLacksawaitOperatorsAndWillRunSynchronouslyConsiderUsingTheawaitOperatorToAwaitNonBlockingAPICallsOrawaitTaskRunToDoCPUBoundWorkOnABackgroundThreadMessage" xml:space="preserve">
    <value>此异步方法缺少 "await" 运算符，将以同步方式运行。请考虑使用 "await" 运算符等待非阻止的 API 调用，或者使用 "await Task.Run(...)" 在后台线程上执行占用大量 CPU 的工作。</value>
  </data>
  <data name="CannotTakeTheAddressOfAVariableOfAManagedTypeMessage" xml:space="preserve">
    <value>不能获取托管类型 '{0}' 的变量的地址</value>
  </data>
  <data name="ConditionalExpressionBranchesMismatchingRefEscapeScopeWarningMessage" xml:space="preserve">
    <value>ref 条件运算符的分支引用声明作用域不兼容的变量</value>
  </data>
  <data name="OverriddenGetHashCodeCallsBaseGetHashCodeMessage" xml:space="preserve">
    <value>被重写的 'GetHashCode()' 调用基 '{0}.GetHashCode()'</value>
  </data>
  <data name="CompilerWarning_CS2029_Title" xml:space="preserve">
    <value>预处理符号的名称无效；不是有效的标识符</value>
  </data>
  <data name="SwitchStatementForEnumValuesDoesNotHaveDefaultSection" xml:space="preserve">
    <value>枚举值的 switch 语句没有 default 部分</value>
  </data>
  <data name="CollectionInitializerElementCannotBeAssignmentExpressionMessage" xml:space="preserve">
    <value>集合初始值设定项元素不能为赋值表达式</value>
  </data>
  <data name="ConvertIfDeclarationIsOfBuiltInType_Text" xml:space="preserve">
    <value>如果声明为内置类型(例如字符串)，则转换</value>
  </data>
  <data name="ReplaceAsyncWithTaskReturn" xml:space="preserve">
    <value>将 'async' 代码替换为 'Task' 返回</value>
  </data>
  <data name="PropertiesAndVariablesField_RiderPresentableName" xml:space="preserve">
    <value>属性和变量//字段</value>
  </data>
  <data name="DuplicateReferenceTypeConstraintMessage" xml:space="preserve">
    <value>重复的引用类型约束</value>
  </data>
  <data name="ParameterHidesPrimaryConstructorParameterTitle" xml:space="preserve">
    <value>形参隐藏主构造函数形参</value>
  </data>
  <data name="CompilerWarning_CS0811_Title" xml:space="preserve">
    <value>完全限定名对于调试信息太长</value>
  </data>
  <data name="CollectionExpressionTargetWithoutIterationType_Text" xml:space="preserve">
    <value>集合表达式目标类型 '{0}' 没有迭代类型</value>
  </data>
  <data name="AbstractInNonAbstractMessage" xml:space="preserve">
    <value>abstract {0}位于非 abstract {1}中</value>
  </data>
  <data name="OperatorReturnType_Text" xml:space="preserve">
    <value>运算符返回值类型</value>
  </data>
  <data name="PreferUsingNamedPositionalArgumentWhenAnonymousFunctionLambdaOrDelegateIsPassed" xml:space="preserve">
    <value>传递匿名函数(lambda 或委托)时，首选使用命名/位置实参</value>
  </data>
  <data name="UseCollectionInitializerMessage" xml:space="preserve">
    <value>使用集合初始值设定项</value>
  </data>
  <data name="NullabilityOfReferenceTypesInReturnTypeDoesntMatchImplicitlyImplementedMemberMessage" xml:space="preserve">
    <value>返回值类型中引用类型的为 null 性与隐式实现的成员 '{0}' 不匹配</value>
  </data>
  <data name="CannotImplementADynamicInterfaceMessage" xml:space="preserve">
    <value>不能实现动态接口 '{0}'</value>
  </data>
  <data name="AnExpressionTreeCannotContainAnAssignmentOperatorMessage" xml:space="preserve">
    <value>表达式树不能包含赋值运算符</value>
  </data>
  <data name="CannotDeclareNewVirtualInSealedMessage" xml:space="preserve">
    <value>不能在 sealed {2} '{3}' 中声明新的 virtual {0} '{1}'</value>
  </data>
  <data name="CodeCleanupTask_ArrangeVarStyle" xml:space="preserve">
    <value>应用 'var' 样式</value>
  </data>
  <data name="PrimaryConstructorParameterCaptureDisallowedMessage" xml:space="preserve">
    <value>不允许捕获主构造函数形参，请改用显式字段</value>
  </data>
  <data name="CannotInvokeConstructorOnInterfaceMessage" xml:space="preserve">
    <value>不能在接口上调用构造函数</value>
  </data>
  <data name="BaseTypeIsAlreadySpecifiedInOtherPartsMessage" xml:space="preserve">
    <value>基类型 '{0}' 已在其他部分中指定</value>
  </data>
  <data name="TypeMemberModifiersCodeStyleRule_TitleCaption" xml:space="preserve">
    <value>对类型成员使用显式或隐式修饰符定义</value>
  </data>
  <data name="ReferenceIsMethodGroup_Text" xml:space="preserve">
    <value>引用 '{0}' 是“方法组”。</value>
  </data>
  <data name="CannotBeSealedMessage" xml:space="preserve">
    <value>{0}不能为 sealed</value>
  </data>
  <data name="RefFieldCannotReferToRefStructMessage" xml:space="preserve">
    <value>'ref' 字段不能引用 'ref' 结构</value>
  </data>
  <data name="BecauseResultOfAsynchronousIteratorCallIsNotBeingIteratedExecutionOfTheCurrentMethodContinuesBeforeTheCallIsCompletedConsiderUsingTheawaitForeachOverTheResultOfTheCallMessage" xml:space="preserve">
    <value>由于异步迭代器调用的结果未循环访问，当前方法会在调用完成之前继续执行。请考虑在调用结果上使用 'await foreach'。</value>
  </data>
  <data name="IntroducingAFinalizeMethodCanInterfereWithDestructorInvocationDidYouIntendToDeclareADestructorMessage" xml:space="preserve">
    <value>引入 "Finalize" 方法会妨碍析构函数调用。是否希望声明析构函数?</value>
  </data>
  <data name="BuiltInTypeReferenceCodeStyleRule_TitleCaption" xml:space="preserve">
    <value>将内置类型引用替换为 CLR 类型名称或关键字</value>
  </data>
  <data name="TheSourceExpressionAlwaysMatchesTheProvidedPatternMessage" xml:space="preserve">
    <value>源表达式始终与提供的模式匹配</value>
  </data>
  <data name="StyleCopAnalyzersDefault_Text" xml:space="preserve">
    <value>StyleCopAnalyzers 默认值</value>
  </data>
  <data name="ReadonlyReferenceFieldCannotBeAssignedToMessage" xml:space="preserve">
    <value>不能给字段 '{0}' 赋值，因为它是只读引用</value>
  </data>
  <data name="CannotAccessHereDueItsProtectionLevelMessage" xml:space="preserve">
    <value>由于{0} '{1}' 的保护级别，不能在此对其进行访问</value>
  </data>
  <data name="CatchClausesCannotFollowTheGeneralCatchClauseOfATryStatementMessage" xml:space="preserve">
    <value>catch 子句不能跟在 try 语句的常规 catch 子句之后</value>
  </data>
  <data name="OnMethodGroupsCannotBeUsedInExpressionTreesMessage" xml:space="preserve">
    <value>不可在表达式树中使用方法组上的 "&amp;"</value>
  </data>
  <data name="CodeCleanupTask_ArrangeTrailingCommas" xml:space="preserve">
    <value>排列尾随逗号</value>
  </data>
  <data name="MissingConfigureAwaitFalseInLibraryCodeMessage" xml:space="preserve">
    <value>库代码中缺少 '.ConfigureAwait(false)'</value>
  </data>
  <data name="CompilerWarning_CS1956_Title" xml:space="preserve">
    <value>成员在运行时使用多个匹配项实现接口成员</value>
  </data>
  <data name="OutputSafe_Text" xml:space="preserve">
    <value>输出安全</value>
  </data>
  <data name="NullableValueTypeMayBeNullMessage" xml:space="preserve">
    <value>可以为 null 的值类型可以为 null</value>
  </data>
  <data name="WinRTOverrideMethodShouldBeSealedMessage" xml:space="preserve">
    <value>WinRT 重写方法应为 sealed</value>
  </data>
  <data name="CompilerWarning_CS3019_Title" xml:space="preserve">
    <value>CLS 遵从性检查在此程序集外部不可见，因此不会执行它</value>
  </data>
  <data name="OperatorCannotHaverefOroutParameterMessage" xml:space="preserve">
    <value>运算符不能有 'ref' 或 'out' 形参</value>
  </data>
  <data name="AnExpressionOfTypeCannotBeHandledByAPatternOfTypeMessage" xml:space="preserve">
    <value>“{0}”类型的模式无法处理“{1}”类型的表达式。</value>
  </data>
  <data name="SeparateLocalFunctionsWithJumpStatementTitle" xml:space="preserve">
    <value>在局部函数之前添加显式 'return' 或 'continue'</value>
  </data>
  <data name="UseCollectionExpressionSyntax" xml:space="preserve">
    <value>使用集合表达式语法</value>
  </data>
  <data name="MustHaveInitToMatchOverriddenMessage" xml:space="preserve">
    <value>'{0}' 必须具有 'init' 访问器而不是 'set' 才能匹配被重写的{1} '{2}'</value>
  </data>
  <data name="CompilerWarning_CS4025_Title" xml:space="preserve">
    <value>CallerFilePathAttribute 将不起作用，因为它应用到的成员在不允许使用可选参数的上下文中使用</value>
  </data>
  <data name="ReplaceSequenceEqualWithConstantPatternMessage" xml:space="preserve">
    <value>将 'SequenceEqual' 替换为常量模式</value>
  </data>
  <data name="TupleMustContainAtLeastTwoElementsMessage" xml:space="preserve">
    <value>元组必须包含至少两个元素</value>
  </data>
  <data name="SimplifyStatement" xml:space="preserve">
    <value>简化语句</value>
  </data>
  <data name="CompilerWarning_CS9088_Title" xml:space="preserve">
    <value>这会按引用返回一个参数，但它的作用域为当前方法</value>
  </data>
  <data name="AswitchExpressionMustBeABoolCharStringIntegralEnumOrCorrespondingNullableTypeMessage" xml:space="preserve">
    <value>'switch' 表达式必须为布尔、字符、字符串、整型、枚举或相应的可以为 null 的类型</value>
  </data>
  <data name="Use_Method_Text" xml:space="preserve">
    <value>请使用 '{0}' 方法</value>
  </data>
  <data name="CompilerWarning_CS1592_Title" xml:space="preserve">
    <value>所包含的注释文件中有格式错误的 XML</value>
  </data>
  <data name="MathSignMethodAlwaysGivesTheSameResult" xml:space="preserve">
    <value>Math.Sign() 方法始终给出相同的结果</value>
  </data>
  <data name="ConvertDelegateVariableToLocalFunction" xml:space="preserve">
    <value>将委托变量转换为局部函数</value>
  </data>
  <data name="AmbiguousConstructorReference_Text" xml:space="preserve">
    <value>构造函数引用</value>
  </data>
  <data name="ConvertTheFollowingCodepreIfConditionReturnExprReturnExprPreTopreReturnConditionExprExprPre" xml:space="preserve">
    <value>将以下代码:
&lt;pre&gt;
  if (condition) return expr1;
  return expr2;
&lt;/pre&gt;
转换为:
&lt;pre&gt;
  return condition ? expr1 : expr2;
&lt;/pre&gt;</value>
  </data>
  <data name="ChainingToSetsRequiredMembersRequiresSetsRequiredMembersMessage" xml:space="preserve">
    <value>此构造函数必须添加 'SetsRequiredMembers'，因为它链接到具有该特性的构造函数</value>
  </data>
  <data name="AbstractEventCannotHaveAddOrRemoveAccessorsMessage" xml:space="preserve">
    <value>abstract 事件不能有 add 或 remove 访问器</value>
  </data>
  <data name="PreprocessorKeyword_RiderPresentableName" xml:space="preserve">
    <value>预处理程序//关键字</value>
  </data>
  <data name="UsingDirectivesFrom__Text" xml:space="preserve">
    <value>来自 '{0}' 的 using 指令</value>
  </data>
  <data name="CannotApplyOperatorToOperandsOfTypeAndMessage" xml:space="preserve">
    <value>不能将运算符 '{0}' 应用于 '{1}' 和 '{2}' 类型的操作数</value>
  </data>
  <data name="MergeSequentialChecksSettingApplyStyleHeuristicsTitle" xml:space="preserve">
    <value>应用代码样式启发</value>
  </data>
  <data name="RecordMemberMustBeMessage" xml:space="preserve">
    <value>记录成员 '{0}' 必须为 {1}</value>
  </data>
  <data name="EntityFramework_NavigationPropertyInitializationHighlighting_ToolTip_Text" xml:space="preserve">
    <value>初始化属性以避免可能的运行时错误</value>
  </data>
  <data name="RedundantisMessage" xml:space="preserve">
    <value>冗余的 'is'</value>
  </data>
  <data name="DuplicateParameterModifierModeMessage" xml:space="preserve">
    <value>形参修饰符 '{0}' 不能与 '{1}' 一起使用</value>
  </data>
  <data name="UnusedNullableDirectiveMessage" xml:space="preserve">
    <value>未使用的可以为 null 的指令</value>
  </data>
  <data name="partialMemberDeclarationsMustBeEitherBothOrNeitherreadonlyMessage" xml:space="preserve">
    <value>'partial' 成员声明必须两个都为 'readonly' 或都不为 'readonly'</value>
  </data>
  <data name="ConditionalAccessQualifierExpressionIsNotNullAccordingToNullableReferenceTypesAnnotations" xml:space="preserve">
    <value>根据可以为 null 的引用类型的注解，条件访问限定符表达式不为 null</value>
  </data>
  <data name="UserDefinedConversionToInterfaceMessage" xml:space="preserve">
    <value>到接口的用户定义转换</value>
  </data>
  <data name="PossibleIncorrectAssignmentToLocalUnderUsingOrLock" xml:space="preserve">
    <value>对{0} '{1}' (为 'using' 或 'lock' 语句的实参)的赋值可能不正确。'Dispose' 方法调用或解锁将发生在局部的原始值上。</value>
  </data>
  <data name="CannotDeclareNewProtectedInStructMessage" xml:space="preserve">
    <value>不能在结构 '{2}' 中声明新的 protected {0} '{1}'</value>
  </data>
  <data name="ObjectCreatedBynewExpressionIsPossiblyNotAssignedAnywhere" xml:space="preserve">
    <value>可能未在任何位置给 'new' 表达式创建的对象赋值</value>
  </data>
  <data name="CannotBevolatileMessage" xml:space="preserve">
    <value>{0}不能为 'volatile'</value>
  </data>
  <data name="UserDefinedConversionFromInterfaceMessage" xml:space="preserve">
    <value>从接口的用户定义转换</value>
  </data>
  <data name="CompilerWarning_CS9082_Title" xml:space="preserve">
    <value>将按引用返回本地，但它已初始化为无法按引用返回的值</value>
  </data>
  <data name="EnforceBracesInlockStatement" xml:space="preserve">
    <value>在 'lock' 语句中强制使用大括号</value>
  </data>
  <data name="ComparisonToIntegralConstantIsUselessTheConstantIsOutsideTheRangeOfTargetType" xml:space="preserve">
    <value>与整型常量进行比较没有意义；常量超出目标类型的范围</value>
  </data>
  <data name="CannotModifyStructMemberWhenAccessedStructIsNotClassifiedAsAVariableMessage" xml:space="preserve">
    <value>{0}访问的结构未被分类为变量时不能修改结构成员</value>
  </data>
  <data name="CannotUsePrimaryConstructorParameterInThisContextMessage" xml:space="preserve">
    <value>无法在此上下文中使用主构造函数参数“{0}”</value>
  </data>
  <data name="CannotReturnAMemberOfByReferenceBecauseItIsNotArefVariableMessage" xml:space="preserve">
    <value>不能通过引用返回{0} '{1}' 的成员，因为它不是 'ref' 变量</value>
  </data>
  <data name="RedundantobjectToStringCallForValueTypes" xml:space="preserve">
    <value>值类型的冗余 'object.ToString()' 调用</value>
  </data>
  <data name="NonStaticLoggerTemplate_Message" xml:space="preserve">
    <value>在对 '{0}' 的调用之间，日志记录消息模板不应变化</value>
  </data>
  <data name="CannotAccessHereMessage1" xml:space="preserve">
    <value>不能在此处访问{0}{1} '{2}'</value>
  </data>
  <data name="CannotAccessHereMessage2" xml:space="preserve">
    <value>不能在此处访问{0}{1} '{2}'</value>
  </data>
  <data name="NullableAttributeHasNoEffectAndCanBeSafelyRemovedThisCanBeCausedByTheTargetElementAlreadyHavingTheDesiredNullableAnnotation" xml:space="preserve">
    <value>可以为 null 的特性不起任何作用，可以安全地移除。这可能是因为目标元素已具有所需的可以为 null 的注解。</value>
  </data>
  <data name="AssignmentExpressionInsideMemberInitializerValueLooksSuspiciousCommaIsProbablyMissing" xml:space="preserve">
    <value>成员初始值设定项值中的赋值表达式看上去可疑。可能缺少逗号。</value>
  </data>
  <data name="ScopedDiscardMessage" xml:space="preserve">
    <value>'scoped' 修饰符不能与弃元一起使用</value>
  </data>
  <data name="MathSignMethodInvocationCanBeReplacedWithAConstant" xml:space="preserve">
    <value>Math.Sign() 方法调用可被替换为常量</value>
  </data>
  <data name="TypeIsNotAwaitableMessage" xml:space="preserve">
    <value>类型 '{0}' 不可等待</value>
  </data>
  <data name="WhenTypeIsNotEvident_Caption" xml:space="preserve">
    <value>当类型不明显时</value>
  </data>
  <data name="UseBracesToSeparateForeachStatement_Text" xml:space="preserve">
    <value>使用大括号分隔 'foreach' 语句体</value>
  </data>
  <data name="CodeStylesCleanupModule_ModuleActionName_Applying_syntax_style" xml:space="preserve">
    <value>应用语法样式</value>
  </data>
  <data name="Modifiers_Text" xml:space="preserve">
    <value>修饰符</value>
  </data>
  <data name="ReplaceAsyncWithTaskReturnMessage" xml:space="preserve">
    <value>将 'async' {0}替换为 '{1}' 值返回</value>
  </data>
  <data name="CanOnlyUseArrayInitializerExpressionsToAssignToArrayTypesTryUsingANewExpressionInsteadMessage" xml:space="preserve">
    <value>只能使用数组初始值设定项表达式分配数组类型。请尝试改用新的表达式。</value>
  </data>
  <data name="ParenthesesCanBeSafelyRemovedFromExpressionsWithoutChangingCodeSemantics" xml:space="preserve">
    <value>可以安全地从表达式中移除圆括号而不更改代码语义</value>
  </data>
  <data name="EnumeratorObjectIsNotDisposedConsiderSafeCastMessage" xml:space="preserve">
    <value>'GetEnumerator' 调用结果永远不会被处置；请考虑在枚举后安全转换为 IDisposable 和 Dispose() 调用</value>
  </data>
  <data name="PossibleUnassignedObjectCreatedBynewExpressionMessage" xml:space="preserve">
    <value>由 'new' 表达式创建的可能未赋值的对象</value>
  </data>
  <data name="DontProvideGenericArgumentsWhenTakingMethodNamesMessage" xml:space="preserve">
    <value>请勿在获取方法命名时提供泛型实参</value>
  </data>
  <data name="CannotUseLocalVariableInThisContextBecauseItMayExposeReferencedVariablesOutsideOfTheirDeclarationScopeMessage" xml:space="preserve">
    <value>不能在此上下文中使用{0} '{1}'，因为它可能会在声明作用域以外公开引用的变量</value>
  </data>
  <data name="TheExpressionMustBeOfTypeToMatchTheAlternativerefOperandMessage" xml:space="preserve">
    <value>表达式必须为 '{0}' 类型以与替代 'ref' 操作数匹配</value>
  </data>
  <data name="IncorrectConstantExpectedAnnotation_Message" xml:space="preserve">
    <value>{1} 类型不支持 {0} 特性</value>
  </data>
  <data name="RefReturnScopedParameterMemberWarningMessage" xml:space="preserve">
    <value>这会通过引用返回作用域仅限于当前方法的{0} '{1}' 的成员</value>
  </data>
  <data name="CannotApplyOperatorToOperandOfTypeCandidatesAreMessage" xml:space="preserve">
    <value>不能将运算符 '{0}' 应用于 '{1}' 类型的操作数。{2}候选项为: {3}</value>
  </data>
  <data name="TheTupleElementNamesInTheSignatureOf_Text" xml:space="preserve">
    <value>{0} '{1}' 的签名中的元组元素名称必须与接口{2} '{3}' 的元组元素名称(包括返回类型)匹配。</value>
  </data>
  <data name="ConversionFromBaseClassMessage" xml:space="preserve">
    <value>从基类转换</value>
  </data>
  <data name="MembersMustHaveWhenExitingMessage" xml:space="preserve">
    <value>退出时成员 {0} 必须具有非 null 值</value>
  </data>
  <data name="ACatchClauseThatCatchesSystemExceptionAndHasAnEmptyBody" xml:space="preserve">
    <value>捕获 System.Exception 并具有空体的 catch 子句</value>
  </data>
  <data name="AddOrRemoveExplicitTypeSpecificationInDefaultValueExpressionWhenTypeIsNotEvidentFromTheUsage" xml:space="preserve">
    <value>在无法从用法明显看出类型时，在默认值表达式中添加或移除显式类型规范</value>
  </data>
  <data name="trueIsRedundantAsforStatementConditionAndThusCanSafelyBeOmitted" xml:space="preserve">
    <value>'true' 作为 'for' 语句条件冗余，可以安全地将其省略</value>
  </data>
  <data name="CannotConvertTypeToViaABuiltInConversionMessage" xml:space="preserve">
    <value>不能通过内置转换将 '{0}' 类型转换为 '{1}'</value>
  </data>
  <data name="ObjectPatternNotPerformingAnyChecksCanBeReplacedWithVarPatternMessage" xml:space="preserve">
    <value>未执行任何检查的对象模式可被替换为 '{0}' 模式</value>
  </data>
  <data name="RefReturnCapturesLocalEntityWarningMessage" xml:space="preserve">
    <value>局部 '{0}' 通过引用返回，但已被初始化为不能通过引用返回的值</value>
  </data>
  <data name="ConvertToExpressionMessage1" xml:space="preserve">
    <value>转换为 '??' 表达式</value>
  </data>
  <data name="ConvertToExpressionMessage2" xml:space="preserve">
    <value>转换为 '??' 表达式</value>
  </data>
  <data name="ConvertToExpressionMessage3" xml:space="preserve">
    <value>转换为 '??' 表达式</value>
  </data>
  <data name="ConvertToExpressionMessage4" xml:space="preserve">
    <value>转换为 '?:' 表达式</value>
  </data>
  <data name="MemberMustHaveWhenExitingWithMessage" xml:space="preserve">
    <value>以 '{1}' 退出时成员 {0} 必须具有非 null 值</value>
  </data>
  <data name="RedundantEmptyObjectOrCollectionInitializer" xml:space="preserve">
    <value>冗余的空对象或集合初始值设定项</value>
  </data>
  <data name="CompilerWarning_CS9094_Title" xml:space="preserve">
    <value>这将通过 ref 参数按引用返回参数；但它只能在 return 语句中安全返回</value>
  </data>
  <data name="And_More_Text" xml:space="preserve">
    <value>…和其他 {0} 个</value>
  </data>
  <data name="BracesAndOperatorsParentheses_RiderPresentableName" xml:space="preserve">
    <value>大括号和运算符//圆括号</value>
  </data>
  <data name="InEveryExecutionPathWhichIsUselessMessage" xml:space="preserve">
    <value>在每个执行路径中{0}，但它没有意义</value>
  </data>
  <data name="CompilerWarning_CS9081_Title" xml:space="preserve">
    <value>此上下文中此类型 stackalloc 表达式的结果可能会在包含方法之外公开</value>
  </data>
  <data name="IsOfTypeADefaultParameterValueOfAReferenceTypeOtherThanStringCanOnlyBeInitializedWithNullMessage" xml:space="preserve">
    <value>'{0}' 为 '{1}' 类型。字符串以外的引用类型的默认形参值只能用 null 初始化。</value>
  </data>
  <data name="ImplicitlyTypedLocalVariableInitializerMustBeAnExpressionMessage" xml:space="preserve">
    <value>隐式类型化局部变量初始值设定项必须为表达式</value>
  </data>
  <data name="ArefOroutParameterCannotHaveADefaultValueMessage" xml:space="preserve">
    <value>'ref' 或 'out' 形参不能具有默认值</value>
  </data>
  <data name="DisposeOnUsingVariableTitle" xml:space="preserve">
    <value>处置 'using' 语句已捕获的变量</value>
  </data>
  <data name="BothPartialMemberDeclarationsMustHaveIdenticalAccessibilityModifiersMessage" xml:space="preserve">
    <value>两个分部成员声明必须具有相同的可访问性修饰符</value>
  </data>
  <data name="ALambdaExpressionWithAStatementBodyCannotBeConvertedToAnExpressionTreeMessage" xml:space="preserve">
    <value>具有语句体的 lambda 表达式不能转换为表达式树</value>
  </data>
  <data name="RecordMemberMustBeAReadableInstancePropertyOfTypeToMatchPositionalParameterMessage" xml:space="preserve">
    <value>记录成员 '{0}' 必须为 '{1}' 类型的可读实例属性以匹配位置形参 '{2}'</value>
  </data>
  <data name="LoopControlVariableIsNeverChangedInsideLoop29" xml:space="preserve">
    <value>循环控制变量在循环内从未更改过</value>
  </data>
  <data name="CSharpFormatterHighlightingProvider_InternalConfigurableSeverityItems_Blank_lines_are_redundant_elsewhere" xml:space="preserve">
    <value>其他位置空行冗余</value>
  </data>
  <data name="VariableInLocalFunctionHidesVariableFromOuterScope" xml:space="preserve">
    <value>局部函数中的变量会隐藏外部作用域内的变量</value>
  </data>
  <data name="CannotBeBothExternAndAbstractMessage" xml:space="preserve">
    <value>{0} '{1}' 不能为 extern 和 abstract</value>
  </data>
  <data name="RedundantLambdaSignatureParentheses" xml:space="preserve">
    <value>冗余的 lambda 签名圆括号</value>
  </data>
  <data name="ItIsNotLegalToUseNullableReferenceTypeInAnAsExpressionUseTheUnderlyingTypeInsteadMessage" xml:space="preserve">
    <value>在 as 表达式中使用可以为 null 的引用类型 '{0}' 不合法；请改用基础类型 '{1}'</value>
  </data>
  <data name="DoNotRemoveRedundantBraces_Caption" xml:space="preserve">
    <value>不移除冗余的名称</value>
  </data>
  <data name="OutVariableAndPatternVariableDeclarationsAreNotAllowedWithinAQueryClauseConstructorInitializerOrFieldEventPropertyInitializerMessage" xml:space="preserve">
    <value>查询子句、构造函数初始值设定项或字段/事件/属性初始值设定项中不允许使用 out 变量和模式变量声明</value>
  </data>
  <data name="sealedOrprivateInInterfaceMustDeclareABodyMessage" xml:space="preserve">
    <value>接口中的 'sealed' 或 'private' {0}必须声明主体</value>
  </data>
  <data name="CompilerWarning_CS8960_Title" xml:space="preserve">
    <value>CallerArgumentExpressionAttribute 将不起任何作用；它由 CallerLineNumberAttribute 替代</value>
  </data>
  <data name="UsageOfDefaultStructEquality_CheckNonUserTypes_Description" xml:space="preserve">
    <value>检查不属于解决方案的结构类型的相等性用法</value>
  </data>
  <data name="IgnoredDirectiveAfterIfDirectiveMessage" xml:space="preserve">
    <value>'#{0}' 指令前不允许 '#if' 指令</value>
  </data>
  <data name="SuggestCollectionExpressionWithSingleSpreadDescription" xml:space="preserve">
    <value>建议使用另一个集合 '[..anotherCollection]' 的单个传播元素转换为集合表达式。</value>
  </data>
  <data name="StaticFieldAutoPropertyEventInitializerRefersToStaticFieldAutoPropertyEventBelowOrInOtherPart" xml:space="preserve">
    <value>static 字段/自动属性/事件初始值设定项引用下面或另一部分中的 static 字段/自动属性/事件</value>
  </data>
  <data name="VariableCanBeDeclaredAsNonNullable" xml:space="preserve">
    <value>变量可被声明为不可以为 null 的</value>
  </data>
  <data name="JoinLocalVariableDeclarationAndAssignment" xml:space="preserve">
    <value>联接局部变量声明和赋值</value>
  </data>
  <data name="UsePositionalDeconstructionPatternMessage" xml:space="preserve">
    <value>使用位置析构模式</value>
  </data>
  <data name="UseWithExpressionToCreateAModifiedInstanceOfAStruct" xml:space="preserve">
    <value>使用 'with' 表达式创建结构的修改后实例</value>
  </data>
  <data name="CompilerWarning_CS1058_Title" xml:space="preserve">
    <value>上一个 catch 子句已经捕获了所有异常</value>
  </data>
  <data name="CompilerWarning_CS1570_Title" xml:space="preserve">
    <value>XML 注释出现 XML 格式错误</value>
  </data>
  <data name="CompilerWarning_CS8631_Title" xml:space="preserve">
    <value>类型不能用作泛型类型或方法中的类型参数。类型参数的为 Null 性与约束类型不匹配。</value>
  </data>
  <data name="ConfigureAwaitAnalysisDescription_Text" xml:space="preserve">
    <value>为当前项目启用或禁用 'ConfigureAwait' 分析</value>
  </data>
  <data name="CallTobaseEqualsIsReferenceEqualityMessage" xml:space="preserve">
    <value>对 'base.Equals(...)' 的调用是引用相等</value>
  </data>
  <data name="ThetypeofExpressionCannotBeUsedOnNullableReferenceTypesMessage" xml:space="preserve">
    <value>'typeof' 表达式不能用于可以为 null 的引用类型</value>
  </data>
  <data name="CompilerWarning_CS8907_Title" xml:space="preserve">
    <value>参数未读。是否忘记通过它来使用该名称初始化属性?</value>
  </data>
  <data name="CanSimplifyDictionaryLookupWithTryAddDescription" xml:space="preserve">
    <value>可以使用 'TryAdd' 简化字典查找</value>
  </data>
  <data name="RedundantMemberOverride" xml:space="preserve">
    <value>冗余的成员重写</value>
  </data>
  <data name="CannotConvertnullToTypeParameterBecauseItCouldBeAValueTypeConsiderUsingdefaultTInsteadMessage3" xml:space="preserve">
    <value>不能将 'null' 转换为类型形参 '{0}'，因为它可能是值类型。请考虑改用 'default(T)'。</value>
  </data>
  <data name="BaseInterfaceIsRedundantBecauseImplementsMessage" xml:space="preserve">
    <value>基接口 '{0}' 冗余，因为{1}实现 '{2}'</value>
  </data>
  <data name="RedundantExplicitPropertyNameMessage" xml:space="preserve">
    <value>冗余的显式属性名称</value>
  </data>
  <data name="PossiblyUnintendedLinearSearchInSetMessage" xml:space="preserve">
    <value>集合中可能出现非有意的线性搜索</value>
  </data>
  <data name="ValueOfABooleanExpressionIsAlwaysTheSameAtThisPoint" xml:space="preserve">
    <value>此时，布尔表达式的值始终相同</value>
  </data>
  <data name="ReplaceStringLiteralWithStaticallyTypedNameofExpression" xml:space="preserve">
    <value>将字符串字面量替换为静态类型化 'nameof' 表达式</value>
  </data>
  <data name="AnExpressionOfTypeCannotBeUsedAsAConstituentValueOfADynamicallyBoundOperationMessage" xml:space="preserve">
    <value>'{0}' 类型的表达式不能用作动态绑定运算的组成值</value>
  </data>
  <data name="CodeCleanupTask_ArrangeTypeAccessModifier" xml:space="preserve">
    <value>对类型使用显式或隐式修饰符定义</value>
  </data>
  <data name="ConvertIfStatementToSwitchExpression" xml:space="preserve">
    <value>将 'if' 语句转换为 'switch' 表达式</value>
  </data>
  <data name="CompilerWarning_CS0652_Title" xml:space="preserve">
    <value>与整数常量比较无意义；该常量不在类型的范围之内</value>
  </data>
  <data name="StaticAfterUnsafeInUsingDirectiveMessage" xml:space="preserve">
    <value>'static' 修饰符必须位于 'unsafe' 修饰符之前</value>
  </data>
  <data name="EnumsCannotHaveTypeParametersMessage" xml:space="preserve">
    <value>枚举不能有类型形参</value>
  </data>
  <data name="RedundantExplicitCollectionCreationInArgumentOfParamsParameterMessage" xml:space="preserve">
    <value>'params' 形参的实参中存在冗余的显式集合创建</value>
  </data>
  <data name="UsePreferredBodyStyle" xml:space="preserve">
    <value>使用首选主体样式</value>
  </data>
  <data name="EmptyGeneralCatchClauseSuppressesAnyErrorsMessage" xml:space="preserve">
    <value>空常规 catch 子句会禁止任何错误</value>
  </data>
  <data name="RedundantEmptyObjectOrCollectionInitializer10" xml:space="preserve">
    <value>冗余的空对象或集合初始值设定项</value>
  </data>
  <data name="ThePositionalMemberFoundCorrespondingToThisParameterIsHiddenMessage" xml:space="preserve">
    <value>与此形参对应的位置成员 '{0}' 已被隐藏</value>
  </data>
  <data name="ProgramUsingTopLevelStatementsMustBeAnExecutableMessage" xml:space="preserve">
    <value>使用顶级语句的程序必须是可执行文件</value>
  </data>
  <data name="ParameterMustBeDeclaredAsMessage" xml:space="preserve">
    <value>形参 '{0}' 必须被声明为 '{1}'</value>
  </data>
  <data name="PossibleUnintendedReferenceComparisonToGetAValueComparisonCastTheHandSideToTypeMessage" xml:space="preserve">
    <value>可能非有意的引用比较。要获得值比较，请将{0}侧转换为类型 '{1}'。</value>
  </data>
  <data name="CodeCleanupTask_ArrangeObjectCreation" xml:space="preserve">
    <value>应用对象创建样式('new()' 与 'new T()')</value>
  </data>
  <data name="FeatureIsNotAvailablePleaseUseLanguageVersionOrGreaterMessage17" xml:space="preserve">
    <value>功能 '{0}' 不可用。请使用语言版本 9.0 或更高版本。</value>
  </data>
  <data name="FeatureIsNotAvailablePleaseUseLanguageVersionOrGreaterMessage16" xml:space="preserve">
    <value>功能 '{0}' 不可用。请使用语言版本 8.0 或更高版本。</value>
  </data>
  <data name="FeatureIsNotAvailablePleaseUseLanguageVersionOrGreaterMessage15" xml:space="preserve">
    <value>功能 '{0}' 不可用。请使用语言版本 8.0 或更高版本。</value>
  </data>
  <data name="FeatureIsNotAvailablePleaseUseLanguageVersionOrGreaterMessage14" xml:space="preserve">
    <value>功能 '{0}' 不可用。请使用语言版本 7.3 或更高版本。</value>
  </data>
  <data name="FeatureIsNotAvailablePleaseUseLanguageVersionOrGreaterMessage13" xml:space="preserve">
    <value>功能 '{0}' 不可用。请使用语言版本 7.2 或更高版本。</value>
  </data>
  <data name="FeatureIsNotAvailablePleaseUseLanguageVersionOrGreaterMessage12" xml:space="preserve">
    <value>功能 '{0}' 不可用。请使用语言版本 7.1 或更高版本。</value>
  </data>
  <data name="FeatureIsNotAvailablePleaseUseLanguageVersionOrGreaterMessage11" xml:space="preserve">
    <value>功能 '{0}' 不可用。请使用语言版本 7.0 或更高版本。</value>
  </data>
  <data name="FeatureIsNotAvailablePleaseUseLanguageVersionOrGreaterMessage10" xml:space="preserve">
    <value>功能 '{0}' 不可用。请使用语言版本 6.0 或更高版本。</value>
  </data>
  <data name="FeatureIsNotAvailablePleaseUseLanguageVersionOrGreaterMessage18" xml:space="preserve">
    <value>功能 '{0}' 不可用。请使用语言版本 10.0 或更高版本。</value>
  </data>
  <data name="TypeCannotBeUsedInawaitForeachStatementBecauseReturnTypeOfGetAsyncEnumeratorMoveNextAsyncMethodIsNotAwaitableTypeWithboolResultMessage" xml:space="preserve">
    <value>类型 '{0}' 不能用于 'await foreach' 语句，因为 'GetAsyncEnumerator.MoveNextAsync' 方法的返回值类型不是具有 'bool' 结果的可等待类型</value>
  </data>
  <data name="InconsistentModifiersDeclarationOrderMessage" xml:space="preserve">
    <value>修饰符声明顺序不一致</value>
  </data>
  <data name="MethodInvocationIsSkipped" xml:space="preserve">
    <value>跳过了方法调用</value>
  </data>
  <data name="CompilerWarning_CS3000_Title" xml:space="preserve">
    <value>带有变量参数的方法不符合 CLS</value>
  </data>
  <data name="ArgExpectedRefOrInMessage" xml:space="preserve">
    <value>实参 {0} 应与 'ref' 或 'in' 关键字一起传递</value>
  </data>
  <data name="ParameterIsInferredToBeNullable" xml:space="preserve">
    <value>形参被推断为可以为 null 的</value>
  </data>
  <data name="TheTypeMustBeAReferenceTypeInOrderToUseItAsParameterMessage" xml:space="preserve">
    <value>类型 '{0}' 必须为引用类型才能将其用作形参 '{1}'</value>
  </data>
  <data name="IQueryableIsPossiblyUnintentionallyUsedAsIEnumerable" xml:space="preserve">
    <value>IQueryable 可能被无意中用作 IEnumerable</value>
  </data>
  <data name="UseinheritdocOnRootLevelToInheritDocumentationFromBaseCandidate" xml:space="preserve">
    <value>在根级别使用 &lt;inheritdoc /&gt; 可从基候选项继承文档</value>
  </data>
  <data name="InlineArrayNotSupportedByLanguageMessage" xml:space="preserve">
    <value>对于作为类型实参无效或具有作为类型实参无效的元素类型的内联数组类型，不支持 'Inline arrays' 语言功能</value>
  </data>
  <data name="RecordMemberMustReturnMessage" xml:space="preserve">
    <value>记录成员 '{0}' 必须返回 '{1}'</value>
  </data>
  <data name="RedundantAlwaysMatchSubpattern" xml:space="preserve">
    <value>始终匹配的子模式冗余</value>
  </data>
  <data name="voidMethodIsAnnotatedByPureAttribute" xml:space="preserve">
    <value>'void' 方法使用 [Pure] 特性注解</value>
  </data>
  <data name="CompilerWarning_CS9093_Title" xml:space="preserve">
    <value>此 ref 分配的值只能通过 return 语句转义当前方法。</value>
  </data>
  <data name="RedundantstringFormatCall" xml:space="preserve">
    <value>冗余的 'string.Format()' 调用</value>
  </data>
  <data name="UseExplicitOrImplicitModifierDefinitionForTypes" xml:space="preserve">
    <value>对类型使用显式或隐式修饰符定义</value>
  </data>
  <data name="EmptyforLoopIsRedundant9" xml:space="preserve">
    <value>空 'for' 循环冗余</value>
  </data>
  <data name="PartialHasConstructorInitializerMessage" xml:space="preserve">
    <value>分部构造函数定义不能具有构造函数初始值设定项</value>
  </data>
  <data name="UnderlyingTypeOfEnumIsint" xml:space="preserve">
    <value>枚举的基础类型为 'int'</value>
  </data>
  <data name="CompilerWarning_CS8794_Title" xml:space="preserve">
    <value>输入始终与提供的模式匹配。</value>
  </data>
  <data name="TheNotNullConstraintIsRedundantBecauseTypeParameterIsConstrainedByNonNullableTypeMessage" xml:space="preserve">
    <value>'{0}' 约束冗余，因为类型形参 '{1}' 受不可以为 null 的基类型 '{2}' 约束</value>
  </data>
  <data name="RedundantGlobalUsingDirective" xml:space="preserve">
    <value>冗余的 global using 指令</value>
  </data>
  <data name="ApplyingNullnessAnnotationToDeclarationThatCannotBeDirectlyReferencedFromOtherCodeIsMeaninglessMessage" xml:space="preserve">
    <value>对不能从其他代码直接引用的声明应用为 null 性注解毫无意义</value>
  </data>
  <data name="CannotReturnByReferenceBecauseItIsNotArefoutOrinParameterMessage" xml:space="preserve">
    <value>不能通过引用返回{0} '{1}'，因为它不是 'ref'、'out' 或 'in' 形参</value>
  </data>
  <data name="RedundantExplicitTupleComponentNameMessage" xml:space="preserve">
    <value>冗余的显式元组组件名称</value>
  </data>
  <data name="IAsyncEnumerableTSupportsCancellationViaWithCancellationExtensionMethod" xml:space="preserve">
    <value>IAsyncEnumerable&lt;T&gt; 通过 'WithCancellation' 扩展方法支持取消</value>
  </data>
  <data name="AvoidUsingasyncMethodsWithThevoidReturnType" xml:space="preserve">
    <value>避免将 'async' 用于带有 'void' 返回值类型但没有 'System.EventArgs' 类型形参的方法和函数</value>
  </data>
  <data name="ApartialMethodCannotHaveoutParametersUnlessLanguageVersionOrGreaterIsUsedMessage" xml:space="preserve">
    <value>除非使用语言版本 '9.0' 或更高版本，否则 'partial' 方法不能有 'out' 形参</value>
  </data>
  <data name="BracesCanBeSafelyRemovedWithoutChangingCodeSemantics" xml:space="preserve">
    <value>可以安全地移除大括号而不更改代码语义</value>
  </data>
  <data name="FixedSizeBufferMayBeDeclaredInStructOnlyMessage" xml:space="preserve">
    <value>只能在结构中声明固定大小的缓冲区</value>
  </data>
  <data name="SomeValuesOfTheEnumAreNotProcessedInside_Text" xml:space="preserve">
    <value>枚举的某些值未在 switch 内处理:</value>
  </data>
  <data name="ElementTypeIn__Text" xml:space="preserve">
    <value>{0}中的元素类型</value>
  </data>
  <data name="TheOperatorMustBeAppliedToAPointerMessage" xml:space="preserve">
    <value>'-&gt;' 运算符必须应用于指针</value>
  </data>
  <data name="PartOfLoopsBodyCanBeConvertedIntoLINQExpressionMessage" xml:space="preserve">
    <value>循环体的一部分可以转换为 LINQ 表达式</value>
  </data>
  <data name="UseExpressionBodyOrBlockBodyForMethods_Text" xml:space="preserve">
    <value>为方法使用表达式主体或块主体</value>
  </data>
  <data name="ArrangeNullCheckingPattern_Description" xml:space="preserve">
    <value>使用首选的 null 检查模式样式('not null' 或 '{ }')</value>
  </data>
  <data name="RedundantPartialMethodEmptyImplementation_Title" xml:space="preserve">
    <value>'partial void' 方法的空实现冗余</value>
  </data>
  <data name="TypeSpecifiedInBaseTypeRequiredAttributeConflictsAnotherType" xml:space="preserve">
    <value>'[BaseTypeRequired]' 特性中指定的类型与另一个类型冲突</value>
  </data>
  <data name="SimplifyIsAssignableFromTitle" xml:space="preserve">
    <value>简化 'IsAssignableFrom()' 调用</value>
  </data>
  <data name="PossibleLossOfFractionWhenDividingIntegralValuesAndAssignResultToFloatOrDecimal" xml:space="preserve">
    <value>除以整数值并将结果赋值为浮点数或小数时分数可能丢失</value>
  </data>
  <data name="InterceptorNotAccessibleMessage" xml:space="preserve">
    <value>无法拦截，因为在 '{1}' 中无法访问 '{0}'</value>
  </data>
  <data name="AThrowStatementWithNoArgumentsIsNotAllowedInsideOfAFinallyClauseNestedInsideOfTheInnermostCatchClauseMessage" xml:space="preserve">
    <value>不允许在嵌套在最里面的 catch 子句内的 finally 子句内使用不带实参的 throw 语句</value>
  </data>
  <data name="CheckUsageOfasyncLambdaExpressionAnyExceptionsNotHandledByTheLambdaMightLeadToAProcessCrash" xml:space="preserve">
    <value>检查 'async' lambda 表达式的用法: lambda 未处理的任何异常都可能导致进程崩溃</value>
  </data>
  <data name="VariableResultedFromAConditionalExpression_Text" xml:space="preserve">
    <value>条件表达式生成的变量</value>
  </data>
  <data name="PreferToExplicitlyMarkDiscardsWithVar_Caption" xml:space="preserve">
    <value>首选显式使用 'var' 关键字标记弃元</value>
  </data>
  <data name="NameOfDestructorMustMatchTheNameOfTheClassMessage" xml:space="preserve">
    <value>析构函数的名称必须与类名匹配</value>
  </data>
  <data name="ConvertToConstructorOrDestructorWithPreferredBodyStyle" xml:space="preserve">
    <value>转换为具有首选主体样式的构造函数或析构函数</value>
  </data>
  <data name="DuplicatePropertyAssignmentMessage" xml:space="preserve">
    <value>重复的属性 '{0}' 赋值</value>
  </data>
  <data name="IgnoredDirectiveSeparatedBySpaceMessage" xml:space="preserve">
    <value>'#{0}' 指令标记内不允许空格</value>
  </data>
  <data name="CompilerWarning_CS8600_Title" xml:space="preserve">
    <value>将 null 字面量或可能为 null 的值转换为非 null 类型。</value>
  </data>
  <data name="CompilerWarning_CS8615_Title" xml:space="preserve">
    <value>类型中引用类型的为 Null 性与实现的成员不匹配。</value>
  </data>
  <data name="IntroduceVerticalSpacingToHighlightControlTransferStatement" xml:space="preserve">
    <value>引入垂直间距以高亮显示控制传输语句</value>
  </data>
  <data name="TheModifierIsNotValidForAccessorMessage" xml:space="preserve">
    <value>修饰符 '{0}' 对访问器无效</value>
  </data>
  <data name="TheTypeArgumentsCannotBeInferredFromTheUsageTrySpecifyingTheTypeArgumentsExplicitlynCandidatesAreMessage" xml:space="preserve">
    <value>不能从用法中推断类型实参。请尝试显式指定类型实参。
候选项为:{0}</value>
  </data>
  <data name="CannotUseSizeofOnVoidTypeMessage" xml:space="preserve">
    <value>不能在 'void' 类型上使用 'sizeof'</value>
  </data>
  <data name="EmptywithExpressionAppliedToNewlyCreatedObjectInstanceResultsInUnnecessaryCloneCreation" xml:space="preserve">
    <value>应用于新创建对象实例的空 'with' 表达式会导致不必要的克隆创建</value>
  </data>
  <data name="MergeAndPattern" xml:space="preserve">
    <value>合并 'and' 模式</value>
  </data>
  <data name="ReplaceSequenceEqualWithConstantPatternTitle" xml:space="preserve">
    <value>将 'SequenceEqual' 替换为常量模式</value>
  </data>
  <data name="EmptyPropertyPatternClauseCanBeOmitted" xml:space="preserve">
    <value>可以省略空属性模式子句</value>
  </data>
  <data name="UseNameofExpressionToReferenceEnumMemberName" xml:space="preserve">
    <value>使用 'nameof' 表达式引用枚举成员名称</value>
  </data>
  <data name="MethodHasAsyncOverload" xml:space="preserve">
    <value>方法具有异步重载</value>
  </data>
  <data name="UnnecessaryWhitespaceAtTheEndOfLine" xml:space="preserve">
    <value>行尾的不必要空格</value>
  </data>
  <data name="TheValuesOfDeconstructingAssignmentAreAllDiscardedAndCantBeUsedInAnyExecutionPath" xml:space="preserve">
    <value>析构赋值的值全部被舍弃，不能在任何执行路径中使用</value>
  </data>
  <data name="ArithmeticProblemInConstantValueComputationMessage" xml:space="preserve">
    <value>常量值计算中存在算术问题</value>
  </data>
  <data name="_Type_Text" xml:space="preserve">
    <value>{0}类型</value>
  </data>
  <data name="BothContextDeclaredDescription" xml:space="preserve">
    <value>方法在两种 CQRS 上下文中声明</value>
  </data>
  <data name="YouCannotUseTheFixedStatementToTakeTheAddressOfAnAlreadyFixedExpressionMessage" xml:space="preserve">
    <value>不能使用 fixed 语句获取已固定表达式的地址</value>
  </data>
  <data name="BaseDeclarationHasTheSameAnnotationMessage" xml:space="preserve">
    <value>基方法声明具有相同的注解</value>
  </data>
  <data name="ReturnValueOfPureMethodIsNotUsed16" xml:space="preserve">
    <value>纯方法的返回值未使用</value>
  </data>
  <data name="TheOverrideOfAVirtualMemberIsRedundantBecauseItConsistsOfOnlyACallToTheBase" xml:space="preserve">
    <value>virtual 成员的重写冗余，因为它只包含对基成员的调用</value>
  </data>
  <data name="CodeCleanupTask_SortModifiers" xml:space="preserve">
    <value>对修饰符排序</value>
  </data>
  <data name="LocalSameNameAsExtensionTypeParameterErrorMessage" xml:space="preserve">
    <value>'{0}': 形参、局部变量或本地函数不能与扩展类型形参同名</value>
  </data>
  <data name="AccessToCapturedVariableFromAnonymousMethodWhenTheVariableIsDisposed" xml:space="preserve">
    <value>释放变量后，从匿名方法访问捕获变量</value>
  </data>
  <data name="BadCallerInfoAttributeParamWithoutDefaultValue_Message" xml:space="preserve">
    <value>[{0}] 特性只能应用于具有默认值的形参</value>
  </data>
  <data name="TopLevelCodeHidesExisting_EntryPoint_Text" xml:space="preserve">
    <value>顶层代码隐藏了类型 '{1}' 中现有的 '{0}' 入口点方法</value>
  </data>
  <data name="ReplaceUnaryNegationOperatorBeforeIsExpressionWithCNegatedPattern" xml:space="preserve">
    <value>将 'is' 表达式之前的一元求反运算符 '!' 替换为 C# 9.0 求反模式</value>
  </data>
  <data name="TheCannotBeUsedInThisContextBecauseTheAccessorIsInaccessibleMessage" xml:space="preserve">
    <value>{0} '{1}' 不能用于此上下文，因为 '{2}' 访问器不能访问</value>
  </data>
  <data name="CanSimplifyDictionaryRemovingWithSingleCallTitle" xml:space="preserve">
    <value>可以使用单个 'Remove' 简化字典条目移除</value>
  </data>
  <data name="CannotDeclareAPointerToAManagedTypeMessage" xml:space="preserve">
    <value>不能声明托管类型 '{0}' 的指针</value>
  </data>
  <data name="PossibleMistakenCallToGetTypeTitle" xml:space="preserve">
    <value>可能存在错误的 'GetType()' 调用</value>
  </data>
  <data name="CollectionArgumentsDynamicBindingMessage" xml:space="preserve">
    <value>集合实参不能为动态；需要编译时绑定</value>
  </data>
  <data name="UseCollectionsCountProperty" xml:space="preserve">
    <value>使用集合的计数属性</value>
  </data>
  <data name="CannotConvertInstanceArgumentType_To_Text" xml:space="preserve">
    <value>不能将实例实参类型 '{0}' 转换为 '{1}'</value>
  </data>
  <data name="DelegateReturnType_Text" xml:space="preserve">
    <value>委托返回值类型</value>
  </data>
  <data name="IndexingByInvalidRangeMayCauseExceptions" xml:space="preserve">
    <value>通过无效范围索引可能会导致异常</value>
  </data>
  <data name="ReplaceSequenceEqualWithConstantPatternDescription" xml:space="preserve">
    <value>将 'SequenceEqual' 调用替换为常量模式检查</value>
  </data>
  <data name="CompilerWarning_CS0184_Title" xml:space="preserve">
    <value>'"is" 表达式的给定表达式始终不是所提供的类型</value>
  </data>
  <data name="RecordMemberMustBeAReadableInstancePropertyOrFieldOfTypeToMatchPositionalParameterMessage" xml:space="preserve">
    <value>记录成员 '{0}' 必须为 '{1}' 类型的可读实例属性或字段以匹配位置形参 '{2}'</value>
  </data>
  <data name="CannotInitializeRequiredMembersFromParamsCollectionMessage" xml:space="preserve">
    <value>无法在 params 集合中创建 '{0}' 的实例，因为以下必需成员将不初始化:</value>
  </data>
  <data name="SuggestWhenArgumentsAreLongerDescription" xml:space="preserve">
    <value>在显式类型实参比转换表达式更冗长时建议</value>
  </data>
  <data name="MethodGroupToNonDelegateErrorMessage" xml:space="preserve">
    <value>无法将方法组“{0}”转换为非委托类型“{1}”。是否希望调用此方法?</value>
  </data>
  <data name="TheGivenExpressionIsNeverOfTheProvidedTypeMessage" xml:space="preserve">
    <value>给定表达式从不为提供的类型</value>
  </data>
  <data name="ModuleInitializerMethodMustNotBeGenericAndMustNotBeContainedInAGenericTypeMessage" xml:space="preserve">
    <value>模块初始值设定项方法“{0}”不能是泛型的，且不得包含在泛型类型中</value>
  </data>
  <data name="MethodIsMarkedAsOperationContractButContainingTypeIsntMarkedAsServiceContract" xml:space="preserve">
    <value>方法被标记为 OperationContract，但包含类型未被标记为 ServiceContract</value>
  </data>
  <data name="NullAsDelegateCreationParameterMessage" xml:space="preserve">
    <value>null 作为委托创建形参</value>
  </data>
  <data name="FieldOfTypeCannotBeVolatileMessage" xml:space="preserve">
    <value>'{0}' 类型的字段不能是 volatile 字段</value>
  </data>
  <data name="EmptyNamespaceDeclarationIsRedundant" xml:space="preserve">
    <value>空命名空间声明冗余</value>
  </data>
  <data name="ThePatternIsRedundantMessage" xml:space="preserve">
    <value>模式冗余，不会产生任何运行时检查</value>
  </data>
  <data name="GlobalUsingDirectives_Text" xml:space="preserve">
    <value>全局 '{0}' 指令</value>
  </data>
  <data name="MethodExpectedButFoundMessage" xml:space="preserve">
    <value>应为方法，但实际为{0} {1}</value>
  </data>
  <data name="PossibleIncorrectImplementationOfDoubleCheckLockingPatternReadAccessToCheckedField" xml:space="preserve">
    <value>可能错误地实现了双重检查锁定模式。请对checked 字段进行读取访问。</value>
  </data>
  <data name="UseNameofExpressionToReferenceNameInPartOfTheStringLiteral" xml:space="preserve">
    <value>使用 'nameof' 表达式引用部分字符串字面量中的名称</value>
  </data>
  <data name="ParametersMustHaveWhenExitingMessage" xml:space="preserve">
    <value>退出时形参 {0} 必须具有非 null 值</value>
  </data>
  <data name="ReplaceXObjectPatternNotPerformingAnyAdditionalChecksWithVarXPattern" xml:space="preserve">
    <value>将不执行任何额外检查的 '{ } x' 对象模式替换为 'var x' 模式</value>
  </data>
  <data name="AStackallocExpressionRequiresAfterTypeMessage" xml:space="preserve">
    <value>stackalloc 表达式在类型后要求有 []</value>
  </data>
  <data name="CannotSpecifyBothnotnullAndstructTypeConstraintMessage" xml:space="preserve">
    <value>不能同时指定 'notnull' 和 'struct' 类型约束</value>
  </data>
  <data name="ArglistIsNotValidInThisContextMessage" xml:space="preserve">
    <value>__arglist 在此上下文中无效</value>
  </data>
  <data name="DuplicatedSwitchBranchesDescription" xml:space="preserve">
    <value>重复的 'switch' 分支。考虑将它们合并成一个单独的分支，以提高可读性和减少代码重复。</value>
  </data>
  <data name="ProgramHasMoreThanOneEntryPointDefinedMessage" xml:space="preserve">
    <value>程序 '{0}' 定义了多个入口点</value>
  </data>
  <data name="RedundantNullableDirectiveMessage" xml:space="preserve">
    <value>冗余的可以为 null 的指令</value>
  </data>
  <data name="ReturnOfTaskProducedByUsingVariableTitle" xml:space="preserve">
    <value>返回由 'using' 捕获的对象生成的任务</value>
  </data>
  <data name="CompilerWarning_CS8597_Title" xml:space="preserve">
    <value>抛出的值可能为 null。</value>
  </data>
  <data name="TheParameterlessStructConstructorMustBepublicMessage" xml:space="preserve">
    <value>无形参结构构造函数必须为 'public'</value>
  </data>
  <data name="AccessToModifiedCapturedVariable" xml:space="preserve">
    <value>访问已修改的捕获变量</value>
  </data>
  <data name="AnalysisIsNotAvailableForTheFileFile_Text" xml:space="preserve">
    <value>无法分析该文件。文件的主要语言不是 C#。</value>
  </data>
  <data name="AnExpressionTreeMayNotContainAReferenceToALocalFunctionMessage" xml:space="preserve">
    <value>表达式树不能包含对局部函数的引用</value>
  </data>
  <data name="RedundantIEnumerableCastTOrIEnumerableOfTypeTCall" xml:space="preserve">
    <value>冗余的 'IEnumerable.Cast&lt;T&gt;' 或 'IEnumerable.OfType&lt;T&gt;' 调用</value>
  </data>
  <data name="FunctionPointerInvocation_Text" xml:space="preserve">
    <value>函数指针调用</value>
  </data>
  <data name="CSharpFormatterHighlightingProvider_InternalConfigurableSeverityItems_Tabs_spaces_mismatch" xml:space="preserve">
    <value>制表符/空格不匹配</value>
  </data>
  <data name="IncorrectBoundaryConstantExpectedAnnotation_Message" xml:space="preserve">
    <value>值 {0}={1} 不符合 {2}..{3} 的形参值范围</value>
  </data>
  <data name="CompilerWarning_CS9204_Title" xml:space="preserve">
    <value>类型仅用于评估，在将来的更新中可能会被更改或移除。禁止进行此诊断。</value>
  </data>
  <data name="CompilerWarning_CS8764_Title" xml:space="preserve">
    <value>返回类型的为 Null 性与重写成员不匹配(可能是由于为 Null 性特性)。</value>
  </data>
  <data name="PartialMethodParameterScopeModifiersMismatchMessage" xml:space="preserve">
    <value>形参 '{0}' 的 'scoped' 修饰符与分部方法声明不匹配</value>
  </data>
  <data name="ConvertToStaticClass" xml:space="preserve">
    <value>转换为 static 类</value>
  </data>
  <data name="CompilerWarning_CS4014_Title" xml:space="preserve">
    <value>由于此调用不会等待，因此在调用完成前将继续执行当前方法</value>
  </data>
  <data name="FunctionMustBeCalledOnServerSideText" xml:space="preserve">
    <value>数据库函数不得在非数据库上下文中调用</value>
  </data>
  <data name="TypeParameterHasTheSameNameAsTheTypeParameterFromOuterMessage" xml:space="preserve">
    <value>类型形参 '{0}' 与来自外部{1} '{2}' 的类型形参同名</value>
  </data>
  <data name="CompilerWarning_CS7022_Title" xml:space="preserve">
    <value>程序的入口点是全局代码；将忽略此入口点</value>
  </data>
  <data name="TryCastAndCheckForNullCanBeReplacedWithATypeCheck" xml:space="preserve">
    <value>null 的 try cast 和检查可被替换为类型检查</value>
  </data>
  <data name="CompilerWarning_CS1581_Title" xml:space="preserve">
    <value>XML 注释的 cref 特性中的返回类型无效</value>
  </data>
  <data name="ComponentOfTheTupleIsNeverUsed4" xml:space="preserve">
    <value>元组的组件从未被使用</value>
  </data>
  <data name="IntroduceOptionalParameterSForMessage" xml:space="preserve">
    <value>为{0} '{1}' 引入可选形参</value>
  </data>
  <data name="CompilerWarning_CS0251_Title" xml:space="preserve">
    <value>正在使用负值对数组编制索引</value>
  </data>
  <data name="BracesAndOperatorsSemicolon_RiderPresentableName" xml:space="preserve">
    <value>大括号和运算符//分号</value>
  </data>
  <data name="MathAbsArgumentIsAlwaysNonNegativeMessage" xml:space="preserve">
    <value>Math.Abs() 实参始终为非负</value>
  </data>
  <data name="ReturnOfUsingVariableMessage" xml:space="preserve">
    <value>变量 '{0}' 是由 'using' 语句捕获的，并且会在返回之前被自动处置</value>
  </data>
  <data name="WhenAVirtualMethodIsCalledTheActualTypeThatExecutesTheMethodIsNotSelectedUntilRunTimeWhenAConstructorCallsAVirtualMethodItIsPossibleThatTheConstructorForTheInstanceThatInvokesTheMethodHasNotExecutedSeeaHrefhttpMsdnMicrosoftComEnUsLibraryMsAspxhttpMsdnMicrosoftComEnUsLibraryMsAspxA" xml:space="preserve">
    <value>调用 virtual 方法时，执行该方法的实际类型直到运行时才被选中。当构造函数调用 virtual 方法时，调用该方法的实例的构造函数可能尚未执行。请参阅 &lt;a href='http://msdn2.microsoft.com/en-us/library/ms182331.aspx'&gt;http://msdn2.microsoft.com/en-us/library/ms182331.aspx&lt;/a&gt;。</value>
  </data>
  <data name="ReplaceWithSingleAssignment_Text" xml:space="preserve">
    <value>替换为单个赋值</value>
  </data>
  <data name="CannotSpecifyTheOutAttributeOnARefParameterWithoutAlsoSpecifyingTheInAttributeMessage" xml:space="preserve">
    <value>不可在 ref 参数上指定 Out 特性，除非同时指定 In 特性</value>
  </data>
  <data name="TheparamsParameterCannotBeDeclaredAsMessage" xml:space="preserve">
    <value>'params' 形参不能被声明为 '{0}'</value>
  </data>
  <data name="MergeNestedPropertyPatternsMessage" xml:space="preserve">
    <value>合并嵌套属性模式</value>
  </data>
  <data name="RedundantCollectionCopyCallTitle" xml:space="preserve">
    <value>冗余的集合副本</value>
  </data>
  <data name="CompilerWarning_CS0197_Title" xml:space="preserve">
    <value>将引用封送类的字段用作 ref 或 out 值或获取其地址可能导致运行时异常</value>
  </data>
  <data name="APropertySubpatternRequiresAReferenceToThePropertyOrFieldToBeMatchedEGNameVarAMessage" xml:space="preserve">
    <value>属性子模式需要引用要匹配的属性或字段，例如，"{ Name: var a }"</value>
  </data>
  <data name="ReturnStatementIsMissingMessage" xml:space="preserve">
    <value>缺少 return 语句</value>
  </data>
  <data name="AvoidOrintReturningEntryPointCannotBeasyncMessage" xml:space="preserve">
    <value>'void' 或 'int' 返回入口点不能为 'async'</value>
  </data>
  <data name="TheasyncModifierCanOnlyBeUsedInMethodsThatHaveABodyMessage" xml:space="preserve">
    <value>只能在具有正文的方法中使用 "async" 修饰符</value>
  </data>
  <data name="CompilerWarning_CS1700_Title" xml:space="preserve">
    <value>程序集引用无效，无法解析</value>
  </data>
  <data name="InvertIfStatementToReduceNestingMessage" xml:space="preserve">
    <value>反转 '{0}' 语句以减少嵌套</value>
  </data>
  <data name="RewriteAsMessage" xml:space="preserve">
    <value>重写为 '{0}'</value>
  </data>
  <data name="CSharpFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_namespace_braces" xml:space="preserve">
    <value>命名空间大括号周围</value>
  </data>
  <data name="OutParameterWithHandlesResourceDisposalAttributeTitle" xml:space="preserve">
    <value>输出形参的无意义 [HandlesResourceDisposal] 注解</value>
  </data>
  <data name="AddressOfInAsync_Text" xml:space="preserve">
    <value>'&amp;' 运算符不应用于 async 方法中的形参或局部变量</value>
  </data>
  <data name="CannotInheritFromSealedMessage" xml:space="preserve">
    <value>不能从 sealed {0} '{1}' 继承</value>
  </data>
  <data name="PossibleSystemArgumentOutOfRangeExceptionZeroIndexFromEndMessage" xml:space="preserve">
    <value>来自末尾的索引必须大于零；使用 '^1' 引用最后一个元素</value>
  </data>
  <data name="ConditionIsKnownToBeNullOrNotNull" xml:space="preserve">
    <value>'??' 条件已知为 null 或非 null</value>
  </data>
  <data name="RedundantabstractModifierInInterfaceDeclaration" xml:space="preserve">
    <value>接口声明中存在冗余的 'abstract' 修饰符</value>
  </data>
  <data name="NullabilityOfReferenceTypesInTypeOfParameterDoesntMatchPartialMethodDeclarationMessage" xml:space="preserve">
    <value>形参 '{0}' 的类型中引用类型的为 null 性在方法声明的各部分之间不匹配</value>
  </data>
  <data name="CompilerWarning_CS3022_Title" xml:space="preserve">
    <value>CLSCompliant 特性在应用于参数时无意义</value>
  </data>
  <data name="PartOfLoopsBodyCanBeConvertedIntoLINQExpression" xml:space="preserve">
    <value>循环体的一部分可以转换为 LINQ 表达式</value>
  </data>
  <data name="ArrangeNullCheckingPattern_Message" xml:space="preserve">
    <value>null 检查模式样式不一致</value>
  </data>
  <data name="AppendToCollectionExpression" xml:space="preserve">
    <value>追加到集合表达式</value>
  </data>
  <data name="ConstantExpectedTitle" xml:space="preserve">
    <value>为了获得最佳性能，该形参应为一个常量</value>
  </data>
  <data name="TypesEnum_RiderPresentableName" xml:space="preserve">
    <value>类型//枚举</value>
  </data>
  <data name="CallerInfoAttributeParamForUnconsumedLocation_Message" xml:space="preserve">
    <value>应用于形参 '{1}' 的 [{0}] 特性将不起作用，因为它应用于的成员在不允许使用可选实参的上下文中使用</value>
  </data>
  <data name="TheFirstOperandOfAnisOrasOperatorCannotBeALambdaExpressionOrAnonymousMethodMessage" xml:space="preserve">
    <value>'is' 或 'as' 运算符的第一个操作数不能为 lambda 表达式或匿名方法</value>
  </data>
  <data name="ReturnValueIsMissingMessage" xml:space="preserve">
    <value>缺少返回值</value>
  </data>
  <data name="CanBeMadeStaticMessage" xml:space="preserve">
    <value>{0}可被设为 '{1}'</value>
  </data>
  <data name="CLRTypeNamesAndCorrespondingCKeywordAreInterchangeableAndDoNotAffectCodeSemantics" xml:space="preserve">
    <value>CLR 类型名称和对应的 C# 关键字可互换，不影响代码语义</value>
  </data>
  <data name="KeywordoverrideIsMissingMessage" xml:space="preserve">
    <value>缺少关键字 'override'</value>
  </data>
  <data name="AnOutParameterCannotHaveTheInAttributeMessage" xml:space="preserve">
    <value>out 参数不能具有 In 特性</value>
  </data>
  <data name="CompilerWarning_CS8880_Title" xml:space="preserve">
    <value>在将控件返回给调用方之前，必须完全分配自动实现的属性。请考虑更新语言版本以自动默认属性。</value>
  </data>
  <data name="CompilerWarning_CS9158_Title" xml:space="preserve">
    <value>形参类型中引用类型的为 null 性与可拦截的方法不匹配。</value>
  </data>
  <data name="PossibleOverflowOfIntVariableMessage" xml:space="preserve">
    <value>在 int 变量中可能溢出</value>
  </data>
  <data name="CannotConvertExpressionTypeToReturnTypeMessage" xml:space="preserve">
    <value>不能将表达式类型 '{0}' 转换为返回值类型 '{1}'</value>
  </data>
  <data name="MissingXMLCommentForPubliclyVisibleTypeOrMemberMessage" xml:space="preserve">
    <value>缺少对公共可见类型或成员“{0}”的 XML 注释</value>
  </data>
  <data name="CompilerWarning_CS8094_Title" xml:space="preserve">
    <value>对齐值具有可能产生较大的格式化字符串的度量值</value>
  </data>
  <data name="ExpressionTreeMayNotContainACollectionExpression_Text" xml:space="preserve">
    <value>表达式树不能包含集合表达式</value>
  </data>
  <data name="MethodParameterHasTheSameNameAsAPrimaryConstructorParameterAndHidesIt" xml:space="preserve">
    <value>方法形参与主构造函数形参同名，并将其隐藏</value>
  </data>
  <data name="MissingConfigureAwaitFalseForAsyncDisposableInLibraryCodeMessage" xml:space="preserve">
    <value>库代码中的异步释放缺少 '.ConfigureAwait(false)'</value>
  </data>
  <data name="EmptyFinalizerDeclarationIsRedundant" xml:space="preserve">
    <value>空终结器声明冗余</value>
  </data>
  <data name="PossibleCyclicConstructorCallMessage" xml:space="preserve">
    <value>可能的循环构造函数调用</value>
  </data>
  <data name="UnmanagedKeywordExpected_ToolTip" xml:space="preserve">
    <value>应为 'unmanaged' 关键字</value>
  </data>
  <data name="TypesStruct_RiderPresentableName" xml:space="preserve">
    <value>类型//结构</value>
  </data>
  <data name="PartialMember_MustHaveAnImplementationPartMessage" xml:space="preserve">
    <value>分部{0} '{1}' 必须有实现部分</value>
  </data>
  <data name="MoveToExtensionBlockDescription" xml:space="preserve">
    <value>将扩展方法移至现有扩展块</value>
  </data>
  <data name="OperatorWithoutMatchedCheckedOperatorWhenAnotherOperatorHasCheckedVersion" xml:space="preserve">
    <value>该运算符没有匹配的 checked 运算符，而此类型的其他运算符有 checked 版本</value>
  </data>
  <data name="ConversionToBaseClassMessage" xml:space="preserve">
    <value>转换为基类</value>
  </data>
  <data name="UseIndexedPropertyMessage" xml:space="preserve">
    <value>使用索引的属性</value>
  </data>
  <data name="CannotApplyOverloadResolutionPriorityToOverride_Text" xml:space="preserve">
    <value>无法在重写成员上使用 'OverloadResolutionPriorityAttribute'</value>
  </data>
  <data name="Braces_Text" xml:space="preserve">
    <value>大括号</value>
  </data>
  <data name="AnAttributeArgumentArrayCreationMustBeSingleDimensionArrayWithInitializedElementsMessage" xml:space="preserve">
    <value>特性实参数组创建必须为具有初始化元素的一维数组</value>
  </data>
  <data name="SimplifyIsAssignableFromDescription" xml:space="preserve">
    <value>IsAssignableFrom() 调用可以使用 IsInstanceOfType() 或 'is' 运算符简化</value>
  </data>
  <data name="RedundantPropertyPatternClauseMessage" xml:space="preserve">
    <value>冗余的属性模式子句</value>
  </data>
  <data name="CompilerWarning_CS1690_Title" xml:space="preserve">
    <value>访问引用封送类的字段上的成员可能导致运行时异常</value>
  </data>
  <data name="OverrideCannotChangeAccessRightsMessage" xml:space="preserve">
    <value>重写{0} '{1}' 不能更改访问权限</value>
  </data>
  <data name="InterceptableMethodMustBeOrdinaryMessage" xml:space="preserve">
    <value>无法拦截 '{0}'，因为它不是对普通成员方法的调用</value>
  </data>
  <data name="CompilerWarning_CS1685_Title" xml:space="preserve">
    <value>预定义类型是在全局别名的多个程序集中定义的</value>
  </data>
  <data name="AssignedValueCanBeLostIfGenericTypeParameterWillBeSubstitutedWithStructTypeStructMessage" xml:space="preserve">
    <value>如果泛型类型形参将被替换为结构类型，赋值可能丢失。{0}结构成员修改需要将访问的结构分类为变量。</value>
  </data>
  <data name="CompilerWarning_CS3021_Title" xml:space="preserve">
    <value>由于程序集没有 CLSCompliant 特性，因此类型或成员不需要 CLSCompliant 特性</value>
  </data>
  <data name="SimilarExpressionsComparison" xml:space="preserve">
    <value>类似表达式比较</value>
  </data>
  <data name="ArrayInitializerIsExpectedMessage" xml:space="preserve">
    <value>应为数组初始值设定项</value>
  </data>
  <data name="SimplifyIsAssignableFromMessage" xml:space="preserve">
    <value>简化 '{0}()' 调用</value>
  </data>
  <data name="SpinLockShouldNotBeStoredInReadonlyFieldBecauseItIsStructAndIsCopiedWhenInstanceMethodIsCalledOnIt" xml:space="preserve">
    <value>SpinLock 不应存储在只读字段中，因为它是一个结构，并且会在其中调用实例方法时对其进行复制</value>
  </data>
  <data name="IntroduceOptionalParametersToOverloadMethod" xml:space="preserve">
    <value>为重载方法引入可选形参</value>
  </data>
  <data name="CodeIsHeuristicallyUnreachableMessage" xml:space="preserve">
    <value>代码为启发式不可到达</value>
  </data>
  <data name="AforeachForEachForVBNETOrforStatementCanBeConvertedIntoALINQExpression" xml:space="preserve">
    <value>'foreach' (对于 VB.NET 为 'For Each')或 'for' 语句可以转换为 LINQ 表达式</value>
  </data>
  <data name="ReplaceTernaryExpressionWithSwitchExpression" xml:space="preserve">
    <value>将三元表达式替换为 'switch' 表达式</value>
  </data>
  <data name="StaticClassCannotHavesealedModifierMessage" xml:space="preserve">
    <value>static 类 '{0}' 不能有 'sealed' 修饰符</value>
  </data>
  <data name="StringLiteralsLengthCanBeReducedByUsingVerbatimString" xml:space="preserve">
    <value>可以通过使用逐字字符串来缩短字符串字面量长度</value>
  </data>
  <data name="APreviousCatchClauseAlreadyCatchesAllExceptionsOfThisOrOfASuperTypeMessage" xml:space="preserve">
    <value>上一个 catch 子句已经捕获了此类型或超类型(“{0}”)的所有异常</value>
  </data>
  <data name="TheNullabilityAttributeHasNoEffectAndCanBeSafelyRemovedMessage" xml:space="preserve">
    <value>为 null 性特性不起任何作用，可以安全地移除</value>
  </data>
  <data name="CompilerWarning_CS1734_Title" xml:space="preserve">
    <value>XML 注释中有 paramref 标记，但是没有该名称的参数</value>
  </data>
  <data name="MethodsOverloadedOperator_RiderPresentableName" xml:space="preserve">
    <value>方法//重载运算符</value>
  </data>
  <data name="CannotDeclareAccessRightsForPrivateImplementationAccessorMessage" xml:space="preserve">
    <value>不能声明 private 实现访问器的访问权限</value>
  </data>
  <data name="PossibleSystemInvalidCastExceptionWhenCastingFromToMessage" xml:space="preserve">
    <value>从 '{2}' 类型转换为 '{3}' 时可能为 '{0}.{1}'</value>
  </data>
  <data name="InterceptorCannotInterceptNameofMessage" xml:space="preserve">
    <value>无法拦截 nameof 运算符</value>
  </data>
  <data name="AStringnullConstantIsNotSupportedAsAPatternForUseAnEmptyStringInsteadMessage" xml:space="preserve">
    <value>不支持将字符串 'null' 常量作为 '{0}' 的模式。改用空字符串</value>
  </data>
  <data name="StaticConstructorMustBeParameterlessMessage" xml:space="preserve">
    <value>static 构造函数必须为无形参</value>
  </data>
  <data name="CompilerWarning_CS8033_Title" xml:space="preserve">
    <value>程序集不包含任何分析器</value>
  </data>
  <data name="CompareToSimilarExpressionForEqualityIsUsuallySenseless" xml:space="preserve">
    <value>比较相似的表达式是否相等通常是冗余的操作</value>
  </data>
  <data name="choice:mappings" xml:space="preserve">
    <value>one:i == 1</value>
  </data>
  <data name="CompilerWarning_CS8973_Title" xml:space="preserve">
    <value>操作可能在运行时溢出(请使用“unchecked”语法替代)</value>
  </data>
  <data name="CodeCleanupTask_CSOptimizeUsings_EmbraceInRegion" xml:space="preserve">
    <value>在区域内包含 'using' 指令</value>
  </data>
  <data name="CompilerWarning_CS9183_Title" xml:space="preserve">
    <value>内联数组转换运算符不会用于从声明类型的表达式的转换。</value>
  </data>
  <data name="RedundantNameQualifier" xml:space="preserve">
    <value>冗余的名称限定符</value>
  </data>
  <data name="ParameterMustHaveANonNullValueWhenExitingBecauseParameterIsNonNullMessage" xml:space="preserve">
    <value>退出时参数“{0}”必须具有非 null 值，因为参数“{1}”是非 null</value>
  </data>
  <data name="ReplaceEnumMemberToStringExpressionWithConstantNameofExpression" xml:space="preserve">
    <value>将 'SomeEnum.Member.ToString()' 表达式替换为常量 'nameof' 表达式</value>
  </data>
  <data name="PossibleIncorrectImplementationOfDoubleCheckLockingCheckedFieldMustBeVolatileOrAssignedFromLocalVariableAfterThreadMemoryBarrierCallMessage" xml:space="preserve">
    <value>可能错误地实现了双重检查锁定。checked 字段必须为 volatile 或在 'Thread.MemoryBarrier()' 调用之后从局部变量中赋值。</value>
  </data>
  <data name="RedundantOperandInLogicalConditionalExpression" xml:space="preserve">
    <value>逻辑条件表达式中存在冗余的操作数</value>
  </data>
  <data name="InvalidInlineArrayLengthMessage" xml:space="preserve">
    <value>内联数组长度必须大于 0</value>
  </data>
  <data name="ConstructorWithMustDisposeResourceAttributeBaseIsNotAnnotatedTitle" xml:space="preserve">
    <value>[MustDisposeResource] 注解不是继承自基构造函数，应显式放置</value>
  </data>
  <data name="CovariantReturnTypeOfA_CanOnlyBeUsed_Text" xml:space="preserve">
    <value>使用{0}的协变返回值类型的条件是重写{0}处于只读状态</value>
  </data>
  <data name="NotSingleExtensionReceiverParameterErrorMessage" xml:space="preserve">
    <value>扩展必须具有单个接收器形参</value>
  </data>
  <data name="MemberWithTheSameNameIsAlreadyDeclaredMessage" xml:space="preserve">
    <value>已声明具有相同名称的成员</value>
  </data>
  <data name="OverridesObjectEqualsObjectOButDoesNotOverrideObjectGetHashCodeMessage" xml:space="preserve">
    <value>“{0}”重写 Object.Equals(object o) 但不重写 Object.GetHashCode()</value>
  </data>
  <data name="UsageOfinheritdocIsInvalid" xml:space="preserve">
    <value>&lt;inheritdoc /&gt; 的用法无效</value>
  </data>
  <data name="MultipleSequentialorderbyClausesAreMeaninglessPossiblyYouMeanThenByInsteadMessage" xml:space="preserve">
    <value>多个顺序 'orderby' 子句毫无意义。您的意思可能是 'ThenBy'。</value>
  </data>
  <data name="NamespaceShouldBeTheDefaultNamespaceOfThisProjectMessage" xml:space="preserve">
    <value>命名空间 '{0}' 应为此项目的默认命名空间</value>
  </data>
  <data name="CompilerWarning_CS7033_Title" xml:space="preserve">
    <value>指定了延迟签名，这需要公钥，但是未指定任何公钥</value>
  </data>
  <data name="ParenthesesCanBeSafelyAddedToExpressions_Text" xml:space="preserve">
    <value>可以安全地在表达式中添加圆括号以澄清优先级</value>
  </data>
  <data name="TheInheritedMembersAndHaveTheSameSignatureInSoTheyCannotBeOverriddenMessage" xml:space="preserve">
    <value>继承的成员 '{0}' 和 '{1}' 在{2} '{3}' 中具有相同的签名，因此它们不能被重写</value>
  </data>
  <data name="PatternMatchingIsNotPermittedForPointerTypesMessage" xml:space="preserve">
    <value>指针类型不允许模式匹配</value>
  </data>
  <data name="withExpressionAppliedToNewlyCreatedObjectInstanceResultsInUnnecessaryCloneCreation" xml:space="preserve">
    <value>应用于新创建对象实例的 'with' 表达式会导致不必要的克隆创建</value>
  </data>
  <data name="InstanceFieldsOfreadonlyStructsMustBereadonlyMessage" xml:space="preserve">
    <value>'readonly' 结构的实例字段必须为 'readonly'</value>
  </data>
  <data name="ConvertingNullLiteralOrPossibleNullValueToNonNullableTypeMessage" xml:space="preserve">
    <value>将 null 字面量或可能的 null 值转换为不可以为 null 的类型</value>
  </data>
  <data name="ParameterHasNoMatchingParamTagInTheXMLCommentForButOtherParametersDoMessage" xml:space="preserve">
    <value>形参 '{0}' 在{1}的 XML 注释中没有匹配的 param 标记(但其他形参有)</value>
  </data>
  <data name="PossibleNullReferenceAssignmentMessage" xml:space="preserve">
    <value>可能的 null 引用赋值</value>
  </data>
  <data name="DuplicateAnonymousTypePropertyNameMessage" xml:space="preserve">
    <value>重复的匿名类型属性名称 '{0}'</value>
  </data>
  <data name="ExpressionTreeMayNotContainExpandedParamsCollection_Text" xml:space="preserve">
    <value>表达式树不能包含展开形式的非数组 params 集合形参</value>
  </data>
  <data name="ModuleInitializerMethodMustBeStaticMustHaveNoParametersAndMustReturnvoidMessage" xml:space="preserve">
    <value>模块初始值设定项方法“{0}”必须是静态的，不能有任何参数，并且必须返回 "void"</value>
  </data>
  <data name="ReplaceWithPrimaryConstructorParameterMessage" xml:space="preserve">
    <value>替换为主构造函数形参</value>
  </data>
  <data name="ConvertIfStatementToSwitchStatementMessage" xml:space="preserve">
    <value>将 '{0}' 语句转换为 '{1}' 表达式</value>
  </data>
  <data name="TypeParameterSameNameAsExtensionReceiverParameterErrorMessage" xml:space="preserve">
    <value>类型形参 '{0}' 与扩展形参同名</value>
  </data>
  <data name="TheswitchExpressionDoesNotHandleSomeNullInputsItIsNotExhaustiveForExampleThePatternIsNotCoveredHoweverAPatternWithAwhenClauseMightSuccessfullyMatchThisValueMessage" xml:space="preserve">
    <value>'switch' 表达式不处理某些 null 输入(它不是详尽的)。例如，不涵盖模式 '{0}'。但是，具有 'when' 子句的模式可能与此值成功匹配。</value>
  </data>
  <data name="PossibleSystemInvalidOperationExceptionMessage" xml:space="preserve">
    <value>可能的 '{0}.{1}'</value>
  </data>
  <data name="MethodsStaticMethod_RiderPresentableName" xml:space="preserve">
    <value>方法//static 方法</value>
  </data>
  <data name="UserDefinedConversionToSystemObjectMessage" xml:space="preserve">
    <value>到 System.Object 的用户定义转换</value>
  </data>
  <data name="InputSafe_Text" xml:space="preserve">
    <value>输入安全</value>
  </data>
  <data name="OperatorisTypeOfIsCanBeUsed" xml:space="preserve">
    <value>可以使用 'is'/'Type Of ... Is ...' 运算符</value>
  </data>
  <data name="WinRTCannotBeVirtualMessage" xml:space="preserve">
    <value>WinRT {0}不能为 virtual</value>
  </data>
  <data name="ThereIsBaseMemberThatHasTheSameNullnessAnnotation" xml:space="preserve">
    <value>存在具有相同的为 null 性注解的基成员</value>
  </data>
  <data name="AsyncVoidEventHandlerMethodTitle" xml:space="preserve">
    <value>避免将 'async' 用于带有 'void' 返回值类型和 'System.EventArgs' 类型形参的方法和函数</value>
  </data>
  <data name="SimilarAnonymousTypeDetectedNearby" xml:space="preserve">
    <value>附近检测到类似的匿名类型</value>
  </data>
  <data name="ActualShiftCountEqualsZeroLeftOperandWillRemainUnchangedMessage" xml:space="preserve">
    <value>实际位移计数等于零。左操作数将保持不变。</value>
  </data>
  <data name="AlignmentValueHasAMagnitudeGreaterThanAndMayResultInALargeFormattedStringMessage" xml:space="preserve">
    <value>对齐值 {0} 具有大于 {1} 的度量值，可能产生较大的格式化字符串</value>
  </data>
  <data name="StructIsReadonly_Text" xml:space="preserve">
    <value>结构为只读</value>
  </data>
  <data name="WinRTParametersOfArrayTypeMustBeAnnotatedWithEitherReadOnlyArrayAttributeOrWriteOnlyArrayAttributeAttributeMessage" xml:space="preserve">
    <value>必须使用 'ReadOnlyArrayAttribute' 或 'WriteOnlyArrayAttribute' 特性注解数组类型的 WinRT 形参</value>
  </data>
  <data name="CompilerWarning_CS1066_Title" xml:space="preserve">
    <value>指定的默认值将不起任何作用，因为它适用于不允许可选参数的上下文中使用的成员</value>
  </data>
  <data name="InterfaceMember_DoesnTHaveAMostSpecific_Text" xml:space="preserve">
    <value>接口成员 '{0}' 没有最具体的实现。'{1}' 和 '{2}' 都不是最具体的。</value>
  </data>
  <data name="CannotUseBaseTypeConstructorCallSyntaxMessage" xml:space="preserve">
    <value>{0}不能使用基类型构造函数调用语法</value>
  </data>
  <data name="CSharpFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_empty_braces" xml:space="preserve">
    <value>空大括号周围</value>
  </data>
  <data name="_OfThe_IsAlready__Text" xml:space="preserve">
    <value>{1}的{0}已为{2}</value>
  </data>
  <data name="ValueAssignedToALocalVariableOrParameterIsNotUsedInAnyExecutionPath" xml:space="preserve">
    <value>赋给局部变量或形参的值未在任何执行路径中使用</value>
  </data>
  <data name="TypeNameExpectedButNameFoundMessage" xml:space="preserve">
    <value>应为类型名称，但实际为{0}名称{1}</value>
  </data>
  <data name="WhenTypeIsEvident_Caption" xml:space="preserve">
    <value>当类型明显时</value>
  </data>
  <data name="OperatorisCanBeUsedMessage" xml:space="preserve">
    <value>可以使用运算符 'is'</value>
  </data>
  <data name="InterceptorCannotUseUnmanagedCallersOnlyMessage" xml:space="preserve">
    <value>拦截器不能标记为 'UnmanagedCallersOnlyAttribute'</value>
  </data>
  <data name="LineBreaksAreNotAllowedInsideNonVerbatimStringInterpolationMessage" xml:space="preserve">
    <value>非逐字字符串内插中不允许换行</value>
  </data>
  <data name="NamespaceWithPublicTypesShouldStartWithCommonPrefixMessage" xml:space="preserve">
    <value>具有 public 类型的命名空间应以公共前缀 '{0}' 开头</value>
  </data>
  <data name="RedundantElseBlockMessage" xml:space="preserve">
    <value>冗余的 'else' 块</value>
  </data>
  <data name="CannotTakeTheAddressOfBecauseItIsReadOnlyMessage" xml:space="preserve">
    <value>不能获取{0}的地址，因为它是只读的</value>
  </data>
  <data name="TheBodyOfCannotBeAnIteratorBlockBecauseIsNotAnInterfaceTypeMessage" xml:space="preserve">
    <value>'{0}' 的主体不能为迭代器块，因为 '{1}' 不是{2}接口类型</value>
  </data>
  <data name="BaseMemberHasparamsParameterButOverriderHasnt5" xml:space="preserve">
    <value>基成员具有 'params' 形参，但强制替代项没有</value>
  </data>
  <data name="UseExpressionOrBlockBody" xml:space="preserve">
    <value>使用表达式或块主体</value>
  </data>
  <data name="RedundantMethodOverload" xml:space="preserve">
    <value>冗余的方法重载</value>
  </data>
  <data name="ExplicitDelegateCreationExpressionIsRedundant7" xml:space="preserve">
    <value>显式委托创建表达式冗余</value>
  </data>
  <data name="TypesInterface_RiderPresentableName" xml:space="preserve">
    <value>类型//接口</value>
  </data>
  <data name="WithElementNotSupportedForTypeMessage" xml:space="preserve">
    <value>'{0}' 类型不支持集合实参</value>
  </data>
  <data name="CSharp14OverloadResolutionWithSpanBreakingChangeDescription" xml:space="preserve">
    <value>C# 14 在带有跨度形参的重载解析中的重大变化。请参阅&lt;a href='https://learn.microsoft.com/en-us/dotnet/core/compatibility/core-libraries/10.0/csharp-overload-resolution'&gt;详细信息&lt;/a&gt;。</value>
  </data>
  <data name="CannotResolveCollectionExpressionDefaultConstructorMessage" xml:space="preserve">
    <value>'{0}' 不包含采用 0 个实参的构造函数</value>
  </data>
  <data name="TheFirstParameterOfTheExtensionMethodMustBeAValueTypeMessage" xml:space="preserve">
    <value>'{0}' 扩展方法的第一个形参必须为值类型</value>
  </data>
  <data name="UseC90OrGreaterToIgnoreVarianceOfType_Text" xml:space="preserve">
    <value>使用 C# 9.0 或更高版本可以忽略 static 接口成员中类型形参的差异。</value>
  </data>
  <data name="UseCancellationTokenMessage" xml:space="preserve">
    <value>使用取消令牌</value>
  </data>
  <data name="CannotUseInThisContextMessage" xml:space="preserve">
    <value>不能在此上下文中使用 '{0}'</value>
  </data>
  <data name="ParameterIsAnArgumentToTheInterpolatedStringHandlerConversionOnParameterButTheCorrespondingArgumentIsSpecifiedAfterTheInterpolatedStringExpressionReorderTheArgumentsToMoveBeforeMessage" xml:space="preserve">
    <value>形参 '{0}' 是形参 '{1}' 上的内插字符串处理程序转换的实参，但在内插字符串表达式之后指定了相应的实参。请重新排列实参，将 '{0}' 移动到 '{1}' 之前。</value>
  </data>
  <data name="CodeCleanupTask_CSUseAutoProperty" xml:space="preserve">
    <value>如果可能，使用自动属性</value>
  </data>
  <data name="CSharpFormatterHighlightingProvider_InternalConfigurableSeverityItems_Incorrect_indent_size" xml:space="preserve">
    <value>缩进大小不正确</value>
  </data>
  <data name="CompilerWarning_CS8021_Title" xml:space="preserve">
    <value>找不到 RuntimeMetadataVersion 的值</value>
  </data>
  <data name="sOfTypeCannotBeDeclaredInAsyncsMessage" xml:space="preserve">
    <value>不能在 async {2}中声明'{1}'类型的{0}</value>
  </data>
  <data name="TheExpressionIsUsedInSeveralLockStatementsWithInconsistentExecutionOrderFormingACycleThisMightLeadToAPossibleDeadlockInAMultiThreadedExecution" xml:space="preserve">
    <value>在多条执行顺序不一致的 lock 语句中使用了该表达式，构成循环。这可能导致多线程执行中出现死锁。</value>
  </data>
  <data name="PossibleLocalVariableEscapeWarningMessage" xml:space="preserve">
    <value>在此上下文中使用{0} '{1}' 可能会在声明作用域以外公开引用的变量</value>
  </data>
  <data name="ConvertToExtensionBlockDescription" xml:space="preserve">
    <value>将经典扩展方法转换为 C# 14 扩展块</value>
  </data>
  <data name="CanSimplifyDictionaryLookupWithTryAddTitle" xml:space="preserve">
    <value>可以使用 'TryAdd' 简化字典查找</value>
  </data>
  <data name="InconsistentAccessibilityBaseIsLessAccessibleMessage" xml:space="preserve">
    <value>可访问性不一致: 基{0} '{1}' 的可访问性更低</value>
  </data>
  <data name="RedundantWithCancellationTitle" xml:space="preserve">
    <value>冗余的 'WithCancellation()' 调用</value>
  </data>
  <data name="InitializingByDefaultValueIsRedundantMessage" xml:space="preserve">
    <value>使用默认值初始化{0}冗余</value>
  </data>
  <data name="PrivateCannotBePolymorphicMessage" xml:space="preserve">
    <value>private {0}不能为多态</value>
  </data>
  <data name="UseOfnullIsNotValidInThisContextMessage" xml:space="preserve">
    <value>'null' 的使用在此上下文中无效</value>
  </data>
  <data name="AnonymousMethodsLambdaExpressionsLocalFunctionsAndQueryExpressionsInsideStructsCannotAccessInstanceMembersOfthisConsiderCopyingthisToALocalVariableOutsideTheClosureAndUsingTheLocalInsteadMessage" xml:space="preserve">
    <value>结构中的匿名方法、lambda 表达式、局部函数和查询表达式不能访问 'this' 的实例成员。请考虑将 'this' 复制到闭包以外的局部变量，并改用该局部变量。</value>
  </data>
  <data name="ParameterInBaseHasDefaultValueMessage" xml:space="preserve">
    <value>基{1} '{2}' 中的形参{0}具有默认值</value>
  </data>
  <data name="ArrayInitializersCanOnlyBeUsedInAVariableOrFieldInitializerTryUsingANewExpressionInsteadMessage" xml:space="preserve">
    <value>数组初始值设定项只能在变量或字段初始值设定项中使用。请尝试改用 new 表达式。</value>
  </data>
  <data name="CannotUseVoidAndRefTogetherOnLambdaExpressionMessage" xml:space="preserve">
    <value>返回引用的 lambda 表达式不能为 'void'</value>
  </data>
  <data name="PossiblyImpureStructMethodCalledOnReadonlyVariableStructValueAlwaysCopiedBeforeInvocationMessage" xml:space="preserve">
    <value>在只读变量中调用可能不纯的结构方法: 结构值始终在调用前复制</value>
  </data>
  <data name="ExtractCommonPropertyPatternTitle" xml:space="preserve">
    <value>提取通用属性模式</value>
  </data>
  <data name="CannotConvertValueType_ToIterationValueType_Text" xml:space="preserve">
    <value>不能将值类型 '{0}' 转换为迭代值类型 '{1}'</value>
  </data>
  <data name="PreferTrailingCommasWhenTheLastElement_Caption" xml:space="preserve">
    <value>当最后一个元素后面没有新行时，首选尾随逗号</value>
  </data>
  <data name="MergeSequentialNegatedNullPatternValueChecksIntoSingleLogicalOrAndPatternCheck" xml:space="preserve">
    <value>将顺序求反的 null/模式/值检查合并到单个逻辑 'or'/'and' 模式检查中</value>
  </data>
  <data name="PrivateFieldCanBeConvertedToLocalVariable" xml:space="preserve">
    <value>private 字段可以转换为局部变量</value>
  </data>
  <data name="ReturnValueOfTaskWithMustDisposeAnnotatedMethodIsNotDisposedMessage" xml:space="preserve">
    <value>此任务的结果值永远不会被处置</value>
  </data>
  <data name="AtLeastOneParameterShouldBeMessage" xml:space="preserve">
    <value>至少有一个形参应为 '{0}'</value>
  </data>
  <data name="SomeValuesOfTheEnumAreNotProcessedInsideSwitchExpressionAndFallIntoDefaultArmThisMightIndicateUnintentionalHandlingOfAllEnumValuesAddedAfterTheSwitchWasIntroducedConsiderHandlingMissingEnumValuesExplicitly" xml:space="preserve">
    <value>枚举的某些值未在 switch 表达式内处理，并且位于 default arm 中。这可能表明在引入 switch 后意外处理了所有添加的枚举值，请考虑显式处理缺少的枚举值</value>
  </data>
  <data name="UseUtf8StringLiteralForArrayMessage" xml:space="preserve">
    <value>字节数组可被转换为 UTF-8 字符串字面量</value>
  </data>
  <data name="ArgExpectedInMessage" xml:space="preserve">
    <value>实参 {0} 应与 'in' 关键字一起传递</value>
  </data>
  <data name="AnExpressionTreeMayNotContainASwitchExpressionMessage" xml:space="preserve">
    <value>表达式树不能包含 switch 表达式</value>
  </data>
  <data name="ConvertToMethodGroupMessage" xml:space="preserve">
    <value>转换为方法组</value>
  </data>
  <data name="ProblemInContractAnnotationDefinition" xml:space="preserve">
    <value>协定注解定义中存在问题</value>
  </data>
  <data name="CannotConvertNullToTypeParameterBecauseItCouldBeAValueTypeConsiderUsingdefaultTInsteadMessage" xml:space="preserve">
    <value>不能将 null 转换为类型形参 '{0}'，因为它可能是值类型。请考虑改用 'default(T)'。</value>
  </data>
  <data name="CompilerWarning_CS8670_Title" xml:space="preserve">
    <value>对象或集合初始值设定项会隐式解引用可能为 null 的成员。</value>
  </data>
  <data name="PreferUsingNamedPositionalArgumentWhenstringLiteralValueIsPassed" xml:space="preserve">
    <value>传递 'string' 字面量值时，首选使用命名/位置实参</value>
  </data>
  <data name="NotDisposedResourceIsReturnedTitle" xml:space="preserve">
    <value>返回值应被处置，但方法或函数未使用 [MustDisposeResource] 注解</value>
  </data>
  <data name="RefReturnStructThisOrInstanceFieldWarningMessage" xml:space="preserve">
    <value>结构成员通过引用返回 'this' 或其他实例成员</value>
  </data>
  <data name="Field_ProducedWithMustDisposeAnnotatedMethodIsNotDisposedMessage" xml:space="preserve">
    <value>字段 '{0}' 从未被处置</value>
  </data>
  <data name="TheParameterHasTheSameDefaultValueMessage" xml:space="preserve">
    <value>形参 '{0}' 具有相同的默认值</value>
  </data>
  <data name="RedundantEmptyFinallyBlockMessage" xml:space="preserve">
    <value>冗余的空 finally 块</value>
  </data>
  <data name="RefAssignReturnOnlyMessage" xml:space="preserve">
    <value>不能将 '{0}' 引用赋给 '{1}' ，因为 '{2}' 只能通过 return 语句转义当前方法</value>
  </data>
  <data name="NonAbstractAndNonExternMethodMustDeclareABodyMessage" xml:space="preserve">
    <value>非 abstract 和非 extern 方法必须声明主体</value>
  </data>
  <data name="AccessToAStaticMemberOfATypeViaADerivedType4" xml:space="preserve">
    <value>通过派生类型访问某一类型的 static 成员</value>
  </data>
  <data name="PointerTypesAreNotAllowedInWinRTPublicAPIMessage" xml:space="preserve">
    <value>WinRT 公开 API 中不允许使用指针类型</value>
  </data>
  <data name="UnableToIncludeXMLFragmentMessage" xml:space="preserve">
    <value>无法包含 XML 片段: {0}</value>
  </data>
  <data name="QualifierCanBeSafelyAddedRemovedWithoutChangingCodeSemantics" xml:space="preserve">
    <value>可以安全地添加/移除限定符而不更改代码语义</value>
  </data>
  <data name="ThedefaultConstraintIsValidOnOverrideAndExplicitInterfaceImplementationMethodsOnlyMessage" xml:space="preserve">
    <value>'default' 约束仅对重写和显式接口实现方法有效</value>
  </data>
  <data name="CannotInferTheTypeOfImplicitlyTypedDiscardMessage" xml:space="preserve">
    <value>无法推断隐式类型放弃的类型</value>
  </data>
  <data name="ReplaceSwitchStatementWithSwitchExpression" xml:space="preserve">
    <value>将 'switch' 语句替换为 'switch' 表达式</value>
  </data>
  <data name="ClassIsDeclaredAspartialButHasOnlySinglePart" xml:space="preserve">
    <value>类被声明为 'partial'，但只有一个部分</value>
  </data>
  <data name="RedundantBooleanComparison" xml:space="preserve">
    <value>冗余的布尔比较</value>
  </data>
  <data name="QualifierBaseIsRedundantMessage" xml:space="preserve">
    <value>限定符 '{0}.' 冗余</value>
  </data>
  <data name="ExpressionTreeWithExtensionPropertyAccessErrorMessage" xml:space="preserve">
    <value>表达式树可能不包含扩展属性访问</value>
  </data>
  <data name="PossibleSystemInvalidCastExceptionInForeachLoop" xml:space="preserve">
    <value>在 foreach 循环中可能出现 'System.InvalidCastException'</value>
  </data>
  <data name="AGlobalUsingDirectiveCannotBeUsedInANamespaceDeclarationMessage" xml:space="preserve">
    <value>不能在命名空间声明中使用 global using 指令</value>
  </data>
  <data name="withExpressionModifiesAllExistingTupleComponentsMessage" xml:space="preserve">
    <value>'with' 表达式会修改所有现有的元组组件</value>
  </data>
  <data name="MergeSequentialNullPatternChecksIntoSingleRecursiveLogicalPatternCheck" xml:space="preserve">
    <value>将顺序 null/模式检查合并到单个递归/逻辑模式检查中</value>
  </data>
  <data name="RecordEqualityContractPropertyMustHaveAGetAccessorMessage" xml:space="preserve">
    <value>记录等同性合同属性“{0}”必须具有 get 访问器</value>
  </data>
  <data name="RedundantcaseLabel" xml:space="preserve">
    <value>冗余的 'case' 标签</value>
  </data>
  <data name="HeuristicallyUnreachableCode" xml:space="preserve">
    <value>启发式不可到达的代码</value>
  </data>
  <data name="DuplicatedSequentialIfBodiesTitle" xml:space="preserve">
    <value>重复的连续 'if' 分支</value>
  </data>
  <data name="TheReceiverTypeIsNotAValidRecordTypeMessage" xml:space="preserve">
    <value>接收器类型 '{0}' 不是有效的记录类型</value>
  </data>
  <data name="BackingFieldIsAssignedButNeverUsed" xml:space="preserve">
    <value>支持字段已被赋值，但从未被使用</value>
  </data>
  <data name="CollectionInitializerElementCannotBeEmptyMessage" xml:space="preserve">
    <value>集合初始值设定项元素不能为空</value>
  </data>
  <data name="OverrideMustHaveRequiredMessage" xml:space="preserve">
    <value>'{0}' 必须为必需，因为它会重写必需成员 '{1}'</value>
  </data>
  <data name="MultipleWithTheSameNumberOfParametersCannotBeMarkedWithDefaultOverloadAttributeMessage" xml:space="preserve">
    <value>不能使用 'DefaultOverloadAttribute' 标记具有相同数量形参的多个{0}</value>
  </data>
  <data name="ConstructorCannotCallItselfThroughAnotherConstructorMessage" xml:space="preserve">
    <value>构造函数不能通过另一个构造函数调用自身</value>
  </data>
  <data name="refKeywordMustImmediatelyPrecedeTheTypeMessage" xml:space="preserve">
    <value>'ref' 关键字必须紧接在类型之前</value>
  </data>
  <data name="ShowOnDeclarations" xml:space="preserve">
    <value>在声明上显示</value>
  </data>
  <data name="InputAndOutputSafe_Text" xml:space="preserve">
    <value>输入和输出安全</value>
  </data>
  <data name="SuggestToReplaceEmptyCollectionObjectDescription" xml:space="preserve">
    <value>建议为 'new List&lt;T&gt;()'、'Array.Empty&lt;T&gt;()'、'Enumerable.Empty&lt;T&gt;()'、'ImmutableArray.Create&lt;T&gt;()' 之类的情况使用空集合表达式 '[]'。</value>
  </data>
  <data name="RedundantOverrideMessage" xml:space="preserve">
    <value>冗余的{0}重写</value>
  </data>
  <data name="MergeStringLiteralWithContainingInterpolationMessage" xml:space="preserve">
    <value>将字符串字面量与包含内插合并</value>
  </data>
  <data name="RefReturnNonRefVariableMemberWarningMessage" xml:space="preserve">
    <value>这会通过引用返回{0} '{1}' 的成员，但它不是 ref 局部变量</value>
  </data>
  <data name="OverrideCannotBeMarkedAsNewMessage" xml:space="preserve">
    <value>重写{0}不能被标记为 new</value>
  </data>
  <data name="ReplaceAutoPropertyWithComputedProperty" xml:space="preserve">
    <value>将自动属性替换为计算所得属性</value>
  </data>
  <data name="PrimaryConstructorCannotHaveParametersMessage" xml:space="preserve">
    <value>{0}主构造函数不能具有 '{1}' 形参</value>
  </data>
  <data name="ACopyConstructorMustBePublicOrProtectedBecauseTheRecordIsNotSealedMessage" xml:space="preserve">
    <value>复制构造函数“{0}”必须是公共的或受保护的，因为该记录未密封</value>
  </data>
  <data name="UseNullCheckInsteadOfATypeCheckSucceedingOnAnyNotNullValue" xml:space="preserve">
    <value>在任何非 null 值之后使用 null 检查而非类型检查</value>
  </data>
  <data name="TheNameDoesNotIdentifyTupleElementMessage" xml:space="preserve">
    <value>名称 '{0}' 不标识元组元素 '{1}'</value>
  </data>
  <data name="InconsistentModifiersStyleMessage" xml:space="preserve">
    <value>修饰符样式不一致: {0}</value>
  </data>
  <data name="CannotApplyOperatorToOperandsOfTypeAndCandidatesAreMessage" xml:space="preserve">
    <value>不能将运算符 '{0}' 应用于 '{1}' 和 '{2}' 类型的操作数。{3}候选项为: {4}</value>
  </data>
  <data name="AsyncVoidThrowExceptionTitle" xml:space="preserve">
    <value>请勿在 'async void' 方法和函数中重新抛出异常</value>
  </data>
  <data name="PossiblyImpureStructInstanceMethodOrthisRefExtensionMethodIsCalledOnReadonlyFieldInParameterRefReadonlyReturnStructValueAlwaysCopiedBeforeInvocation" xml:space="preserve">
    <value>在只读字段/in 形参/ref 只读返回中调用可能不纯的结构实例方法或 'this ref' 扩展方法: 结构值始终在调用前复制</value>
  </data>
  <data name="TypeParameterNameDiffersFromDeclaredInOtherPartsMessage" xml:space="preserve">
    <value>类型形参名称与其他部分中声明的不同</value>
  </data>
  <data name="TheArgumentTypeDoesntMatchParameterTypeMessage" xml:space="preserve">
    <value>'{0}' 实参类型与形参类型不匹配</value>
  </data>
  <data name="CqrsDebug" xml:space="preserve">
    <value>CqrsDebug</value>
  </data>
  <data name="SimplifyNegatedPattern" xml:space="preserve">
    <value>简化求反模式</value>
  </data>
  <data name="LocalVariable_ProducedWithMustDisposeAnnotatedMethodIsNotDisposedMessage" xml:space="preserve">
    <value>局部变量 '{0}' 从未被处置</value>
  </data>
  <data name="MemberInitializedValueIgnored" xml:space="preserve">
    <value>忽略了成员初始值设定项值</value>
  </data>
  <data name="ConvertToReturnStatementMessage" xml:space="preserve">
    <value>转换为 '{0}' 语句</value>
  </data>
  <data name="UnscopedScopedParameterMessage" xml:space="preserve">
    <value>UnscopedRefAttribute 不能应用于具有 'scoped' 修饰符的形参</value>
  </data>
  <data name="ExpressionIsAlwaysMessage" xml:space="preserve">
    <value>表达式始终为 {0}{1}</value>
  </data>
  <data name="CLRTypeNamesAndCorrespondingCKeyword_DescriptionText" xml:space="preserve">
    <value>CLR 类型名称和对应的 C# 关键字可互换，不影响代码语义</value>
  </data>
  <data name="AnonymousTypeWhichDiffersOnlyInPropertyOrderIsDetectedNearby" xml:space="preserve">
    <value>附近检测到仅在属性顺序上不同的匿名类型</value>
  </data>
  <data name="APreviousCatchClauseAlreadyCatchesAllExceptionsAllNonExceptionsThrownWillBeWrappedInASystemRuntimeCompilerServicesRuntimeWrappedExceptionMessage" xml:space="preserve">
    <value>上一个 catch 子句已捕获所有异常。引发的所有非异常均被包装在 System.Runtime.CompilerServices.RuntimeWrappedException 中。</value>
  </data>
  <data name="MultipleNullableAttributesUsage" xml:space="preserve">
    <value>多个可以为 null 的特性用法</value>
  </data>
  <data name="ForeachLoopCanBeConvertedIntoLINQExpressionButAnotherGetEnumeratorMethodWillBeUsed" xml:space="preserve">
    <value>foreach 循环可以转换为 LINQ 表达式，但将使用另一个 'GetEnumerator' 方法</value>
  </data>
  <data name="LockObjectsInvolvedInTheCycle_Text" xml:space="preserve">
    <value>循环中涉及的锁定对象: {0}</value>
  </data>
  <data name="CallingConventionIsNotRecognizedMessage" xml:space="preserve">
    <value>无法识别调用惯例 '{0}'</value>
  </data>
  <data name="CompilerWarning_CS9086_Title" xml:space="preserve">
    <value>ref 条件运算符的分支引用声明作用域不兼容的变量</value>
  </data>
  <data name="ReplaceAutoPropertyWithComputedPropertyToAvoidStoringTrivialStateInEveryTypeInstance" xml:space="preserve">
    <value>将自动属性替换为计算所得属性，以避免在每个类型实例中存储普通状态</value>
  </data>
  <data name="UsingVariable_Text" xml:space="preserve">
    <value>using 变量</value>
  </data>
  <data name="RefReadonlyNotVariableMessage" xml:space="preserve">
    <value>实参 {0} 应为变量，因为它会被传递给 'ref readonly' 形参</value>
  </data>
  <data name="LambdaExpressionAnonymousMethodPassedToParameterAnnotatedByRequireStaticDelegateAttributeShouldNotHaveCapturesOfTheContainingContextLocalVariablesLocalFunctionsThisReferenceToAvoidHeapAllocations" xml:space="preserve">
    <value>传递给由 '[RequireStaticDelegate]' 特性注解的形参的 lambda 表达式/匿名方法不应捕获包含上下文(局部变量、局部函数、'this' 引用)，以避免堆分配</value>
  </data>
  <data name="EmptywithExpressionIsRedundant" xml:space="preserve">
    <value>空 'with' 表达式冗余</value>
  </data>
  <data name="MustBeStaticToAvoidAllocationsMessage" xml:space="preserve">
    <value>{0}必须为 '{1}' 以避免分配</value>
  </data>
  <data name="CompilerWarning_CS8656_Title" xml:space="preserve">
    <value>从 "readonly" 成员调用非 readonly 成员将产生一个隐式副本。</value>
  </data>
  <data name="CompilerWarning_CS1571_Title" xml:space="preserve">
    <value>XML 注释中有重复的 param 标记</value>
  </data>
  <data name="ChangeFieldTypeToSystemThreadingLockTitle" xml:space="preserve">
    <value>将锁定字段类型更改为 'System.Threading.Lock'</value>
  </data>
  <data name="CaseIsHeuristicallyUnreachableMessage" xml:space="preserve">
    <value>case 为启发式无法访问</value>
  </data>
  <data name="MethodIsMarkedAsOneWayOperationAndThereforeCouldntReturnValuesMessage" xml:space="preserve">
    <value>方法 '{0}' 被标记为单向运算，因此无法返回值</value>
  </data>
  <data name="CanReplaceCastWithTypeArgumentTitle" xml:space="preserve">
    <value>转换表达式可被替换为显式类型实参</value>
  </data>
  <data name="RemoveConstructorInvocation_Text" xml:space="preserve">
    <value>移除构造函数调用</value>
  </data>
  <data name="ParameterWithparamsModifierMustHaveAValidCollectionTypeMessage" xml:space="preserve">
    <value>带有 'params' 修饰符的形参必须具有有效的集合类型</value>
  </data>
  <data name="DefaultParameterValueAttributeShouldBeUsedInConjunctionWithOptionalAttribute2" xml:space="preserve">
    <value>'DefaultParameterValueAttribute' 应与 'OptionalAttribute' 结合使用</value>
  </data>
  <data name="CompilerWarning_CS0809_Title" xml:space="preserve">
    <value>过时成员重写未过时成员</value>
  </data>
  <data name="RequiredNotInitializedInAnyExecutionPathMessage" xml:space="preserve">
    <value>必需的{0} '{1}' 未在任何执行路径中初始化</value>
  </data>
  <data name="UseSimpleTypesMessage" xml:space="preserve">
    <value>使用{0}(简单类型)</value>
  </data>
  <data name="LeftOperandOfTheOperatorShouldBeOfReferenceOrNullableTypeMessage" xml:space="preserve">
    <value>'??' 运算符的左操作数应为引用或可以为 null 的类型</value>
  </data>
  <data name="RefReturnOnlyParameterWarningMessage" xml:space="preserve">
    <value>这会经 ref 形参通过引用返回{0} '{1}'；但它只能在 return 语句中安全返回</value>
  </data>
  <data name="OmitVarKeywordForDiscardsWhenPossible_Caption" xml:space="preserve">
    <value>尽可能省略弃元的 'var' 关键字</value>
  </data>
  <data name="ModifierCannotBeCombinedWithMessage" xml:space="preserve">
    <value>修饰符 '{0}' 不能与 '{1}' 相结合</value>
  </data>
  <data name="WinRTFieldCannotBeOfTypeEachFieldInAWinRTStructureCanOnlyBeUIntIntUIntIntUIntIntUIntSingleDoubleBooleanStringEnumCharOrItselfAStructureMessage" xml:space="preserve">
    <value>WinRT 字段不能为 '{0}' 类型。WinRT 结构中的每个字段只能为 UInt8、Int16、UInt16、Int32、UInt32、Int64、UInt64、Single、Double、Boolean、String、Enum、Char 或本身就是结构.</value>
  </data>
  <data name="TypeParameterSameNameAsExtensionTypeParameterErrorMessage" xml:space="preserve">
    <value>类型形参 '{0}' 与扩展类型形参同名</value>
  </data>
  <data name="CSharp14OverloadResolutionWithSpanBreakingChangeMessage" xml:space="preserve">
    <value>由于带跨度的重载解析发生了重大变化，C# 14 中对此调用的解析也发生了变化。</value>
  </data>
  <data name="RefAssignValEscapeWiderMessage" xml:space="preserve">
    <value>不能将 '{1}' 引用赋给 '{0}'，因为 '{1}' 的值转义作用域比 '{0}' 宽，允许通过转义作用域比 '{1}' 更窄的值的 '{0}' 进行赋值</value>
  </data>
  <data name="InvalidNamespaceAliasMessage" xml:space="preserve">
    <value>命名空间别名无效</value>
  </data>
  <data name="ParamsExtensionReceiverParameterErrorMessage" xml:space="preserve">
    <value>扩展的接收器形参不能有 'params' 修饰符</value>
  </data>
  <data name="MustHaveSetToMatchOverriddenMessage" xml:space="preserve">
    <value>'{0}' 必须具有 'set' 访问器而不是 'init' 才能匹配被重写的{1} '{2}'</value>
  </data>
  <data name="EmptyExtensionBlockTitle" xml:space="preserve">
    <value>空 extension 块</value>
  </data>
  <data name="UsePatternMatchingMessage" xml:space="preserve">
    <value>使用模式匹配</value>
  </data>
  <data name="Iterator_Text" xml:space="preserve">
    <value>迭代器</value>
  </data>
  <data name="AMethodWithVarargCannotBeGenericBeInAGenericTypeOrHaveAParamsParameterMessage" xml:space="preserve">
    <value>带有 vararg 的方法不能是泛型，不能属于泛型类型，也不能具有 params 参数</value>
  </data>
  <data name="AtLeastOneTopLevelStatementMustBeNonEmptyMessage" xml:space="preserve">
    <value>至少有一条顶层语句必须为非空</value>
  </data>
  <data name="ImplicitlyTypedLocalVariableMustBeInitializedMessage" xml:space="preserve">
    <value>隐式类型化局部变量必须初始化</value>
  </data>
  <data name="CallToBaseMemberWithImplicitDefaultParameters" xml:space="preserve">
    <value>使用隐式默认形参调用基成员</value>
  </data>
  <data name="AnExpressionTreeMayNotContainAnOutArgumentVariableDeclarationMessage" xml:space="preserve">
    <value>表达式树不能包含 out 实参变量声明</value>
  </data>
  <data name="CanSimplifyDictionaryLookupWithTryGetValueMessage" xml:space="preserve">
    <value>可以使用 'TryGetValue' 简化字典查找</value>
  </data>
  <data name="EventMustHaveBothAddAndRemoveAccessorsMessage" xml:space="preserve">
    <value>事件必须同时具有 add 和 remove 访问器</value>
  </data>
  <data name="OverridesThereAreMultipleOverrideCandidatesAtRunTimeItIsImplementationDependentWhichMethodWillBeCalledMessage" xml:space="preserve">
    <value>{0}重写 '{1}'。在运行时有许多重写候选项。将调用的方法取决于实现。</value>
  </data>
  <data name="UseFileScopedOrBlockScopedNamespaces_Text" xml:space="preserve">
    <value>使用文件作用域或块作用域的命名空间</value>
  </data>
  <data name="NoDeconstructMethodWithOutParametersFoundForTypeMessage" xml:space="preserve">
    <value>没有为类型 '{0}' 找到具有 {1} 个 out 形参的 'Deconstruct' 方法</value>
  </data>
  <data name="ArrayElementsCannotBeOfStaticClassTypeMessage" xml:space="preserve">
    <value>数组元素不能为 static 类类型 '{0}'</value>
  </data>
  <data name="ThereIsNoDefinedOrderingBetweenFieldsInMultipleDeclarationsOfPartialStruct" xml:space="preserve">
    <value>在分部结构“{0}”的多个声明中的字段之间没有已定义的排序方式。要指定排序方式，所有实例字段必须位于同一声明中。</value>
  </data>
  <data name="EnforceBracesInforeachStatement" xml:space="preserve">
    <value>在 'foreach' 语句中强制使用大括号</value>
  </data>
  <data name="AddExplicitControlFlowJumpBeforeLocalFunctionInterlineHintActionText" xml:space="preserve">
    <value>在局部函数之前添加显式 '{0}'</value>
  </data>
  <data name="CompilerWarning_CS9085_Title" xml:space="preserve">
    <value>此 ref 分配的值的转义范围比目标更窄。</value>
  </data>
  <data name="MisleadingBodyLikeStatementTitle" xml:space="preserve">
    <value>类似于主体的令人混淆的语句</value>
  </data>
  <data name="HeuristicallyUnreachableCaseLabelDueToIntegerAnalysis" xml:space="preserve">
    <value>由于整数分析而启发式无法访问的 case 标签</value>
  </data>
  <data name="PossibleCyclicConstructorCall" xml:space="preserve">
    <value>可能的循环构造函数调用</value>
  </data>
  <data name="KindNameIsImmutable_Text" xml:space="preserve">
    <value>{0} 不可变。</value>
  </data>
  <data name="UsePreferredStyleForTrailingCommaBeforeNewLineInMultilineLists" xml:space="preserve">
    <value>对多行列表中新行前的尾随逗号使用首选样式</value>
  </data>
  <data name="ConvertConstructorToMemberInitializers" xml:space="preserve">
    <value>将构造函数转换为成员初始值设定项</value>
  </data>
  <data name="TypeParameterHidesMessage" xml:space="preserve">
    <value>类型形参 '{0}' 会隐藏{1} '{2}'</value>
  </data>
  <data name="RefVariablesAreNotAllowedInThisContextMessage" xml:space="preserve">
    <value>此上下文中不允许使用 ref 变量</value>
  </data>
  <data name="WhenObjectCreationUsesObjectOrCollectionInitializerEmptyArgumentListIsRedundant" xml:space="preserve">
    <value>当对象创建使用对象或集合初始值设定项时，空实参列表冗余</value>
  </data>
  <data name="TupleTypesUsedAsOperandsOfAnOrOperatorMustHaveTheSameComponentsCountButThisOperatorHasTupleTypesWithComponentsOnTheLeftAndOnTheRightMessage" xml:space="preserve">
    <value>用作 '==' 或 '!=' 运算符的操作数的元组类型必须具有相同的组件计数。但是，此运算符具有左侧带 {0} 个组件，右侧带 {1} 个组件的元组类型。</value>
  </data>
  <data name="CompilerWarning_CS9092_Title" xml:space="preserve">
    <value>这会按引用返回本地成员，但它不是 ref 本地</value>
  </data>
  <data name="AbstractCannotBeVirtualMessage" xml:space="preserve">
    <value>abstract {0}不能为 virtual</value>
  </data>
  <data name="UnusedNullableDirectiveTitle" xml:space="preserve">
    <value>未使用的可以为 null 的指令</value>
  </data>
  <data name="BaseDoesntContainParameterlessConstructorMessage" xml:space="preserve">
    <value>基{0} '{1}' 不包含无形参构造函数</value>
  </data>
  <data name="UsePreferredNamespaceBodyStyle" xml:space="preserve">
    <value>使用首选命名空间主体样式</value>
  </data>
  <data name="CompilerWarning_CS1574_Title" xml:space="preserve">
    <value>XML 注释中有无法解析的 cref 特性</value>
  </data>
  <data name="ReturnTypeIsvoidMessage" xml:space="preserve">
    <value>返回值类型为'void'</value>
  </data>
  <data name="ApplyingContainerNullnessAnnotationToNonContainerTypeIsMeaninglessMessage" xml:space="preserve">
    <value>对非容器类型应用容器为 null 性注解毫无意义</value>
  </data>
  <data name="InParameterWithMustDisposeResourceAttributeTitle" xml:space="preserve">
    <value>输入形参的无意义 [MustDisposeResource] 注解</value>
  </data>
  <data name="TheFieldIsAlwaysAssignedBeforeBeingUsedAndCanBeConvertedToLocalVariableMessage" xml:space="preserve">
    <value>该字段总是在使用前赋值，并且可以转换为局部变量</value>
  </data>
  <data name="ValueParameterIsNotUsed" xml:space="preserve">
    <value>'value' 形参未使用</value>
  </data>
  <data name="AnonymousMethodParameterCannotBeOptionalMessage" xml:space="preserve">
    <value>匿名方法形参不能是可选形参</value>
  </data>
  <data name="IsNotAnAttributeMessage" xml:space="preserve">
    <value>'{0}' 不是特性</value>
  </data>
  <data name="AnExpressionTreeMayNotContainADiscardMessage" xml:space="preserve">
    <value>表达式树不能包含弃元</value>
  </data>
  <data name="NotIdentifierAttributeArgumentMessage" xml:space="preserve">
    <value>“{0}”特性的参数必须是有效的标识符</value>
  </data>
  <data name="GCSuppressFinalizeIsInvokedForTypeWithoutDestructorMessage" xml:space="preserve">
    <value>为不带析构函数的类型调用了 'GC.SuppressFinalize'</value>
  </data>
  <data name="TailRecursiveCallsCanBeReplacedWithLoopForBetterPerformanceAndProtectionFromPossibleStackOverflows" xml:space="preserve">
    <value>尾递归调用可被替换为循环，以获得更好的性能并防止出现可能的堆栈溢出</value>
  </data>
  <data name="ConstructorOrInitOnlySetterOfTheType_Text" xml:space="preserve">
    <value>用于定义字段的类型的构造函数或仅初始化 setter</value>
  </data>
  <data name="CannotInferTheTypeOfImplicitlyTypedDeconstructionVariableMessage" xml:space="preserve">
    <value>不能推断隐式类型化析构变量 '{0}' 的类型</value>
  </data>
  <data name="TypeArgumentSpecificationIsRedundantMessage" xml:space="preserve">
    <value>类型实参规范冗余</value>
  </data>
  <data name="CannotAccessSymbolInTextArgument14" xml:space="preserve">
    <value>不能访问文本实参中的符号</value>
  </data>
  <data name="UseWithExpressionToCopyAnonymousObjectMessage" xml:space="preserve">
    <value>使用 '{0}' 表达式复制匿名对象</value>
  </data>
  <data name="ConvertToPropertyIndexerOrEventWithPreferredBodyStyle" xml:space="preserve">
    <value>转换为具有首选主体样式的属性、索引器或事件</value>
  </data>
  <data name="CompareWithTypesMarkedByCannotApplyEqualityOperatorAttribute" xml:space="preserve">
    <value>使用 'CannotApplyEqualityOperatorAttribute' 标记的类型的值应该使用 'Equals()' 进行比较。</value>
  </data>
  <data name="awaitCannotBeUsedInAnExpressionContainingCallToBecauseItReturnsByReferenceMessage" xml:space="preserve">
    <value>'await' 不能用于包含对 '{0}' 的调用的表达式，因为它通过引用返回</value>
  </data>
  <data name="ModuleInitializerCannotBeAttributedWithUnmanagedCallersOnlyMessage" xml:space="preserve">
    <value>模块初始值设定项不能具有 'UnmanagedCallersOnly' 特性</value>
  </data>
  <data name="InterceptorSignatureMismatchWarningMessage" xml:space="preserve">
    <value>正在使用拦截器 '{1}' 拦截对 '{0}' 的调用，但签名不匹配</value>
  </data>
  <data name="CannotUseLocalVariableInsideMessage" xml:space="preserve">
    <value>不能在{2}内使用 '{0}' 局部变量 '{1}'</value>
  </data>
  <data name="InconsistentAccessibilityReturnTypeIsLessAccessibleThanMessage" xml:space="preserve">
    <value>可访问性不一致: 返回值类型 '{0}' 的可访问性低于{1} '{2}'</value>
  </data>
  <data name="ThreadStaticFieldHasInitializerItIsInvokedOnlyOnceOnTheThreadThatsRunningWhenTheStaticConstructorExecutes" xml:space="preserve">
    <value>线程 static 字段具有一个初始值设定项，它仅在执行 static 构造函数时，在正在运行的线程上调用一次</value>
  </data>
  <data name="EventUnsubscriptionViaAnonymousDelegate" xml:space="preserve">
    <value>通过匿名委托取消订阅事件</value>
  </data>
  <data name="PossiblyMisleadingDefaultValueAttributeUsageToDefineOptionalParameterValueDefaultParameterValueAttributeShouldBeUsedInsteadMessage" xml:space="preserve">
    <value>可能使用误导性 'DefaultValueAttribute' 来定义可选形参值。应改为使用 'DefaultParameterValueAttribute'。</value>
  </data>
  <data name="UseWithExpressionToCopyRecordMessage" xml:space="preserve">
    <value>使用 '{0}' 表达式复制记录</value>
  </data>
  <data name="TestingAgainstFalseCanBeSimplifiedMessage" xml:space="preserve">
    <value>针对 '{0}' 的测试可以简化</value>
  </data>
  <data name="TheExpressionIsUsedInSeveralLockStatements_Text" xml:space="preserve">
    <value>在多条执行顺序不一致的 lock 语句中使用了该表达式，构成循环。</value>
  </data>
  <data name="LocalVariableHidesPrimaryConstructorParameterTitle" xml:space="preserve">
    <value>局部变量隐藏主构造函数形参</value>
  </data>
  <data name="CompilerWarning_CS1717_Title" xml:space="preserve">
    <value>对同一变量进行了赋值</value>
  </data>
  <data name="AutoPropertyCannotBeOfByrefLikeTypeUnlessItIsAnInstanceMemberOfArefStructMessage" xml:space="preserve">
    <value>自动属性不能为类似 byref 的类型 '{0}'，除非它是 'ref' 结构的实例成员</value>
  </data>
  <data name="RedundantobjectToStringCall" xml:space="preserve">
    <value>冗余的 'object.ToString()' 调用</value>
  </data>
  <data name="ConstructorCannotCallItselfMessage" xml:space="preserve">
    <value>构造函数不能调用自身</value>
  </data>
  <data name="FieldCannotBeOfByrefLikeTypeUnlessItIsAnInstanceMemberOfArefStructMessage" xml:space="preserve">
    <value>字段不能为类似 byref 的类型 '{0}'，除非它是 'ref' 结构的实例成员</value>
  </data>
  <data name="UsePreferredStyleForTrailingCommaWhen_Text" xml:space="preserve">
    <value>当最后一个元素后面没有新行时，对尾随逗号使用首选样式</value>
  </data>
  <data name="CompilerWarning_CS0693_Title" xml:space="preserve">
    <value>类型参数与外部类型中的类型参数同名</value>
  </data>
  <data name="ReturnValueOfIteratorIsNotUsed" xml:space="preserve">
    <value>迭代器的返回值未使用</value>
  </data>
  <data name="CompilerWarning_CS9097_Title" xml:space="preserve">
    <value>它会 ref-assign 一个值转义范围大于目标的值，允许通过转义范围更窄的值的目标进行赋值。</value>
  </data>
  <data name="PartialPropertyAccessor_MustBeInitMessage" xml:space="preserve">
    <value>分部{0}访问器 '{1}' 必须为 '{2}' 以匹配定义</value>
  </data>
  <data name="TheTypeArgumentsForMethodCannotBeInferredFromTheQueryMessage" xml:space="preserve">
    <value>不能从查询中推断方法 '{0}' 的类型实参</value>
  </data>
  <data name="AccessorInAbstractCannotDeclareABodyMessage" xml:space="preserve">
    <value>abstract {0}中的访问器不能声明主体</value>
  </data>
  <data name="CompilerWarning_CS0628_Title" xml:space="preserve">
    <value>在密封类型中声明了新的保护成员</value>
  </data>
  <data name="DestinationHasTheSameValueBeforeAssignmentMessage" xml:space="preserve">
    <value>目标在赋值前具有相同的值</value>
  </data>
  <data name="CompilerWarning_CS0684_Title" xml:space="preserve">
    <value>接口标记为 "CoClassAttribute" 而不是 "ComImportAttribute"</value>
  </data>
  <data name="CompilerWarning_CS0661_Title" xml:space="preserve">
    <value>类型定义运算符 == 或运算符 !=，但不重写 Object.GetHashCode()</value>
  </data>
  <data name="initAccessorsCannotBeMarkedreadonlyMarkReadonlyInsteadMessage" xml:space="preserve">
    <value>"init" 访问器不能标记为“只读”。请转而将“{0}”标记为“只读”。</value>
  </data>
  <data name="CommentsDocCommentsComment_RiderPresentableName" xml:space="preserve">
    <value>注释//文档注释//注释</value>
  </data>
  <data name="OfTypeCausesACycleInTheStructLayoutMessage" xml:space="preserve">
    <value>'{2}' 类型的{0} '{1}' 导致结构布局中出现循环</value>
  </data>
  <data name="ExtensionReceiverParameterCannotBeDeclaredAsMessage" xml:space="preserve">
    <value>扩展的接收器形参不能被声明为 '{0}'</value>
  </data>
  <data name="PossibleMultipleEnumerationMessage" xml:space="preserve">
    <value>可能多次枚举</value>
  </data>
  <data name="NamedArgumentsCannotPrecedePositionalInADynamicInvocationMessage" xml:space="preserve">
    <value>在动态调用中，命名实参不能在位置实参之前</value>
  </data>
  <data name="paramsModifierIsAlwaysIgnoredOnOverrides1" xml:space="preserve">
    <value>重写时始终忽略 'params' 修饰符</value>
  </data>
  <data name="CapturedPrimaryConstructorParameterIsMutableMessage" xml:space="preserve">
    <value>主构造函数形参 '{0}' 被实例成员捕获和变异，请考虑改用显式可变字段</value>
  </data>
  <data name="CompilerWarning_CS0279_Title" xml:space="preserve">
    <value>类型不实现集合模式；成员不是公共实例或扩展方法。</value>
  </data>
  <data name="SuspiciousShiftCountForThisTypeOfLeftOperand" xml:space="preserve">
    <value>此类型的左操作数的可疑位移计数</value>
  </data>
  <data name="TheHasNoSetterMessage" xml:space="preserve">
    <value>{0} '{1}' 没有 setter</value>
  </data>
  <data name="MethodGroupToNonDelegateWarningMessage" xml:space="preserve">
    <value>将方法组“{0}”转换为非委托类型“{1}”。是否希望调用此方法?</value>
  </data>
  <data name="EmptyTypeDeclarationCanBeReplacedWithSemicolon" xml:space="preserve">
    <value>空类型声明主体可被替换为分号</value>
  </data>
  <data name="FileScopedNamespaceMustPrecedeAllOtherMembersInAFileMessage" xml:space="preserve">
    <value>文件作用域命名空间必须在文件中的所有其他成员之前</value>
  </data>
  <data name="IncorrectConstantExpectedAnnotationDescription" xml:space="preserve">
    <value>'ConstantExpectedAttribute' 未正确应用于形参</value>
  </data>
  <data name="TheEndIndexIsInterpretedAsLiteralDidYouMeanToUseRangeMessage" xml:space="preserve">
    <value>结束索引被解释为{0}字面量 '{1}'。您是要使用范围 '{2}' 吗?</value>
  </data>
  <data name="RedundantabstractModifier" xml:space="preserve">
    <value>冗余的 'abstract' 修饰符</value>
  </data>
  <data name="TypesTypeParameter_RiderPresentableName" xml:space="preserve">
    <value>类型//类型形参</value>
  </data>
  <data name="PlaceAssignmentExpressionIntoBlockToIndicateTheSideEffect" xml:space="preserve">
    <value>将赋值表达式放入块中以指示副作用</value>
  </data>
  <data name="CompilerWarning_CS0642_Title" xml:space="preserve">
    <value>空语句可能有错误</value>
  </data>
  <data name="CompilerWarning_CS0618_Title" xml:space="preserve">
    <value>类型或成员已过时</value>
  </data>
  <data name="TypeOfIterationVariableDeclaredInforeachStatementIsLessSpecificThanThatWhichCanBeInferredFromTheCollectionTypeBeingIterated" xml:space="preserve">
    <value>'foreach' 语句中声明的迭代变量的类型没有可以从正在迭代的集合类型中推断出的类型具体</value>
  </data>
  <data name="CSharpFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_colon" xml:space="preserve">
    <value>冒号周围</value>
  </data>
  <data name="CSharpFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_comma" xml:space="preserve">
    <value>逗号周围</value>
  </data>
  <data name="OptionalParamMissingValuePlaceholder" xml:space="preserve">
    <value>&lt;缺少&gt;</value>
  </data>
  <data name="CompilerWarning_CS8611_Title" xml:space="preserve">
    <value>参数类型中引用类型的为 Null 性与分部方法声明不匹配。</value>
  </data>
  <data name="TheparamsParameterMustBeASingleDimensionalArrayMessage" xml:space="preserve">
    <value>'params' 形参必须为一维数组</value>
  </data>
  <data name="SuggestForInterfaceTargetTypes" xml:space="preserve">
    <value>当目标类型为集合接口类型时建议</value>
  </data>
  <data name="ConvertIfSimpleTypeNotAnArrayAndDoesNotHaveGenericParameters" xml:space="preserve">
    <value>如果为简单类型(不是数组且没有泛型形参)，则转换</value>
  </data>
  <data name="AValueOfTypeCannotBeUsedAsADefaultParameterForNullableParameterBecauseIsNotASimpleTypeMessage" xml:space="preserve">
    <value>'{0}' 类型的值不能用作可以为 null 的形参 '{1}' 的默认形参，因为 '{0}' 不是简单类型</value>
  </data>
  <data name="CompilerWarning_CS1712_Title" xml:space="preserve">
    <value>类型参数在 XML 注释中没有匹配的 typeparam 标记(但其他类型参数有)</value>
  </data>
  <data name="CodeCleanupTask_CSArrangeQualifiers" xml:space="preserve">
    <value>排列限定符</value>
  </data>
  <data name="ShowOnUsages" xml:space="preserve">
    <value>在用法上显示</value>
  </data>
  <data name="ConstantOutOfExpectedRange_Message" xml:space="preserve">
    <value>实参值 {0} 不符合 {1}..{2} 的形参值范围</value>
  </data>
  <data name="UseArrayEmptyT" xml:space="preserve">
    <value>使用 'Array.Empty&lt;T&gt;()'</value>
  </data>
  <data name="CompilerWarning_CS8424_Title" xml:space="preserve">
    <value>EnumeratorCancellationAttribute 将不起任何作用。该属性仅在返回 IAsyncEnumerable 的异步迭代器方法中 CancellationToken 类型的参数上有效</value>
  </data>
  <data name="ReturnValueProducedWithMustDisposeAnnotatedMethodIsNotDisposedMessage" xml:space="preserve">
    <value>此调用的返回值从未被处置</value>
  </data>
  <data name="CatchClauseWithSinglethrowStatementIsRedundant" xml:space="preserve">
    <value>带有单条 'throw' 语句的 catch 子句冗余</value>
  </data>
  <data name="CompilerWarning_CS3010_Title" xml:space="preserve">
    <value>符合 CLS 的接口必须仅有符合 CLS 的成员</value>
  </data>
  <data name="FieldCannotBeBothvolatileAndreadonlyMessage" xml:space="preserve">
    <value>'{0}' 字段不能同时为 'volatile' 和 'readonly'</value>
  </data>
  <data name="Object_Text" xml:space="preserve">
    <value>对象</value>
  </data>
  <data name="CompilerWarning_CS8765_Title" xml:space="preserve">
    <value>参数类型的为 Null 性与重写成员不匹配(可能是由于为 Null 性特性)。</value>
  </data>
  <data name="HidingDifferentRefnessMessage" xml:space="preserve">
    <value>形参 '{0} {1} {2}' 的引用种类修饰符与被隐藏的成员中的相应形参 '{3} {4} {5}' 不匹配</value>
  </data>
  <data name="ItIsRecommendedToUseConfigureAwaitFalseInYourLibraryCodeToPreventContextCaptureInTaskContinuationsThisInspectionIsControlledByTheConfigureAwaitAnalysisModeProjectLevelPropertyWhichIsSetToDisabledByDefaultSetConfigureAwaitAnalysisModeProjectLevelPropertyToLibraryToAnalyzeawaitUsingStatementsForMissingConfigureAwaitFalseCalls" xml:space="preserve">
    <value>建议在库代码中使用 'ConfigureAwait(false)'，以防止在任务延续符中捕获上下文。
        此检查由 'ConfigureAwait analysis mode' 项目级属性控制，默认情况下，该属性被设置为 'Disabled'。
        将 'ConfigureAwait analysis mode' 项目级属性设置为 'Library' 可分析 'await using' 语句以发现缺少的 'ConfigureAwait(false)' 调用。</value>
  </data>
  <data name="ReplaceAnEmptyEventArgsAllocationWithAUseOfThePredefinedEventArgsEmptyField" xml:space="preserve">
    <value>将空 'EventArgs' 分配替换为使用预定义 'EventArgs.Empty' 字段</value>
  </data>
  <data name="NPlusOneMainMessage" xml:space="preserve">
    <value>可能对数据库进行多次相关实体查询(N+1 问题)</value>
  </data>
  <data name="PossibleUnassignedObjectCreatedBynewExpression" xml:space="preserve">
    <value>由 'new' 表达式创建的可能未赋值的对象</value>
  </data>
  <data name="CompilerWarning_CS1668_Title" xml:space="preserve">
    <value>指定的搜索路径无效</value>
  </data>
  <data name="ThrownValueMayBeNullMessage" xml:space="preserve">
    <value>抛出的值可以为 null</value>
  </data>
  <data name="PartialWithSinglePartMessage" xml:space="preserve">
    <value>具有单个部分的分部{0}</value>
  </data>
  <data name="withExpressionIsUsedInsteadOfObjectInitializerMessage" xml:space="preserve">
    <value>使用了 'with' 表达式而不是对象初始值设定项</value>
  </data>
  <data name="MemberWithTheSameSignatureIsAlreadyDeclaredMessage" xml:space="preserve">
    <value>已声明具有相同签名的成员</value>
  </data>
  <data name="TheReturnTypeForOrOperatorMustBeTheContainingTypeMessage" xml:space="preserve">
    <value>++ 或 -- 运算符的返回值类型必须为包含类型</value>
  </data>
  <data name="AccessibilityModifiersOnAccessorsMayOnlyBeUsedIfThePropertyOrIndexerHasBothAGetAndASetAccessorMessage" xml:space="preserve">
    <value>只有属性或索引器同时具有 get 和 set 访问器时，才能在访问器上使用可访问性修饰符</value>
  </data>
  <data name="JoinNullCheckWithUsageSettingApplyStyleHeuristicsTitle" xml:space="preserve">
    <value>应用代码样式启发</value>
  </data>
  <data name="AthrowStatementInsideACatchClauseWhichThrowsTheExceptionCaughtInMostOfCasesAthrowStatementWithNoArgumentIsToBeUsed" xml:space="preserve">
    <value>catch 子句中的 'throw' 语句，用于抛出捕获的异常。大多数情况下，将使用不带实参的 'throw' 语句。</value>
  </data>
  <data name="IncompatibleAnonymousFunctionSignatureMessage" xml:space="preserve">
    <value>不兼容的匿名函数签名</value>
  </data>
  <data name="CannotDefineOperatorWithParametersMessage" xml:space="preserve">
    <value>不能使用{1}形参定义运算符 '{0}'</value>
  </data>
  <data name="TheWillNotBeUsedAsAnEntryPointBecauseCompilationUnitWithTopLevelStatementsWasFoundMessage" xml:space="preserve">
    <value>'{0}' {1} 将不被用作入口点，因为找到了具有顶层语句的编译单元</value>
  </data>
  <data name="DuplicateCaseLabelValueMessage" xml:space="preserve">
    <value>重复的 case 标签值 '{0}'</value>
  </data>
  <data name="UsingStatementResourceInitializationDescription" xml:space="preserve">
    <value>在 'using' 语句中初始化对象属性，以确保在初始化过程中抛出异常时处置该对象</value>
  </data>
  <data name="NestedStringInterpolationCanBeInlinedIntoContainingOne" xml:space="preserve">
    <value>嵌套字符串内插可以内联到包含内插中</value>
  </data>
  <data name="PropertiesAndVariablesMutableLocalVariable_RiderPresentableName" xml:space="preserve">
    <value>属性和变量//可变的局部变量</value>
  </data>
  <data name="FunctionsReturnTypeIsDeclaredAsNullableButItNeverReturnsNullableValues" xml:space="preserve">
    <value>函数的返回值类型被声明为可以为 null，但它从未返回可以为 null 的值</value>
  </data>
  <data name="ConvertsPropertyDeclarationToCAutoPropertySyntax" xml:space="preserve">
    <value>将属性声明转换为 C# 自动属性语法</value>
  </data>
  <data name="ShebangDirectiveBadPlacementDescription" xml:space="preserve">
    <value>将 shebang 指令(以 '#!' 开头)移动到文件的最开头，以便与 Unix 兼容的程序加载器可以确定如何运行</value>
  </data>
  <data name="BitwiseOperationOnEnumWhichIsNotMarkedByFlagsAttribute3" xml:space="preserve">
    <value>枚举上的按位运算未通过 [Flags] 特性进行标记</value>
  </data>
  <data name="partialMemberDeclarationsMustBeEitherBothOrNeitherstaticMessage" xml:space="preserve">
    <value>'partial' 成员声明必须两个都为 'static' 或都不为 'static'</value>
  </data>
  <data name="NullabilityOfTypeArgumentMustMatchConstraintTypeConstraintInOrderToUseItAsParameterMessage" xml:space="preserve">
    <value>类型实参 '{0}' 的为 null 性必须与约束类型为 '{1}' 的约束匹配才能将其用作形参 '{2}'</value>
  </data>
  <data name="AmbiguousSymbolsInTextArgument" xml:space="preserve">
    <value>文本实参中存在不明确的符号</value>
  </data>
  <data name="intIsDefaultEnumGoverningTypeMessage" xml:space="preserve">
    <value>'int' 是默认的枚举控制类型</value>
  </data>
  <data name="ReplaceWithPrimaryConstructorParameter" xml:space="preserve">
    <value>替换为主构造函数形参</value>
  </data>
  <data name="PossibleSystemArgumentOutOfRangeExceptionIndexMustBeANonNegativeInteger" xml:space="preserve">
    <value>可能出现 'System.ArgumentOutOfRangeException'。索引必须为非负整数。</value>
  </data>
  <data name="InterceptorBadMethodKindMessage" xml:space="preserve">
    <value>拦截器方法必须为普通成员方法</value>
  </data>
  <data name="BracesAndOperatorsDot_RiderPresentableName" xml:space="preserve">
    <value>大括号和运算符//点</value>
  </data>
  <data name="ImplicitlyTypedParamsParameterErrorMessage" xml:space="preserve">
    <value>隐式类型化 lambda 形参 '{0}' 不能具有 'params' 修饰符</value>
  </data>
  <data name="MissingConfigureAwaitFalseForAsyncDisposableInLibraryCode" xml:space="preserve">
    <value>库代码中的异步释放缺少 '.ConfigureAwait(false)'</value>
  </data>
  <data name="Type_ConflictsType__Text" xml:space="preserve">
    <value>类型 '{0}' 与类型 '{1}' 冲突</value>
  </data>
  <data name="PartialMethodMustHaveAccessibilityModifiersBecauseItHasAvirtualoverridesealednewOrexternModifierMessage" xml:space="preserve">
    <value>分部方法“{0}”必须具有可访问性修饰符，因为它具有 "virtual"、"override"、"sealed"、"new" 或 "extern" 修饰符</value>
  </data>
  <data name="ThreadStaticDoesntWorkWithMessage" xml:space="preserve">
    <value>[ThreadStatic] 对{0}无效</value>
  </data>
  <data name="CannotawaitInAnUnsafeContextMessage" xml:space="preserve">
    <value>不能在 unsafe 上下文中 'await'</value>
  </data>
  <data name="ThereIsNoCodeInspectionIssueDisabledByThisComment" xml:space="preserve">
    <value>没有此注释禁用的代码检查问题</value>
  </data>
  <data name="MoveLocalFunctionAfterJumpStatementMessage" xml:space="preserve">
    <value>将局部函数 '{0}' 放置在 '{1}' 之后</value>
  </data>
  <data name="TryCastAndCheckForNullCanBeReplacedWithATypeCheckMessage" xml:space="preserve">
    <value>null 的 try cast 和检查可被替换为类型检查</value>
  </data>
  <data name="DeconstructAssignmentRequiresAnExpressionWithATypeOnTheRightHandSideMessage" xml:space="preserve">
    <value>析构任务要求表达式属于右侧的某个类型</value>
  </data>
  <data name="ByRefLikeOrAllowsByRefLikeTypeInTypeArgumentMessage" xml:space="preserve">
    <value>类型 '{0}' 不能是 ref 结构或允许 ref 结构的类型形参以将其用作类型实参({1})</value>
  </data>
  <data name="TypeMemberIsInferredToBeNullableConsiderAnnotatingItWithCanBeNullOrItemCanBeNullAttribute" xml:space="preserve">
    <value>类型成员被推断为可以为 null 的: 请考虑使用 [CanBeNull] 或 [ItemCanBeNull] 特性对其进行注解</value>
  </data>
  <data name="PrefixCanBeSafelyRemovedFromIdentifier" xml:space="preserve">
    <value>可以安全地从标识符中移除 '@' 前缀</value>
  </data>
  <data name="ConvertIfStatementToSwitchStatementSettingAssumeOpenTypeHierarchyDescription" xml:space="preserve">
    <value>如果解决方案中的类型可以通过外部代码扩展，请选中此设置。
存在通过原始 'if' 语句链的路径在转换后互斥时，设置将影响 'switch' 建议。
取消选中此设置后，检查将验证此建议对于当前解决方案中可用的所有类型都是安全的。
选中此设置后，如果来自解决方案的类型将在外部代码中扩展，它还将检查转换是否安全，例如添加代码库中当前不存在的接口组合。</value>
  </data>
  <data name="SimplifyNegativeEqualityExpression" xml:space="preserve">
    <value>简化负的相等表达式</value>
  </data>
  <data name="CannotCallSpecialMethodMessage" xml:space="preserve">
    <value>无法显式调用运算符或访问器</value>
  </data>
  <data name="AnonymousMethod_Text" xml:space="preserve">
    <value>匿名方法</value>
  </data>
  <data name="DereferenceOfAPossiblyNullReferenceMessage" xml:space="preserve">
    <value>解引用可能出现空引用</value>
  </data>
  <data name="StaticMemberCannotBeInitializedInAnObjectInitializerMessage" xml:space="preserve">
    <value>static 成员 '{0}' 不能在对象初始值设定项中初始化</value>
  </data>
  <data name="FixedPointerDeclarationIsRedundantBecauseAccessingElementsOfFixedSizeBufferDoesntRequirePinningMessage" xml:space="preserve">
    <value>固定指针声明冗余，因为访问固定大小缓冲区的元素时不需要固定</value>
  </data>
  <data name="CompilerWarning_CS8607_Title" xml:space="preserve">
    <value>可能的 null 值不能用于标记为 [NotNull] 或 [DisallowNull] 的类型</value>
  </data>
  <data name="UnrecognizedEscapeSequence_Text" xml:space="preserve">
    <value>未识别的转义序列</value>
  </data>
  <data name="MethodSpecifiesAclassConstraintForTypeParameterButCorrespondingTypeParameterOfOverriddenOrExplicitlyImplementedMethodIsNotAReferenceTypeMessage" xml:space="preserve">
    <value>方法 '{0}' 为类型形参 '{1}' 指定了 'class' 约束，但被重写或显式实现的方法 '{3}' 的相应类型形参 '{2}' 不是引用类型</value>
  </data>
  <data name="TypePatternAndCastsCanBeMerged" xml:space="preserve">
    <value>可以合并类型模式和转换</value>
  </data>
  <data name="MultipleSequentialOrderByInvocationsAreMeaninglessPossiblyYouMeanThenByInsteadMessage" xml:space="preserve">
    <value>多个顺序 'OrderBy' 调用毫无意义。您的意思可能是 'ThenBy'。</value>
  </data>
  <data name="TypeNameExpectedMessage5" xml:space="preserve">
    <value>应为类型名称{0}</value>
  </data>
  <data name="UseSymbolAliasDescription" xml:space="preserve">
    <value>使用可用别名</value>
  </data>
  <data name="CompilerWarning_CS9159_Title" xml:space="preserve">
    <value>返回值类型中引用类型的为 null 性与可拦截的方法不匹配。</value>
  </data>
  <data name="PossibleComparisonOfValueTypeWithnull" xml:space="preserve">
    <value>可能将值类型于 'null' 比较</value>
  </data>
  <data name="NullabilityOfReferenceTypesInReturnTypeDoesntMatchTheReturnTypeOfTargetDelegatePossiblyBecauseOfNullabilityAttributesMessage" xml:space="preserve">
    <value>返回值类型 '{0}' 中引用类型的为 null 性与目标委托 '{2}' 的返回值类型 '{1}' 不匹配(可能是由于为 null 性特性)</value>
  </data>
  <data name="RefReturningCallAndAwaitMessage" xml:space="preserve">
    <value>调用 '{0}' 返回的引用无法跨 'await' 或 'yield' 边界保留</value>
  </data>
  <data name="CompilerWarning_CS9020_Title" xml:space="preserve">
    <value>分配“this”对象的所有字段之前读取该对象，从而导致对未显式分配的字段进行前面的隐式分配“default”。</value>
  </data>
  <data name="CompilerWarning_CS8892_Title" xml:space="preserve">
    <value>异步 'Main' 方法将不会用作入口点，因为找到了同步入口点</value>
  </data>
  <data name="TheExpressionMustBeOfTypeBecauseItIsBeingAssignedByReferenceMessage" xml:space="preserve">
    <value>表达式必须为“{0}”类型，因为它通过引用赋值</value>
  </data>
  <data name="StaticMemberCannotBeReferencedInANamedAttributeArgumentMessage" xml:space="preserve">
    <value>不能在命名特性实参中引用 static 成员 '{0}'</value>
  </data>
  <data name="PossiblyUnintendedLinearSearchInSet" xml:space="preserve">
    <value>集合中可能出现非有意的线性搜索</value>
  </data>
  <data name="ReferenceToThisIsImmutableInReadonlyStructs_Text" xml:space="preserve">
    <value>对 '{0}' 的引用在 '{1}' {2}声明中不可变。</value>
  </data>
  <data name="IsNotAnInterpolatedStringHandlerTypeMessage" xml:space="preserve">
    <value>'{0}' 不是内插字符串处理程序类型</value>
  </data>
  <data name="CompilerWarning_CS8824_Title" xml:space="preserve">
    <value>退出时参数必须具有非 null 值，因为由 NotNullIfNotNull 引用的参数是非 null。</value>
  </data>
  <data name="CompilerWarning_CS9193_Title" xml:space="preserve">
    <value>实参应为变量，因为它会被传递给 'ref readonly' 形参</value>
  </data>
  <data name="XMLCommentOnHasADuplicateTypeparamTagForMessage" xml:space="preserve">
    <value>'{0}' 上的 XML 注释具有 '{1}' 的重复 typeparam 标记</value>
  </data>
  <data name="ReturnOfUsingVariableTitle" xml:space="preserve">
    <value>返回 'using' 语句捕获的变量</value>
  </data>
  <data name="TypeCheckisExpressionWithDirectCastSAfterCanBeMerged" xml:space="preserve">
    <value>可以将类型检查('is' 表达式)与后面的直接转换合并</value>
  </data>
  <data name="PerformsAnArithmeticOverflowCheckMessage" xml:space="preserve">
    <value>{0}执行了算术溢出检查</value>
  </data>
  <data name="CqrsFeatureSuggester_SuggestionMessage" xml:space="preserve">
    <value>您的代码似乎正在使用 CQRS 模式。ReSharper 可以通过其 CQRS 验证功能为您提供帮助。
转到“ReSharper | 选项 | 代码检查 | CQRS 验证”。</value>
  </data>
  <data name="CompilerWarning_CS8762_Title" xml:space="preserve">
    <value>在某些条件下退出时，参数必须具有非 null 值。</value>
  </data>
  <data name="PartOfTheCodeCannotBeParsedBecauseOfDeepNestingMostOfTheFeaturesWillNotWorkInsideItMessage" xml:space="preserve">
    <value>由于深度嵌套，部分代码不能解析。其中的大多数功能将不能运行。</value>
  </data>
  <data name="StringCannotBeConvertedToUtf8Message" xml:space="preserve">
    <value>输入字符串不能转换为等效的 UTF-8 字节表示形式。无法对索引 {1} 处的 Unicode 字符 {0} 进行编码。</value>
  </data>
  <data name="ExpressionTreeWithNamedOutOfPositionArgumentMessage" xml:space="preserve">
    <value>表达式树不能包含位置错误的命名实参规范</value>
  </data>
  <data name="DestructorCannotBeCalledDirectlyMessage" xml:space="preserve">
    <value>请勿直接调用析构函数。要管理资源生存期，请考虑实现 '{0}'。</value>
  </data>
  <data name="InExplicitInterfaceDeclarationIsNotAMemberOfInterfaceMessage" xml:space="preserve">
    <value>显式接口声明中的 '{0}' 不是接口 '{1}' 的成员</value>
  </data>
  <data name="InterpolatedStringThatCouldBeAValidFormatStringDetectedPossiblyIntendedToBeAFormatStringTemplateLiteral" xml:space="preserve">
    <value>检测到可能为有效格式字符串的内插字符串。可能打算作为格式字符串模板字面量。</value>
  </data>
  <data name="CompilerWarning_CS1587_Title" xml:space="preserve">
    <value>XML 注释没有放在有效语言元素上</value>
  </data>
  <data name="NotResolvedParamsCollectionDefaultCtorReferenceFromCallSiteMessage" xml:space="preserve">
    <value>从 '{1}' 中找不到 '{0}' 类型的默认构造函数来创建 'params' 集合</value>
  </data>
  <data name="InconsistentLambdaParameterUsageParameterTypesMustBeAllExplicitOrAllImplicitMessage" xml:space="preserve">
    <value>lambda 参数的用法不一致；参数类型必须全部为显式或全部为隐式</value>
  </data>
  <data name="AnExpressionTreeLambdaCannotCaptureReferencesMessage" xml:space="preserve">
    <value>表达式树 lambda 不能捕获引用</value>
  </data>
  <data name="CompilerWarning_CS3026_Title" xml:space="preserve">
    <value>符合 CLS 的字段不能是可变字段</value>
  </data>
  <data name="CapturedPrimaryConstructorParameterIsMutableDescription" xml:space="preserve">
    <value>主构造函数形参被实例成员捕获和变异，请考虑改用显式非 readonly 字段</value>
  </data>
  <data name="SystemVoidCannotBeUsedFromCSharpMessage" xml:space="preserve">
    <value>在 C# 中无法使用 System.Void -- 使用 typeof(void)获取 void 类型对象</value>
  </data>
  <data name="CompilerWarning_CS9154_Title" xml:space="preserve">
    <value>可拦截方法与拦截器方法的签名不匹配</value>
  </data>
  <data name="QueryRangeVariablesInLINQQueries_Text" xml:space="preserve">
    <value>LINQ 查询中的查询范围变量</value>
  </data>
  <data name="CompilerWarning_CS0824_Title" xml:space="preserve">
    <value>构造函数标记为外部对象</value>
  </data>
  <data name="CompilerWarning_CS8305_Title" xml:space="preserve">
    <value>类型仅用于评估，在将来的更新中可能会被更改或删除。</value>
  </data>
  <data name="InitializationIsRecursiveOnAllExecutionPathsMessage" xml:space="preserve">
    <value>{0}初始化在所有执行路径上都是递归的</value>
  </data>
  <data name="MemberInitializerValueIgnoredBecauseMemberAlwaysInitializedInAllConstructors" xml:space="preserve">
    <value>忽略了成员初始值设定项值，因为在所有构造函数中始终会对该成员进行初始化</value>
  </data>
  <data name="RightOperandOfDynamicShiftOperationShouldBeConvertibleToint" xml:space="preserve">
    <value>动态移位运算的右操作数应该可以转换为 'int'</value>
  </data>
  <data name="AForeachLoopMustDeclareItsIterationVariablesMessage" xml:space="preserve">
    <value>foreach 循环必须声明其迭代变量</value>
  </data>
  <data name="ExtensionMethodsCannotBeDynamicallyDispatchedMessage" xml:space="preserve">
    <value>不能动态调度扩展方法</value>
  </data>
  <data name="PartOfTheCodeCannotBeParsed" xml:space="preserve">
    <value>部分代码不能解析</value>
  </data>
  <data name="CoVariantArrayConversion" xml:space="preserve">
    <value>协变数组转换</value>
  </data>
  <data name="NullabilityOfReferenceTypesInTypeOfParameterInDoesntMatchOverriddenMemberMessage" xml:space="preserve">
    <value>{1}中形参 '{0}' 的类型中引用类型的为 null 性与被重写的成员 '{2}' 不匹配</value>
  </data>
  <data name="CommandInvasionMessage" xml:space="preserve">
    <value>CQRS 上下文交集。{0} 从“查询”上下文调用，但属于“命令”上下文。</value>
  </data>
  <data name="CompilerWarning_CS8884_Title" xml:space="preserve">
    <value>使用可能未赋值的字段</value>
  </data>
  <data name="UseMethodAny_Text" xml:space="preserve">
    <value>使用方法 Any()</value>
  </data>
  <data name="SuggestToReplacexIsNotNotTToxIsTXIsNotTToxIsT" xml:space="preserve">
    <value>建议将
          `x is not not T` 替换为 `x is T`
          `!(x is not T)` 替换为 `x is T`</value>
  </data>
  <data name="AttributeConstructorParameterHasTypeWhichIsNotAValidAttributeParameterTypeMessage" xml:space="preserve">
    <value>特性构造函数参数“{0}”具有类型“{1}”，这不是有效特性参数类型</value>
  </data>
  <data name="TheTupleElementNameIsIgnoredBecauseADifferentNameOrNoNameIsSpecifiedOnTheOtherSideOfTheTupleOrOperatorMessage" xml:space="preserve">
    <value>由于元组 == 或 != 运算符的另一侧指定了其他名称或未指定名称，因此元组元素名称“{0}”被忽略</value>
  </data>
  <data name="TheNullableAnnotationOnBaseTypeConstraintIsRedundantBecauseTypeParameterHasclassOrstructOrunmanagedConstraint" xml:space="preserve">
    <value>基类型约束上的可以为 null 的注解冗余，因为类型形参具有 'class' 或 'struct' 或 'unmanaged' 约束</value>
  </data>
  <data name="AccessorWithTheSameKindIsAlreadyDeclaredMessage" xml:space="preserve">
    <value>已声明同类的访问器</value>
  </data>
  <data name="ARefReturningCannotBevoidMessage" xml:space="preserve">
    <value>返回{0}的 ref 不能为 'void'</value>
  </data>
  <data name="AllUnderscoreLocalParameterNameTitle" xml:space="preserve">
    <value>lambda 或局部函数中可能存在误导性的形参名称</value>
  </data>
  <data name="SuggestWhenArgumentsAreLongerTitle" xml:space="preserve">
    <value>在类型实参更冗长时建议</value>
  </data>
  <data name="ReplaceSliceMethodCallWithRangeIndexerAccess" xml:space="preserve">
    <value>将 'Slice' 方法调用替换为范围索引器访问</value>
  </data>
  <data name="PossibleMistakenCallToGetTypeDescription" xml:space="preserve">
    <value>'System.Type' 实例上可能存在错误的 'GetType()' 调用</value>
  </data>
  <data name="CommentsBlockComment_RiderPresentableName" xml:space="preserve">
    <value>注释//块注释</value>
  </data>
  <data name="MethodInvocationIsSkippedConditionalMessage" xml:space="preserve">
    <value>{0} '{1}' 调用被跳过。编译器将不会生成调用，因为{2}已使用 [{3}] 特性进行标记，并且没有定义以下任何条件符号: {4}</value>
  </data>
  <data name="MethodCannotBeDeclaredInEnumMessage" xml:space="preserve">
    <value>不能在枚举中声明方法</value>
  </data>
  <data name="OptimizeUsings_Name" xml:space="preserve">
    <value>优化 'using' 指令和引用</value>
  </data>
  <data name="AssignmentResultsAreFullyDiscarded" xml:space="preserve">
    <value>赋值结果被完全舍弃</value>
  </data>
  <data name="CannotFindBestCommonTypeForTypes_Message" xml:space="preserve">
    <value>找不到类型 {0} 的最佳通用类型</value>
  </data>
  <data name="ConvertIfDeclarationIsOfBuiltInTypeEGString" xml:space="preserve">
    <value>如果声明为内置类型(例如字符串)，则转换</value>
  </data>
  <data name="TupleElementNamesMustBeUniqueMessage" xml:space="preserve">
    <value>元组元素名称必须是唯一的</value>
  </data>
  <data name="CollectionExpressionTypeDoesNotSupportKeyValuePairElements_Text" xml:space="preserve">
    <value>集合表达式类型 '{0}' 不支持键值对元素</value>
  </data>
  <data name="ReturnValueOfIteratorIsNotUsed17" xml:space="preserve">
    <value>迭代器的返回值未使用</value>
  </data>
  <data name="VoidMethodWithMustDisposeResourceAttributeMessage" xml:space="preserve">
    <value>使用 [MustDisposeResource] 注解 'void' 方法毫无意义</value>
  </data>
  <data name="NameofExtensionMemberErrorMessage" xml:space="preserve">
    <value>扩展成员不允许作为 'nameof' 的实参</value>
  </data>
  <data name="MethodHasAsyncOverload6" xml:space="preserve">
    <value>方法具有异步重载</value>
  </data>
  <data name="ADeconstructionCannotMixDeclarationsAndExpressionsOnTheLeftHandSideMessage" xml:space="preserve">
    <value>析构不能混合左侧的声明和表达式</value>
  </data>
  <data name="LocalFunctionIsNeverUsed" xml:space="preserve">
    <value>局部函数从未被使用</value>
  </data>
  <data name="PropertiesAndVariablesTupleComponentName_RiderPresentableName" xml:space="preserve">
    <value>属性和变量//元组组件名称</value>
  </data>
  <data name="PossibleSystemInvalidOperationExceptionCollectionWasModified" xml:space="preserve">
    <value>可能的 'System.InvalidOperationException: 集合已被修改'</value>
  </data>
  <data name="CompilerWarning_CS1584_Title" xml:space="preserve">
    <value>XML 注释中有语法错误的 cref 特性</value>
  </data>
  <data name="ThatReturnsByValue_Text" xml:space="preserve">
    <value>(按值返回)</value>
  </data>
  <data name="TheFieldIsSometimesUsedInsideSynchronizedBlockAndSometimesUsedWithoutSynchronization" xml:space="preserve">
    <value>该字段有时在同步块内使用，有时在不同步的情况下使用</value>
  </data>
  <data name="FixedSizeArrayDeclarationMustProvideArraySizeMessage" xml:space="preserve">
    <value>固定大小的数组声明必须提供数组大小</value>
  </data>
  <data name="CannotBeAbstractMessage" xml:space="preserve">
    <value>{0}不能为 abstract</value>
  </data>
  <data name="ConvertToPrimaryConstructorMessage" xml:space="preserve">
    <value>转换为主构造函数</value>
  </data>
  <data name="MergeSequentialChecksSettingApplyStyleHeuristicsDescription" xml:space="preserve">
    <value>使用此选项，只有在更改不会影响可读性的情况下才会建议转换。例如，如果应用它会提升布尔变量，它将禁止建议，引入显式相等检查，将结果 'Nullable&lt;bool&gt;' 表达式与 true/false 进行比较。</value>
  </data>
  <data name="MethodDelegateOrEventIsExpectedMessage" xml:space="preserve">
    <value>应为方法、委托或事件</value>
  </data>
  <data name="MethodIsDeclaredAspartialButHasOnlySinglePart" xml:space="preserve">
    <value>方法被声明为 'partial'，但仅有一个部分</value>
  </data>
  <data name="FunctionOrTypeInitializationIsRecursiveOnAllExecutionPaths" xml:space="preserve">
    <value>函数或类型初始化在所有执行路径上都是递归的</value>
  </data>
  <data name="ReturnOfTaskProducedByUsingVariableDescription" xml:space="preserve">
    <value>不返回由 'using' 捕获的对象生成的任务，因为在该对象被处置后此任务可能无法完成</value>
  </data>
  <data name="RedundantStringInterpolation" xml:space="preserve">
    <value>冗余的字符串内插</value>
  </data>
  <data name="MoveToExtensionBlockTitle" xml:space="preserve">
    <value>移至扩展块</value>
  </data>
  <data name="KindNameIsAReadOnlyReference_Text" xml:space="preserve">
    <value>{0} 为只读引用。</value>
  </data>
  <data name="CannotBeOverridenByEventMessage" xml:space="preserve">
    <value>'{0}' 无法重写 '{1}'，因为后者不是事件</value>
  </data>
  <data name="IndexedPropertyHasNonOptionalArgumentsWhichMustBeProvidedMessage" xml:space="preserve">
    <value>索引属性“{0}”具有必须提供的非可选参数</value>
  </data>
  <data name="MergeConditionalExpressionSettingApplyStyleHeuristicsTitle" xml:space="preserve">
    <value>应用代码样式启发</value>
  </data>
  <data name="ASuppressedNullableWarningMightHideAnUnderlyingProblem" xml:space="preserve">
    <value>禁止的可以为 null 警告可能会隐藏底层问题</value>
  </data>
  <data name="ConditonalExpressionWithANullCheckexprIsXOrATypePatternexprIsTXCanBeRewrittenAsANullCoalescingExpression" xml:space="preserve">
    <value>带 null 检查('expr is {} x')或类型模式('expr is T x')的条件表达式可被重写为 null 合并('??')表达式</value>
  </data>
  <data name="RedundantCollectionCopyCallMessage" xml:space="preserve">
    <value>冗余的 '{0}' 调用</value>
  </data>
  <data name="ARefReturningMustHaveAGetterMessage" xml:space="preserve">
    <value>返回{0}的 ref 不能有 getter</value>
  </data>
  <data name="AStaticLocalFunctionCannotContainAReferenceToMessage" xml:space="preserve">
    <value>static 局部函数不能包含对 '{0}' 的引用</value>
  </data>
  <data name="Variable_Text" xml:space="preserve">
    <value>变量</value>
  </data>
  <data name="IncorrectConstantExpectedAnnotationTitle" xml:space="preserve">
    <value>'ConstantExpected' 特性的用法不正确</value>
  </data>
  <data name="DefinesEqualsButDoesNotOverridesGetHashCodeMessage" xml:space="preserve">
    <value>'{0}' 定义 'Equals'，但不重写 'GetHashCode'</value>
  </data>
  <data name="FieldHidesPropertyWithDefaultImplementationInInterface" xml:space="preserve">
    <value>字段会隐藏接口中具有默认实现的属性</value>
  </data>
  <data name="AttributeSystemDiagnosticsConditionalAttributeIsOnlyValidOnAttributeClassesOrMethodsWithvoidReturnTypeMessage" xml:space="preserve">
    <value>'System.Diagnostics.ConditionalAttribute' 特性仅对具有 'void' 返回值类型的特性类或方法有效</value>
  </data>
  <data name="AccessToDisposedCapturedVariable" xml:space="preserve">
    <value>访问已释放的捕获变量</value>
  </data>
  <data name="AsyncsCannotHaveByReferenceLocalsMessage" xml:space="preserve">
    <value>async {0}不能有按引用局部变量</value>
  </data>
  <data name="RequiredMemberMustBeSetInAttributeMessage" xml:space="preserve">
    <value>必需成员 '{0}' 必须在特性构造函数中设置</value>
  </data>
  <data name="InterfaceMember_IsNotImplementedMessage" xml:space="preserve">
    <value>接口成员 '{0}' 未实现</value>
  </data>
  <data name="CannotBeSealedBecauseItIsDeclaredInAStructTypeMessage" xml:space="preserve">
    <value>{0}不能为 sealed，因为它是在结构类型中声明的</value>
  </data>
  <data name="PossibleNullAssignmentToNonNullableEntityMessage" xml:space="preserve">
    <value>可能将 '{0}' 赋给不可以为 null 的实体</value>
  </data>
  <data name="ReplaceWithStringIsNullOrEmptyMessage" xml:space="preserve">
    <value>替换为 '{0}{1}.{2}'</value>
  </data>
  <data name="AGenericTypeCannotDeriveFromSystemAttributeBecauseItIsAnAttributeClassMessage" xml:space="preserve">
    <value>泛型类型不能从 'System.Attribute' 中派生，因为它是一个特性类</value>
  </data>
  <data name="TheFirstParameterOfAnExtensionMethodCannotBeOfPointerTypeMessage" xml:space="preserve">
    <value>扩展方法的第一个形参不能为指针类型</value>
  </data>
  <data name="CanSimplifyStringEscapeSequenceMessage" xml:space="preserve">
    <value>转义序列可被简化</value>
  </data>
  <data name="TupleExpressionCannotBeConvertedToTargetTypeMessage" xml:space="preserve">
    <value>元组表达式不能转换为目标类型 '{0}'</value>
  </data>
  <data name="CompilerWarning_CS8883_Title" xml:space="preserve">
    <value>使用可能未赋值的自动实现的属性</value>
  </data>
  <data name="MethodInvocationIsSkippedCompiler" xml:space="preserve">
    <value>跳过了方法调用。编译器将不生成方法调用，因为该方法为条件方法，或者它是没有实现的分部方法。</value>
  </data>
  <data name="CannotUseANegativeSizeWithStackallocMessage" xml:space="preserve">
    <value>无法对 stackalloc 采用负值大小</value>
  </data>
  <data name="RedundantDefaultSwitchBranchpreSwitchFooCaseBarDoSomethingBreakDefaultHereBreakPre" xml:space="preserve">
    <value>冗余的 default switch 分支:
&lt;pre&gt;
  switch (foo)
  {
    case Bar:
      DoSomething;
      break;
    default: // here
      break;
  }
&lt;/pre&gt;</value>
  </data>
  <data name="AbstractCannotDeclareABodyMessage" xml:space="preserve">
    <value>abstract {0}不能声明主体</value>
  </data>
  <data name="ExplicitCollectionCreationInArgumentPassedToParamsParameterIsRedundant" xml:space="preserve">
    <value>在传递给 'params' 形参的实参中显式创建集合的操作冗余</value>
  </data>
  <data name="SuspiciousParameterNameInArgumentNullException" xml:space="preserve">
    <value>ArgumentNullException 中存在可疑的形参名称</value>
  </data>
  <data name="BaseLastParameterHasparamsModifierMessage" xml:space="preserve">
    <value>基{0} '{1}' 最后一个形参具有 'params' 修饰符</value>
  </data>
  <data name="UseDeconstructionToSwapVariables" xml:space="preserve">
    <value>使用析构来交换变量</value>
  </data>
  <data name="StaticClassTypeCannotBeUsedAsTypeArgumentsMessage" xml:space="preserve">
    <value>'{0}': static 类类型不能用作类型实参</value>
  </data>
  <data name="InvalidIntegerLiteralMessage" xml:space="preserve">
    <value>整数字面量无效</value>
  </data>
  <data name="PossibleNullReferenceReturnMessage" xml:space="preserve">
    <value>可能的 null 引用返回</value>
  </data>
  <data name="SimplifyIsInstanceOfTypeDescription" xml:space="preserve">
    <value>IsInstanceOfType() 调用可以使用 'is' 运算符简化</value>
  </data>
  <data name="ParameterIsSpecifiedMultipleTimesMessage" xml:space="preserve">
    <value>多次指定了形参 '{0}'</value>
  </data>
  <data name="StringsStringLiteral_RiderPresentableName" xml:space="preserve">
    <value>字符串//字符串字面量</value>
  </data>
  <data name="DefaultConstructorOfBaseClassIsNotAccessibleMessage" xml:space="preserve">
    <value>基类 '{0}' 的默认构造函数无法访问</value>
  </data>
  <data name="StringCanBeChangedToRegularStringWithoutAnyChanges" xml:space="preserve">
    <value>字符串可以转换为正则字符串，无需任何更改</value>
  </data>
  <data name="UseArgumentNullExceptionThrowIfNullMessage" xml:space="preserve">
    <value>使用 'ArgumentNullException.ThrowIfNull'</value>
  </data>
  <data name="CompilerWarning_CS8819_Title" xml:space="preserve">
    <value>返回类型中引用类型的为 Null 性与分部方法声明不匹配。</value>
  </data>
  <data name="SuggestVarOrType_DeconstructionDeclarationsSettingAlwaysKeepVarInMultiVariableDeconstructionDescription" xml:space="preserve">
    <value>通过此选项可以忽略常规 'var' 样式规则，并始终为具有多个变量的析构声明保留单个 'var' 关键字。</value>
  </data>
  <data name="TheTypeArgumentsForCannotBeInferredFromTheUsageTrySpecifyingTheTypeArgumentsExplicitlyMessage" xml:space="preserve">
    <value>不能从用法中推断{0} '{1}' 的类型实参。请尝试显式指定类型实参。</value>
  </data>
  <data name="In__Call_Text" xml:space="preserve">
    <value> (在 '{0}' {1} 调用中)</value>
  </data>
  <data name="CompilerWarning_CS1723_Title" xml:space="preserve">
    <value>XML 注释中有引用类型参数的 cref 特性</value>
  </data>
  <data name="UseThisInspectionToProhibitUseOfTabulationCharacterForCodeIndentation" xml:space="preserve">
    <value>使用此检查以禁止为代码缩进使用制表符</value>
  </data>
  <data name="TheTypeParameterCouldBeDeclaredAsMessage" xml:space="preserve">
    <value>类型形参 '{0}' 可被声明为 {1}</value>
  </data>
  <data name="ConvertPropertyToAutoProperty" xml:space="preserve">
    <value>将属性转换为自动属性</value>
  </data>
  <data name="CompilerWarning_CS1062_Title" xml:space="preserve">
    <value>与集合初始值设定项元素最匹配的重载 Add 方法已过时</value>
  </data>
  <data name="NullableReferenceTypeInUsingAliasMessage" xml:space="preserve">
    <value>不能将别名声明为可为 null 的引用类型</value>
  </data>
  <data name="ConvertToBlockScopedNamespaceMessage" xml:space="preserve">
    <value>转换为块作用域的命名空间</value>
  </data>
  <data name="ReturnTypeOfAFunctionCanBeNonNullableSettingSuggestChangesInVirtualMembersTitle" xml:space="preserve">
    <value>在 virtual 成员中建议不可以为 null 的返回值类型</value>
  </data>
  <data name="InlineArrayForEachNotSupportedMessage" xml:space="preserve">
    <value>不支持类型 'Buffer' 的内联数组上的 foreach 语句</value>
  </data>
  <data name="CompilerWarning_CS1697_Title" xml:space="preserve">
    <value>提供了不同的 #pragma 校验和值</value>
  </data>
  <data name="LambdaExpressionAnonymousMethodCanBeMadeStatic" xml:space="preserve">
    <value>lambda 表达式/匿名方法可被设为 'static'</value>
  </data>
  <data name="RedundantOperandInLogicalConditionalExpressionForExamplepreExprFalseExprTruePre" xml:space="preserve">
    <value>逻辑条件表达式中存在冗余的操作数，例如
&lt;pre&gt;
  expr || false
  expr &amp;&amp; true
&lt;/pre&gt;</value>
  </data>
  <data name="EnumerableSumInvocationInExplicitUncheckedContext" xml:space="preserve">
    <value>在显式 unchecked 上下文中调用 'Enumerable.Sum'</value>
  </data>
  <data name="UserDefinedCompoundOperatorMustReturnVoidMessage" xml:space="preserve">
    <value>此运算符的返回值类型必须为 void</value>
  </data>
  <data name="TailRecursiveCallCanBeReplacedWithLoop" xml:space="preserve">
    <value>尾递归调用可被替换为循环</value>
  </data>
  <data name="TheCallerArgumentExpressionAttributeAppliedToParameterWillHaveNoEffectItIsAppliedWithAnInvalidParameterNameMessage" xml:space="preserve">
    <value>应用于形参 '{1}' 的 [{0}] 特性不起任何作用，因为应用它时使用了无效的形参名称</value>
  </data>
  <data name="CompilerWarning_CS9184_Title" xml:space="preserve">
    <value>对于元素字段为 'ref' 字段或具有无效类型实参的类型的内联数组类型，不支持 'Inline arrays' 语言功能。</value>
  </data>
  <data name="CanSimplifyDictionaryLookupWithTryAddMessage" xml:space="preserve">
    <value>可以使用 'TryAdd' 简化字典查找</value>
  </data>
  <data name="CSharpFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_preprocessor_directive" xml:space="preserve">
    <value>预处理程序指令周围</value>
  </data>
  <data name="CompilerWarning_CS0473_Title" xml:space="preserve">
    <value>显式接口实现与多个接口成员匹配</value>
  </data>
  <data name="BadParameterModifiersOrderMessage" xml:space="preserve">
    <value>形参修饰符 '{0}' 不能跟在 '{1}' 之后</value>
  </data>
  <data name="PrivateModifierCanBeSafelyAddedRemoved_Text" xml:space="preserve">
    <value>可以安全地在类型成员中添加/移除 'private' 修饰符，而不更改代码语义</value>
  </data>
  <data name="MembersMustHaveWhenExitingWithMessage" xml:space="preserve">
    <value>以 '{1}' 退出时成员 {0} 必须具有非 null 值</value>
  </data>
  <data name="SuspiciousShiftCountForLeftOperandOfTypeActualShiftCountWillBeMessage" xml:space="preserve">
    <value>{1}类型的左操作数的可疑位移计数 {0}: 实际位移计数将为 {2}</value>
  </data>
  <data name="ReplaceDelegateVariableWithLocalFunction" xml:space="preserve">
    <value>将委托变量替换为局部函数</value>
  </data>
  <data name="ComponentOfTheReturnTupleIsNeverUsedMessage" xml:space="preserve">
    <value>返回元组的组件从未被使用</value>
  </data>
  <data name="OperatorCannotBeAppliedToOperandsOfTypeAndMessage" xml:space="preserve">
    <value>运算符 '??' 不能应用于 '{0}' 和 '{1}' 类型的操作数</value>
  </data>
  <data name="ExtensionDisallowsMemberErrorMessage" xml:space="preserve">
    <value>扩展块中不允许使用此成员</value>
  </data>
  <data name="CompilerWarning_CS0169_Title" xml:space="preserve">
    <value>字段从未被使用</value>
  </data>
  <data name="UsingDirectiveIsNotRequiredByTheCodeAndCanBeSafelyRemovedMessage" xml:space="preserve">
    <value>代码不需要 using 指令，可以将其安全地移除</value>
  </data>
  <data name="FieldLikeEventField_Text" xml:space="preserve">
    <value>类似字段的事件</value>
  </data>
  <data name="CanReplaceCastWithLambdaReturnTypeDescription" xml:space="preserve">
    <value>将转换表达式替换为 lambda 返回值类型以增强编译时安全性</value>
  </data>
  <data name="OpenTypeInUsingAliasDirectiveMessage" xml:space="preserve">
    <value>using 别名指令中存在开放类型</value>
  </data>
  <data name="StringInterpolationExpressionWithoutArgumentsIsRedundant" xml:space="preserve">
    <value>没有实参的字符串内插表达式冗余</value>
  </data>
  <data name="NullabilityOfReferenceTypesInTypeDoesntMatchImplicitlyImplementedMemberMessage" xml:space="preserve">
    <value>类型中引用类型的为 null 性与隐式实现的成员 '{0}' 不匹配</value>
  </data>
  <data name="SomeValuesOfTheEnumAreNotProcessedInsideswitchStatementAndFallIntoDefaultSectionThisMightIndicateUnintentionalHandlingOfAllEnumValuesAddedAfterTheSwitchWasIntroducedConsiderHandlingMissingEnumValuesExplicitly" xml:space="preserve">
    <value>枚举的某些值未在 'switch' 语句内处理，并且位于 default 部分。这可能表明在引入 switch 后意外处理了所有添加的枚举值，请考虑显式处理缺少的枚举值</value>
  </data>
  <data name="MustHaveSetToImplementMessage" xml:space="preserve">
    <value>'{0}' 必须具有 'set' 访问器而不是 'init' 才能实现{1} '{2}'</value>
  </data>
  <data name="CanTMakeReferenceFromKindName_Text" xml:space="preserve">
    <value>不能从{0} '{1}' 发起引用。</value>
  </data>
  <data name="InconsistentBracesStyleMissingBracesMessage" xml:space="preserve">
    <value>大括号样式不一致: 缺少大括号</value>
  </data>
  <data name="NotNullOrCanBeNullAttributeHasNoEffectBecauseTheTargetTypeAlreadyHasTheSameAnnotationFromNullableReferenceTypes" xml:space="preserve">
    <value>[NotNull] 或 [CanBeNull] 特性不起任何作用，因为目标类型已具有来自可以为 null 的引用类型的相同注解</value>
  </data>
  <data name="InlineTemporaryVariableMessage" xml:space="preserve">
    <value>内联临时变量</value>
  </data>
  <data name="ReplaceAssignmentWithCompoundAssignment" xml:space="preserve">
    <value>将赋值替换为复合赋值</value>
  </data>
  <data name="RedundantControlFlowJumpStatement" xml:space="preserve">
    <value>冗余的控制流跳过语句</value>
  </data>
  <data name="ParameterOfLocalFunctionIsNeverUsed" xml:space="preserve">
    <value>局部函数的形参从未被使用</value>
  </data>
  <data name="CompilerGeneratesCorrectValueForParametersMarkedWithCallerMemberNameCallerFilePathCallerLineNumberOrCallerArgumentExpressionAttributes" xml:space="preserve">
    <value>编译器为使用 [CallerMemberName]、[CallerFilePath]、[CallerLineNumber] 或 [CallerArgumentExpression] 特性标记的形参生成正确的值</value>
  </data>
  <data name="ConvertSeriesOfIfStatementsToSingleSwitchExpression" xml:space="preserve">
    <value>将一系列 'if' 语句转换为单个 'switch' 表达式</value>
  </data>
  <data name="CoVariantConversionOfArrayCouldCauseRunTimeExceptions" xml:space="preserve">
    <value>数组的协变转换可能导致运行时异常</value>
  </data>
  <data name="ExtensionMemberWithInterfaceQualificationErrorMessage" xml:space="preserve">
    <value>扩展成员不能实现接口</value>
  </data>
  <data name="InvalidModifierOnExtensionMemberErrorMessage" xml:space="preserve">
    <value>扩展成员不能标记为 '{0}'</value>
  </data>
  <data name="RedundantPropertyPatternClause" xml:space="preserve">
    <value>冗余的属性模式子句</value>
  </data>
  <data name="CompilerWarning_CS9073_Title" xml:space="preserve">
    <value>参数的 “scoped” 修饰符与目标不匹配。</value>
  </data>
  <data name="CompilerWarning_CS8105_Title" xml:space="preserve">
    <value>指定公共签名时，将忽略特性。</value>
  </data>
  <data name="ThisCombinationOfArgumentsToIsDisallowedBecauseItMayExposeVariablesReferencedByItsArgumentsOutsideOfTheirDeclarationScopeMessage" xml:space="preserve">
    <value>不允许使用 '{0}' 的这种实参组合，因为它可能会在其声明作用域以外公开其实参引用的变量</value>
  </data>
  <data name="ConvertToUsingDeclarationMessage" xml:space="preserve">
    <value>转换为 '{0}' 声明</value>
  </data>
  <data name="FunctionMustBeCalledOnClientSideText" xml:space="preserve">
    <value>函数不可转换为 SQL，并且不得在数据库上下文中调用</value>
  </data>
  <data name="AccessToForeachVariableInClosureMayHaveDifferentBehaviorWhenCompiledWithDifferentVersionsOfCompilerMessage" xml:space="preserve">
    <value>访问闭包中的 foreach 变量。当使用其他版本的编译器编译时，可能具有不同的行为。</value>
  </data>
  <data name="TypeMemberIsInferredToBeNotNull" xml:space="preserve">
    <value>类型成员被推断为非 null</value>
  </data>
  <data name="TheNullableAnnotationOnTypeConstraintIsRedundantBecauseTypeParameterIsConstrainedByNonNullableTypeMessage" xml:space="preserve">
    <value>类型约束 '{0}' 上的可以为 null 的注解冗余，因为类型形参 '{1}' 受不可以为 null 的类型 '{2}' 约束</value>
  </data>
  <data name="RedundantDisableCodeInspectionComment" xml:space="preserve">
    <value>Redundant disable code inspection comment</value>
  </data>
  <data name="withExpressionModifiesAllAccessibleInstanceMembersMessage" xml:space="preserve">
    <value>'with' 表达式会修改所有可访问的实例成员</value>
  </data>
  <data name="AmbiguousIndexer_Text" xml:space="preserve">
    <value>索引器</value>
  </data>
  <data name="UncheckedContextIsRedundantNoOperatorsOrConversionsWithOverflowChecksMessage" xml:space="preserve">
    <value>unchecked 上下文冗余: 没有带溢出检查的运算符或转换</value>
  </data>
  <data name="BothContextCallTitle" xml:space="preserve">
    <value>方法从两种 CQRS 上下文调用</value>
  </data>
  <data name="ANullableTypeParameterMustBeKnownToBeAValueTypeOrNonNullableReferenceTypeUnlessLanguageVersionOrGreaterIsUsedConsiderAddingAclassstructOrTypeConstraintMessage" xml:space="preserve">
    <value>除非使用语言版本 '9.0' 或更高版本，否则可以为 null 的类型的形参必须为值类型或不可以为 null 的引用类型。请考虑添加 'class'、'struct' 或类型约束。</value>
  </data>
  <data name="CSharpFormatterHighlightingProvider_InternalConfigurableSeverityItems_Multiple_spaces_are_prohibited" xml:space="preserve">
    <value>禁止使用多个空格</value>
  </data>
  <data name="CompilerWarning_CS1998_Title" xml:space="preserve">
    <value>异步方法缺少 "await" 运算符，将以同步方式运行</value>
  </data>
  <data name="NotDisposedEnumeratorDescription" xml:space="preserve">
    <value>为了避免资源泄漏，手动调用 'GetEnumerator' 方法时，在使用后处置生成的枚举器。这具有与自动处理处置的 'foreach' 循环类似的行为。如果枚举器是结构或 sealed 类，则不需要处置，并且不会实现 Dispose 模式或接口。</value>
  </data>
  <data name="CqrsNamingRecommendationDescription" xml:space="preserve">
    <value>可以在不依赖特性的情况下识别遵循命名约定的 CQRS 实体</value>
  </data>
  <data name="XMLCommentHasCrefAttributeThatRefersToATypeParameterMessage" xml:space="preserve">
    <value>XML 注释中有引用类型参数的 cref 特性</value>
  </data>
  <data name="EnumerableSumInvocationInExplicitUncheckedContextMessage" xml:space="preserve">
    <value>在显式 unchecked 上下文中调用 'Enumerable.Sum'</value>
  </data>
  <data name="DuplicateLocalAndGlobalDefinitionOfUsingAliasMessage" xml:space="preserve">
    <value>重复的 using alias '{0}' 的本地和全局定义</value>
  </data>
  <data name="ADefaultLiteraldefaultIsNotValidAsACaseConstantUseAnotherLiteralEGOrnullAsAppropriateIfYouIntendedToWriteTheDefaultLabelUsedefaultWithoutcaseMessage" xml:space="preserve">
    <value>默认字面量 'default' 无法用作 case 常量。请酌情使用其他字面量(如 '0' 或 'null')。如果要编写默认标签，请使用不带 'case' 的 'default:'。</value>
  </data>
  <data name="UseCompilerSupportedNullableAttributesMessage" xml:space="preserve">
    <value>使用编译器支持的可以为 null 的特性</value>
  </data>
  <data name="UseConcreteValueInsteadOfDefaultMessage" xml:space="preserve">
    <value>使用 '{0}' 而不是 '{1}'</value>
  </data>
  <data name="DefaultParameterValueAttributeShouldBeUsedInConjunctionWithOptionalAttribute" xml:space="preserve">
    <value>'DefaultParameterValueAttribute' 应与 'OptionalAttribute' 结合使用</value>
  </data>
  <data name="awaitCannotBeUsedInAnExpressionContainingArefConditionalOperatorMessage" xml:space="preserve">
    <value>'await' 不能用于包含 'ref' 条件运算符的表达式</value>
  </data>
  <data name="CallTobaseEqualsIsReferenceEquality" xml:space="preserve">
    <value>对 'base.Equals(...)' 的调用是引用相等</value>
  </data>
  <data name="InvalidExpressionTermMessage" xml:space="preserve">
    <value>表达式项无效</value>
  </data>
  <data name="InterpolatedStringHandlerMethodHasInconsistentReturnTypeExpectedToReturnMessage" xml:space="preserve">
    <value>内插字符串处理程序方法 '{0}' 的返回值类型不一致。应返回 '{1}'。</value>
  </data>
  <data name="ArraysCannotBeNestedInWinRTPublicAPIMessage" xml:space="preserve">
    <value>数组不能嵌套在 WinRT 公开 API 中</value>
  </data>
  <data name="TheGivenExpressionOfisOperatorIsNeverOfTheProvidedType" xml:space="preserve">
    <value>'is' 运算符的表达式从不为提供的类型</value>
  </data>
  <data name="MultipleCqrsEntityMessage" xml:space="preserve">
    <value>无法识别 CQRS 实体。其名称、实现的接口或特性之间存在冲突。</value>
  </data>
  <data name="CompilerWarning_CS7080_Title" xml:space="preserve">
    <value>CallerMemberNameAttribute 将不起任何作用；它由 CallerFilePathAttribute 重写</value>
  </data>
  <data name="BecauseThisCallIsNotAwaitedExecutionOfTheCurrentMethodContinuesBeforeTheCallIsCompletedConsiderApplyingTheawaitOperatorToTheResultOfTheCallMessage" xml:space="preserve">
    <value>由于此调用不会等待，因此在此调用完成之前将会继续执行当前方法。请考虑将 "await" 运算符应用于调用结果。</value>
  </data>
  <data name="TypeExpectedMessage" xml:space="preserve">
    <value>应为类型</value>
  </data>
  <data name="MemberWithTheSameSignatureAndDefaultImplementationExistsInAnImplementedInterface" xml:space="preserve">
    <value>实现的接口中存在具有相同签名和默认实现的成员</value>
  </data>
  <data name="OperatorWithoutMatchedCheckedOperatorMessage" xml:space="preserve">
    <value>该运算符没有匹配的 checked 运算符，而其他运算符有</value>
  </data>
  <data name="AssignmentInConditionalExpression" xml:space="preserve">
    <value>条件表达式中存在赋值</value>
  </data>
  <data name="ExtractCommonBranchingCodeAfterMessage" xml:space="preserve">
    <value>提取 '{0}' 语句后的通用代码</value>
  </data>
  <data name="ConditionalAccessNotClassifiedAsAVariableHint" xml:space="preserve">
    <value>隐式访问的 '{0}&lt;{1}&gt;.{2}' 属性返回一个临时值。</value>
  </data>
  <data name="ItIsIncorrectToUseNotNullAndCanBeNullSimultaneously" xml:space="preserve">
    <value>同时使用 [NotNull] 和 [CanBeNull] 是不正确的</value>
  </data>
  <data name="CannotResolveParameterMessage" xml:space="preserve">
    <value>无法解析形参 '{0}'</value>
  </data>
  <data name="RedundantObjectToStringCallForValueTypeMessage" xml:space="preserve">
    <value>值类型的冗余 'Object.ToString()' 调用</value>
  </data>
  <data name="PropertiesAndVariablesStaticProperty_RiderPresentableName" xml:space="preserve">
    <value>属性和变量//static 属性</value>
  </data>
  <data name="CompilerWarning_CS0162_Title" xml:space="preserve">
    <value>检测到不可到达的代码</value>
  </data>
  <data name="SimplifyLINQExpressionUseAllMessage" xml:space="preserve">
    <value>简化 LINQ 表达式(使用 'All')</value>
  </data>
  <data name="NonPublicHidesWithDefaultImplementationInInterfaceMessage" xml:space="preserve">
    <value>非 public {0} '{1}' 会隐藏接口{2}中具有默认实现的{0}</value>
  </data>
  <data name="CompilerWarning_CS9264_Title" xml:space="preserve">
    <value>在退出构造函数时，不可为 null 的属性必须包含非 null 值。请考虑添加 'required' 修饰符或将该属性声明为可以为 null，或添加 '[field: MaybeNull, AllowNull]' 特性。</value>
  </data>
  <data name="RedundantTypeDeclarationBody" xml:space="preserve">
    <value>冗余的类型声明主体</value>
  </data>
  <data name="PropertiesAndVariablesCapturedPrimaryConstructorParameter_RiderPresentableName" xml:space="preserve">
    <value>属性和变量//主构造函数形参(已捕获)</value>
  </data>
  <data name="AnnotatingvoidMethodByPureIsMeaninglessMessage" xml:space="preserve">
    <value>使用 [Pure] 注解 'void' 方法毫无意义</value>
  </data>
  <data name="CannotResolveSymbolInTextArgument12" xml:space="preserve">
    <value>不能解析文本实参中的符号</value>
  </data>
  <data name="ArgumentIsWhileParameterIsDeclaredAsMessage" xml:space="preserve">
    <value>实参为 '{0}'，而形参被声明为 '{1}'{2}</value>
  </data>
  <data name="CannotImplicitlyImplementANonPublic_FromInterface_Text" xml:space="preserve">
    <value>{0} '{1}.{2}' 不能从接口 {4} 隐式实现非 public {3}</value>
  </data>
  <data name="CannotBeOverridenByPropertyMessage" xml:space="preserve">
    <value>'{0}' 无法重写 '{1}'，因为后者不是属性</value>
  </data>
  <data name="UsePreferredBracesStyle" xml:space="preserve">
    <value>使用首选大括号样式</value>
  </data>
  <data name="NaNIsNotEqualToAnyFloatingPointNumber_Text" xml:space="preserve">
    <value>NaN 不等于任何浮点数(甚至其本身)。请使用 '{0}' 方法</value>
  </data>
  <data name="ToUseInsteadOfForAnInterpolatedVerbatimStringPleaseUseLanguageVersionOrGreaterMessage" xml:space="preserve">
    <value>要为内插逐字字符串使用 '@$' 而不是 '$@'，请使用语言版本 '8.0' 或更高版本</value>
  </data>
  <data name="PreferExplicitlyProvidedTupleComponentNameMessage" xml:space="preserve">
    <value>首选此元组组件的显式名称 '{0}'</value>
  </data>
  <data name="UseTypeEmptyTypesMessage" xml:space="preserve">
    <value>使用 'Type.EmptyTypes'</value>
  </data>
  <data name="ThePrimaryConstructorConflictsWithTheSynthesizedCopyConstructorMessage" xml:space="preserve">
    <value>主构造函数与合成的复制构造函数冲突</value>
  </data>
  <data name="TheHasNoConstructorsDefinedMessage" xml:space="preserve">
    <value>{0} '{1}' 未定义构造函数</value>
  </data>
  <data name="PossibleIncorrectImplementationOfDoubleCheckLockingReadAccessToCheckedFieldMessage" xml:space="preserve">
    <value>可能错误地实现了双重检查锁定。请对checked 字段进行读取访问。</value>
  </data>
  <data name="DuplicatenotnullTypeConstraintMessage" xml:space="preserve">
    <value>重复的 'notnull' 类型约束</value>
  </data>
  <data name="RedundantstringToCharArrayCall" xml:space="preserve">
    <value>冗余的 'string.ToCharArray()' 调用</value>
  </data>
  <data name="CompilerWarning_CS0105_Title" xml:space="preserve">
    <value>using 指令以前在此命名空间中出现过</value>
  </data>
  <data name="PossibleViolationOfValueRangeNonNegativeValueAttribute" xml:space="preserve">
    <value>可能违反了 'ValueRange'/'NonNegativeValue' 特性</value>
  </data>
  <data name="AVariableMayNotBeDeclaredWithinAnotOrorPatternMessage" xml:space="preserve">
    <value>不能在 'not' 或 'or' 模式中声明变量</value>
  </data>
  <data name="UseNullCheckInsteadOfATypeCheckSucceedingOnAnyNotNullValueMessage" xml:space="preserve">
    <value>在任何非 null 值之后使用 null 检查而非类型检查</value>
  </data>
  <data name="SuspiciousShiftCountForThisTypeOfLeftOperandDifferentFromActualShiftCountThatWillBeUsedByCompiler" xml:space="preserve">
    <value>此类型的左操作数的可疑位移计数(与编译器将要使用的实际位移计数不同)</value>
  </data>
  <data name="RedundantElseKeywordMessage" xml:space="preserve">
    <value>冗余的 '{0}' 关键字</value>
  </data>
  <data name="NonReadonlyTypeMemberReferencedInGetHashCode" xml:space="preserve">
    <value>'GetHashCode()' 中引用了非只读类型成员</value>
  </data>
  <data name="AddOrRemoveTrailingCommaWhenTheLast_Text" xml:space="preserve">
    <value>根据所选代码样式，当最后一个元素后面没有新行时添加或移除尾随逗号</value>
  </data>
  <data name="ForLoopCanBeConvertedIntoForeachLoop" xml:space="preserve">
    <value>for 循环可以转换为 foreach 循环</value>
  </data>
  <data name="AnExpressionTreeMayNotContainPatternMatchingisExpressionMessage" xml:space="preserve">
    <value>表达式树不能包含模式匹配的 'is' 表达式</value>
  </data>
  <data name="RedundantBaseConstructorCallMessage" xml:space="preserve">
    <value>冗余的基构造函数调用</value>
  </data>
  <data name="UseUnsignedRightShiftOperatorInsteadOfManualCasting" xml:space="preserve">
    <value>使用无符号右移运算符 '&gt;&gt;&gt;' 而不是手动转换和移位</value>
  </data>
  <data name="StringEscapeSequenceEscapeUnavailableMessage" xml:space="preserve">
    <value>“字符串转义符”功能不可用。请使用语言版本 {0}。</value>
  </data>
  <data name="AddOrRemoveExplicitTypeSpecificationInnewExpressionWhenTypeIsEvidentFromTheUsage" xml:space="preserve">
    <value>在可以从用法明显看出类型时，在 'new' 表达式中添加或移除显式类型规范</value>
  </data>
  <data name="RedundantExplicitPositionalPropertyDeclarationInRecordTypeWithPrimaryConstructor" xml:space="preserve">
    <value>具有主构造函数的记录类型中存在冗余的显式位置属性声明</value>
  </data>
  <data name="PossiblyImpureStructMethodIsCalledOnReadonlyVariableStructValueAlwaysCopiedBeforeInvocation" xml:space="preserve">
    <value>在只读变量中调用可能不纯的结构方法: 结构值始终在调用前复制</value>
  </data>
  <data name="CompilerWarning_CS8714_Title" xml:space="preserve">
    <value>类型不能用作泛型类型或方法中的类型参数。类型参数的为 Null 性与 "notnull" 约束不匹配。</value>
  </data>
  <data name="UseBracesToSeparatefixedStatementBody" xml:space="preserve">
    <value>使用大括号分隔 'fixed' 语句体</value>
  </data>
  <data name="PossibleMistakenSystemTypeArgumentTitle" xml:space="preserve">
    <value>可能存在 'System.Type' 类型的错误实参</value>
  </data>
  <data name="CommentsDocCommentsTagName_RiderPresentableName" xml:space="preserve">
    <value>注释//文档注释//标记名称</value>
  </data>
  <data name="TheGivenExpressionCannotBeUsedInAfixedStatementBecauseDoesntImplementfixedPatternnoParameterlessGetPinnableReferenceMethodReturningByReferenceFoundMessage" xml:space="preserve">
    <value>表达式不能用于 'fixed' 语句，因为 '{0}' 不实现 'fixed' 模式: {1}找不到通过引用返回 '{2}' 的无形参 'GetPinnableReference' 方法。</value>
  </data>
  <data name="ReplacesIfStatementWithNullPropagatingCodeUsingOperator" xml:space="preserve">
    <value>将 if 语句替换为使用 ?. 运算符的 null 传播代码</value>
  </data>
  <data name="ReplaceConstructorWithMemberInitializers" xml:space="preserve">
    <value>将构造函数替换为内联初始化的成员</value>
  </data>
  <data name="IdentifierExpectedMessage" xml:space="preserve">
    <value>标识符是预期的</value>
  </data>
  <data name="CaseLabelIsMissingMessage" xml:space="preserve">
    <value>缺少 case 标签</value>
  </data>
  <data name="ARefReturningCannotHaveASetterMessage" xml:space="preserve">
    <value>返回{0}的 ref 不能有 setter</value>
  </data>
  <data name="MustHaveInitToImplementMessage" xml:space="preserve">
    <value>'{0}' 必须具有 'init' 访问器而不是 'set' 才能实现{1} '{2}'</value>
  </data>
  <data name="TheGivenExpressionAlwaysMatchesTheProvidedConstantMessage" xml:space="preserve">
    <value>表达式始终与提供的常量匹配</value>
  </data>
  <data name="InitOnlyExtensionPropertyErrorMessage" xml:space="preserve">
    <value>'{0}': 无法声明仅初始化扩展属性</value>
  </data>
  <data name="SimplifyLINQExpressionUseAnyInsteadOfAll" xml:space="preserve">
    <value>简化 LINQ 表达式(使用 'Any' 而非 'All')</value>
  </data>
  <data name="ReplacePropertyPatternMemberSOfRecursivePatternWithPositionalDeconstructionPatternsInExistingPositionalDeconstruction" xml:space="preserve">
    <value>在现有位置析构中将递归模式的属性模式成员替换为位置析构模式</value>
  </data>
  <data name="ReferenceToThisIsImmutableInClassDeclarations_Text" xml:space="preserve">
    <value>对 '{0}' 的引用在{1}声明中不可变。</value>
  </data>
  <data name="CompilerWarning_CS9089_Title" xml:space="preserve">
    <value>这将按引用返回不是 ref 或 out 参数的参数成员</value>
  </data>
  <data name="DuplicateTypeParameterConstraintMessage" xml:space="preserve">
    <value>重复的类型形参约束</value>
  </data>
  <data name="ModifierOnUnnamedExtensionReceiverParameterErrorMessage" xml:space="preserve">
    <value>无法在未命名扩展接收器形参上使用修饰符</value>
  </data>
  <data name="ValueParameterIsNotUsedMessage" xml:space="preserve">
    <value>'{0}' 形参未使用</value>
  </data>
  <data name="CSharpHighlightingCleanupModule_GetModuleActionName" xml:space="preserve">
    <value>处理冗余</value>
  </data>
  <data name="DuplicateDefinitionMessage" xml:space="preserve">
    <value>重复的定义 '{0}'</value>
  </data>
  <data name="ReplaceSubstringWithRangeIndexer" xml:space="preserve">
    <value>将 'Substring' 替换为范围索引器</value>
  </data>
  <data name="MisleadingBodyLikeStatementDescription" xml:space="preserve">
    <value>上一条语句的主体可能会被忽略，下一条语句可能被作为其主体读取。请提升实际主体的可见性，或者用空行分隔下一条语句。</value>
  </data>
  <data name="InitializerValueIgnoredDuringInitializationMessage" xml:space="preserve">
    <value>初始化过程中已忽略{0}初始值设定项值</value>
  </data>
  <data name="CastExpressionCanBeReplacedWithShorterTypeArguments" xml:space="preserve">
    <value>转换表达式可被替换为简化的类型实参</value>
  </data>
  <data name="RemoveRedundantBraces_Text" xml:space="preserve">
    <value>移除冗余大括号</value>
  </data>
  <data name="CompilerWarning_CS2038_Title" xml:space="preserve">
    <value>语言名无效</value>
  </data>
  <data name="PropertiesAndVariablesConstant_RiderPresentableName" xml:space="preserve">
    <value>属性和变量//常量</value>
  </data>
  <data name="TheKeywordVirtualIsRedundantMessage" xml:space="preserve">
    <value>关键字 'virtual' 冗余</value>
  </data>
  <data name="ConstraintCannotBeADynamicTypeMessage" xml:space="preserve">
    <value>约束不能是动态类型“{0}”</value>
  </data>
  <data name="PossiblyUnintendedUsageParameterlessGetExpressionTypeDescription" xml:space="preserve">
    <value>Possible unintended usage of parameterless GetExpressionType() when an instance of IResolveContext is available in the context</value>
  </data>
  <data name="TheConstructorCallNeedsToBeDynamicallyDispatchedButCannotBeBecauseItIsPartOfAConstructorInitializerConsiderCastingTheDynamicArgumentsMessage" xml:space="preserve">
    <value>构造函数调用需要进行动态调度，但无法如此，因为它是构造函数初始值的一部分。请考虑强制转换动态参数。</value>
  </data>
  <data name="AnonymousFunctionsInsideStructsCannotAccessParametersOfPrimaryConstructorMessage" xml:space="preserve">
    <value>结构实例成员中的匿名方法、lambda 表达式、局部函数和查询表达式不能访问主构造函数的形参。请考虑将 'this' 复制到闭包以外的局部变量，并改用该局部变量。</value>
  </data>
  <data name="ParamsCollectionInfiniteChainOfConstructorCallsMessage" xml:space="preserve">
    <value>创建 params 集合 '{0}' 会导致出现构造函数 '{1}' 调用的无限链</value>
  </data>
  <data name="InvocationOfPolymorphicFieldLikeEvent" xml:space="preserve">
    <value>调用多态类似字段的事件</value>
  </data>
  <data name="PossiblyMistakenUseOfCancellationTokenTitle" xml:space="preserve">
    <value>可能错误使用了 'CancellationToken'</value>
  </data>
  <data name="UnderspecifiedExtensionErrorMessage" xml:space="preserve">
    <value>类型形参 '{0}' 未被扩展形参或此成员的形参引用</value>
  </data>
  <data name="Indexer_Text" xml:space="preserve">
    <value>索引器</value>
  </data>
  <data name="EmptyExtensionBlockMessage" xml:space="preserve">
    <value>extension 块为空</value>
  </data>
  <data name="TheModifierasyncIsNotValidForThisItemMessage" xml:space="preserve">
    <value>修饰符 'async' 对此项无效</value>
  </data>
  <data name="BothContextDeclaredMessage" xml:space="preserve">
    <value>{0} 在两种 CQRS 上下文中声明</value>
  </data>
  <data name="ForBuiltInTypes_Caption" xml:space="preserve">
    <value>对于内置类型</value>
  </data>
  <data name="ExpressionTreeMayNotContainUnsignedRightShiftOperatorMessage" xml:space="preserve">
    <value>表达式树不能包含 '&gt;&gt;&gt;'</value>
  </data>
  <data name="CompilerWarning_CS0282_Title" xml:space="preserve">
    <value>在分部结构的多个声明中的字段之间没有已定义的排序方式</value>
  </data>
  <data name="EmptyConstructor" xml:space="preserve">
    <value>空构造函数</value>
  </data>
  <data name="ModuleInitializerMethodMustBeAccessibleAtTheModuleLevelMessage" xml:space="preserve">
    <value>模块初始值设定项方法“{0}”必须可在模块级别被访问</value>
  </data>
  <data name="CompilerWarning_CS9083_Title" xml:space="preserve">
    <value>将按引用返回成员，但它已初始化为无法按引用返回的值</value>
  </data>
  <data name="CompilerWarning_CS8793_Title" xml:space="preserve">
    <value>给定的表达式始终与提供的模式匹配。</value>
  </data>
  <data name="UseBracesToSeparateusingStatementBody" xml:space="preserve">
    <value>使用大括号分隔 'using' 语句体</value>
  </data>
  <data name="AttributesHaveToBeDeclaredInSeparate_Text" xml:space="preserve">
    <value>必须在单独的部分或单个部分中声明特性</value>
  </data>
  <data name="StackallocMayNotBeUsedInACatchOrFinallyBlockMessage" xml:space="preserve">
    <value>stackalloc 不能用于 'catch' 或 'finally' 块</value>
  </data>
  <data name="NonNullableNotSatisfiedInConstructorConsiderDeclaringAsNullablePropertiesMessage" xml:space="preserve">
    <value>在退出构造函数时，不可为 null 的属性{0}必须包含非 null 值。请考虑添加 '{1}' 修饰符或将属性声明为可以为 null。</value>
  </data>
  <data name="InlineArrayUnsupportedElementFieldModifierMessage" xml:space="preserve">
    <value>内联数组元素字段不能声明为 required、readonly、volatile 或固定大小缓冲区</value>
  </data>
  <data name="SimplifyLINQExpressionUseAllInsteadOfAny" xml:space="preserve">
    <value>简化 LINQ 表达式(使用 'All' 而非 'Any')</value>
  </data>
  <data name="CompilerWarning_CS0660_Title" xml:space="preserve">
    <value>类型定义运算符 == 或运算符 !=，但不重写 Object.Equals(object o)</value>
  </data>
  <data name="CSharpFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_child_statement" xml:space="preserve">
    <value>子语句周围</value>
  </data>
  <data name="Optional_Text" xml:space="preserve">
    <value>可选</value>
  </data>
  <data name="NullabilityOfTypeOfParameterInDoesntMatchOverriddenMemberPossiblyBecauseOfNullabilityAttributesMessage" xml:space="preserve">
    <value>{1}中形参 '{0}' 的类型的为 null 性与被重写的成员 '{2}' 不匹配(可能是由于为 null 性特性)</value>
  </data>
  <data name="SimplifyConditionalTernaryExpressionMessage" xml:space="preserve">
    <value>简化条件三元表达式</value>
  </data>
  <data name="ArgumentminIsAlwaysGreaterThanArgumentmax" xml:space="preserve">
    <value>实参 'min' 始终大于实参 'max'</value>
  </data>
  <data name="ConvertAsExpressionTypeCheckAndTheFollowingNullCheckIntoNegatedPatternMatching" xml:space="preserve">
    <value>将 'as' 表达式类型检查以及后续的 null 检查转换为求反模式匹配</value>
  </data>
  <data name="MethodHasAsyncOverloadMessage" xml:space="preserve">
    <value>方法具有异步重载</value>
  </data>
  <data name="EntityFramework_ModelCircularDependencyHighlighting_Title_Text" xml:space="preserve">
    <value>此属性定义的关系可能导致依赖关系循环</value>
  </data>
  <data name="CompilerWarning_CS3008_Title" xml:space="preserve">
    <value>标识符不符合 CLS</value>
  </data>
  <data name="NullabilityOfReferenceTypesInExplicitInterfaceSpecifierDoesntMatchInterfaceImplementedByTheTypeMessage" xml:space="preserve">
    <value>显式接口说明符中引用类型的为 null 性与该类型实现的接口不匹配</value>
  </data>
  <data name="NullabilityOfReturnTypeDoesntMatchImplicitlyImplementedMemberPossiblyBecauseOfNullabilityAttributesMessage" xml:space="preserve">
    <value>返回值类型的为 null 性与隐式被实现的成员 '{0}' 不匹配(可能是由于为 null 性特性)</value>
  </data>
  <data name="readonlyCanOnlyBeUsedOnAccessorsIfTheHasBothAgetAndAsetAccessorMessage" xml:space="preserve">
    <value>只有{0}同时具有 'get' 和 'set' 访问器时才能在访问器上使用 'readonly'</value>
  </data>
  <data name="PossibleComparisonOfValueTypeWithnullMessage" xml:space="preserve">
    <value>可能将值类型于 'null' 比较</value>
  </data>
  <data name="FieldLikeEventCannotBeMarkedreadonlyMessage" xml:space="preserve">
    <value>类似字段的事件 '{0}' 不能被标记为 'readonly'</value>
  </data>
  <data name="CodeCleanupTask_CSOptimizeUsings_RegionName" xml:space="preserve">
    <value>区域名称</value>
  </data>
  <data name="ReplaceSliceWithRangeIndexer" xml:space="preserve">
    <value>将 'Slice' 替换为范围索引器</value>
  </data>
  <data name="IsAttributedWithUnmanagedCallersOnlyAndCannotBeCalledDirectlyObtainAFunctionPointerToThisMethodMessage" xml:space="preserve">
    <value>“{0}”使用 "UnmanagedCallersOnly" 进行特性化，无法直接调用。请获取指向此方法的函数指针。</value>
  </data>
  <data name="ReplaceWith__Text" xml:space="preserve">
    <value>替换为 {0}</value>
  </data>
  <data name="TypeNameExpectedMessage5_NamespaceAddition" xml:space="preserve">
    <value>; '{0}' 是命名空间，而不是类型。请考虑改用 'using namespace' 指令。</value>
  </data>
  <data name="AttributeIsNotValidOnThisDeclarationTypeItIsValidOnDeclarationsOnlyMessage" xml:space="preserve">
    <value>特性 '{0}' 对此声明类型无效。它仅对 '{1}' 声明有效。</value>
  </data>
  <data name="UseUnsignedRightShiftOperatorMessage" xml:space="preserve">
    <value>使用无符号右移运算符 '&gt;&gt;&gt;'</value>
  </data>
  <data name="RedundantClassOrInterfaceSpecificationInBaseTypesList" xml:space="preserve">
    <value>基类型列表中存在冗余的类或接口规范</value>
  </data>
  <data name="PossibleNullReferenceArgumentForParameterInMessage" xml:space="preserve">
    <value>'{1}' 中形参 '{0}' 的可能 null 引用实参</value>
  </data>
  <data name="MisleadingBodyLikeStatementMessage" xml:space="preserve">
    <value>语句可能与上一条语句的主体混淆</value>
  </data>
  <data name="ConvertConstructorToProtectedMessage" xml:space="preserve">
    <value>将构造函数转换为 protected</value>
  </data>
  <data name="CannotSpecifyBothAllowsRefStructAndClassTypeConstraintMessage" xml:space="preserve">
    <value>不能同时指定 'allows ref struct' 和 'class' 类型约束</value>
  </data>
  <data name="InvertCondition_Text" xml:space="preserve">
    <value>反转条件</value>
  </data>
  <data name="AStaticAnonymousFunctionCannotContainAReferenceToMessage" xml:space="preserve">
    <value>static 匿名函数不能包含对 '{0}' 的引用</value>
  </data>
  <data name="AbstractCannotBeSealedMessage" xml:space="preserve">
    <value>abstract {0}不能为 sealed</value>
  </data>
  <data name="ConvertPropertyToAutoPropertyWhenPossible" xml:space="preserve">
    <value>将属性转换为自动属性(如果可能)</value>
  </data>
  <data name="JoinDeclarationAndAssignmentMessage" xml:space="preserve">
    <value>联接声明和赋值</value>
  </data>
  <data name="RedundantorderbyClauseascendingKeyword" xml:space="preserve">
    <value>冗余的 'orderby' 子句 'ascending' 关键字</value>
  </data>
  <data name="CannotSpecifyADefaultValueForAParameterArrayMessage" xml:space="preserve">
    <value>无法为形参集合指定默认值</value>
  </data>
  <data name="UseNameofExpressionToReferenceName" xml:space="preserve">
    <value>使用 'nameof' 表达式引用名称</value>
  </data>
  <data name="TheGivenExpressionCannotBeUsedInAfixedStatementBecauseSignatureOfDoesntMatchTheRequiredfixedPatternmethodMustBeParameterlessAndReturnByReferenceMessage" xml:space="preserve">
    <value>表达式不能在 'fixed' 语句中使用，因为 '{0}' 的签名与所需的 'fixed' 模式不匹配: {1}方法必须为无形参并通过引用返回 '{2}'。</value>
  </data>
  <data name="CodeCleanupTask_RemoveCodeRedundancies" xml:space="preserve">
    <value>删除代码冗余</value>
  </data>
  <data name="CannotCreateDelegateFromBecauseItOrAMethodItOverridesHasAConditionalAttributeMessage" xml:space="preserve">
    <value>不能从 '{0}' 创建委托，因为它或其重写的方法具有 'Conditional' 特性</value>
  </data>
  <data name="DisposeOnUsingVariableMessage" xml:space="preserve">
    <value>变量 '{0}' 由 'using' 语句捕获，当执行超出作用域时将自动处置</value>
  </data>
  <data name="InconsistentArgumentStyleRedundantNameIdentifierMessage" xml:space="preserve">
    <value>实参样式不一致: 名称标识符冗余</value>
  </data>
  <data name="LineDirectiveLineNumberExpectedMessage" xml:space="preserve">
    <value>行号应在 1-16,707,565 范围内</value>
  </data>
  <data name="SystemIndexRequiresANonNegativeArgument" xml:space="preserve">
    <value>'System.Index' 需要非负实参</value>
  </data>
  <data name="CompilerWarning_CS8778_Title" xml:space="preserve">
    <value>常量值可能在运行时溢出(请使用 "unchecked" 语法替代)</value>
  </data>
  <data name="BothConditionalExpressionOperandsMustBerefExpressionsOrNeitherMayBeArefExpressionMessage" xml:space="preserve">
    <value>两个条件表达式操作数必须都为或都不为 'ref' 表达式</value>
  </data>
  <data name="DestructorMustHaveBodyMessage" xml:space="preserve">
    <value>析构函数必须有主体</value>
  </data>
  <data name="RedundantCqrsAttribute_Description" xml:space="preserve">
    <value>CQRS 特性冗余，可以将其移除</value>
  </data>
  <data name="LocalSameNameAsExtensionReceiverParameterErrorMessage" xml:space="preserve">
    <value>'{0}': 形参、局部变量或本地函数不能与扩展形参同名</value>
  </data>
  <data name="CapturedReferenceTovolatileFieldWillNotBeTreatedAsvolatile" xml:space="preserve">
    <value>捕获的对 'volatile' 字段的引用不会被视为 'volatile'</value>
  </data>
  <data name="CanReplaceCastWithShorterTypeArgumentDescription" xml:space="preserve">
    <value>将转换表达式替换为简化的类型实参以增强编译时安全性和代码简洁性</value>
  </data>
  <data name="DoubleNegationIsMeaninglessMessage" xml:space="preserve">
    <value>双重求反毫无意义</value>
  </data>
  <data name="TypeParameterConstraintsDiffersFromDeclaredInOtherPartsMessage" xml:space="preserve">
    <value>类型形参约束与其他部分中声明的不同</value>
  </data>
  <data name="CompilerWarning_CS9256_Title" xml:space="preserve">
    <value>分部属性声明具有签名差异。</value>
  </data>
  <data name="InterceptorSignatureMismatchMessage" xml:space="preserve">
    <value>无法使用拦截器 '{1}' 拦截方法 '{0}'，因为签名不匹配</value>
  </data>
  <data name="LiteralsLengthCanBeReducedByUsingVerbatimString" xml:space="preserve">
    <value>可以通过使用逐字字符串来缩短字面量长度</value>
  </data>
  <data name="DigitSeparatorCannotBeUsedInAPositionWhereItsNotSeparatingTheDigitsMessage" xml:space="preserve">
    <value>不能在不分隔数字的位置使用数字分隔符</value>
  </data>
  <data name="InlineOutVariableDeclarationMessage" xml:space="preserve">
    <value>内联 '{0}' 变量声明</value>
  </data>
  <data name="unsafeContextIsRedundantMessage" xml:space="preserve">
    <value>'unsafe' 上下文冗余</value>
  </data>
  <data name="ConvertStatementBodiedLambdaToExpressionBodiedDoesNotSuggestTheConversionWhenTheExpressionContainsNestedClosuresOrExplicitSideEffects" xml:space="preserve">
    <value>将语句体 lambda 转换为表达式体。当表达式包含嵌套闭包或显式副作用时不建议转换。</value>
  </data>
  <data name="CompilerOnlyProducesXMLDocumentationRelatedWarningsWhenXMLDocumentationOutputGenerationOptionIsEnabledInProjectConfigurationSettingsProjectProperties" xml:space="preserve">
    <value>只有在项目配置设置(项目|属性)中启用“XML 文档”输出生成选项时，编译器才会生成与 XML 文档相关的警告</value>
  </data>
  <data name="Elsewhere_TitleCaption" xml:space="preserve">
    <value>其他地方</value>
  </data>
  <data name="CompilerWarning_CS0665_Title" xml:space="preserve">
    <value>条件表达式中的赋值总是常量</value>
  </data>
  <data name="TargetTypeOfConversionOperator_Text" xml:space="preserve">
    <value>转换运算符的目标类型</value>
  </data>
  <data name="EmptyArgumentListIsRedundantMessage" xml:space="preserve">
    <value>空实参列表冗余</value>
  </data>
  <data name="AConstantValueIsExpectedMessage" xml:space="preserve">
    <value>应输入常量值</value>
  </data>
  <data name="ClassThisReferenceIsImmutable_Text" xml:space="preserve">
    <value>类 'this' 引用不可变。</value>
  </data>
  <data name="RedundantExplicitArraySizeSpecificationMessage" xml:space="preserve">
    <value>冗余的显式数组大小规范</value>
  </data>
  <data name="VariableLengthStringHexEscapeSequenceDescription" xml:space="preserve">
    <value>'\x' 转义序列最多可解释 4 位十六进制数字。为避免后面有多位数字时产生混淆，请考虑使用固定长度的序列，例如: '\u001A' 而不是 '\x1A'。</value>
  </data>
  <data name="SimilarExpressionsComparisonMessage" xml:space="preserve">
    <value>类似表达式比较</value>
  </data>
  <data name="AmbiguousSymbolsInTextArgument13" xml:space="preserve">
    <value>文本实参中存在不明确的符号</value>
  </data>
  <data name="PreferUsingNamedPositionalArgumentForNamedExpressions" xml:space="preserve">
    <value>对命名表达式首选使用命名/位置实参</value>
  </data>
  <data name="SpecifyStringComparisonExplicitlyMessage" xml:space="preserve">
    <value>显式指定字符串比较</value>
  </data>
  <data name="voidMethodIsAnnotatedByMustUseReturnValueAttribute" xml:space="preserve">
    <value>'void' 方法使用 [MustUseReturnValue] 特性注解</value>
  </data>
  <data name="TheSwitchExpressionDoesNotHandleSomeValuesOfItsInputTypeItIsNotExhaustiveInvolvingAnUnnamedEnumValueForExampleThePatternIsNotCoveredMessage" xml:space="preserve">
    <value>switch 表达式不会处理其输入类型的某些值(它不是穷举)，这包括未命名的枚举值。例如，模式“{0}”未包含在内。</value>
  </data>
  <data name="DoesNotImplementInterfaceMemberNullabilityOfReferenceTypesInInterfaceImplementedByTheBaseTypeDoesntMatchMessage" xml:space="preserve">
    <value>'{0}' 不实现接口成员 '{1}'。基类型实现的接口中引用类型的为 null 性不匹配。</value>
  </data>
  <data name="CSharpFormatterHighlightingProvider_InternalConfigurableSeverityItems_Multiple_type_members_on_one_line" xml:space="preserve">
    <value>一行有多个类型成员</value>
  </data>
  <data name="AmbiguousReferenceMessage" xml:space="preserve">
    <value>不明确的{0}。{1}候选项为:{2}</value>
  </data>
  <data name="ItIsRecommendedToUseConfigureAwaitFalseInYourLibraryCodeToPreventContextCaptureInTaskContinuationsThisInspectionIsControlledByTheConfigureAwaitAnalysisModeProjectLevelPropertyWhichIsSetToDisabledByDefaultSetConfigureAwaitAnalysisModeProjectLevelPropertyToLibraryToAnalyzeawaitExpressionsAndStatementsForMissingConfigureAwaitFalseCalls" xml:space="preserve">
    <value>建议在库代码中使用 'ConfigureAwait(false)'，以防止在任务延续符中捕获上下文。
        此检查由 'ConfigureAwait analysis mode' 项目级属性控制，默认情况下，该属性被设置为 'Disabled'。
        将 'ConfigureAwait analysis mode' 项目级属性设置为 'Library' 可分析 'await' 表达式和语句以发现缺少的 'ConfigureAwait(false)' 调用。</value>
  </data>
  <data name="CharIsPossiblyUnintentionallyUsedAsInteger" xml:space="preserve">
    <value>char 可能被无意中用作整数</value>
  </data>
  <data name="DynamicLocalFunctionWithTypeParameterMessage" xml:space="preserve">
    <value>不可将动态类型的参数传递到具有推断类型参数的泛型本地函数“{0}”</value>
  </data>
  <data name="InterpolatedStringHandlerConversionsThatReferenceTheInstanceBeingIndexedCannotBeUsedInIndexerMemberInitializersMessage" xml:space="preserve">
    <value>不能在索引器成员初始值设定项中使用引用正在索引的实例的内插字符串处理程序转换</value>
  </data>
  <data name="InitializerIsNotAllowedForStaticConstructorMessage" xml:space="preserve">
    <value>static 构造函数不允许使用初始值设定项</value>
  </data>
  <data name="CannotRefAssignOutParameterBecauseItWillOverridePossiblyNotInitializedOutParameterReferenceMessage" xml:space="preserve">
    <value>不能为 out 形参 '{0}' 引用赋值，因为它将重写可能未初始化的 out 形参引用</value>
  </data>
  <data name="CanSimplifyDictionaryTryGetValueWithGetValueOrDefaultTitle" xml:space="preserve">
    <value>可以使用 'GetValueOrDefault' 简化字典查找</value>
  </data>
  <data name="CollectionInitializerElementCannotBeNamedMessage" xml:space="preserve">
    <value>不能命名集合初始值设定项元素</value>
  </data>
  <data name="CannotReturnAMemberOfByReferenceBecauseItIsNotArefoutOrinParameterMessage" xml:space="preserve">
    <value>不能通过引用返回{0} '{1}' 的成员，因为它不是 'ref'、'out' 或 'in' 形参</value>
  </data>
  <data name="AConstructorDeclaredInAWithParameterListMustHavethisConstructorInitializerMessage" xml:space="preserve">
    <value>在 '{0}' 中声明的带有形参列表的构造函数必须具有 'this' 构造函数初始值设定项</value>
  </data>
  <data name="LocalVariableIsDeclaredInAWiderScopeThanTheScopeOfItsActualUse" xml:space="preserve">
    <value>局部变量的声明作用域比其实际使用作用域更大</value>
  </data>
  <data name="SimplifyStringInterpolationMessage" xml:space="preserve">
    <value>简化字符串内插</value>
  </data>
  <data name="MemberHidesStaticMemberFromOuterClass" xml:space="preserve">
    <value>成员会隐藏外部类中的 static 成员</value>
  </data>
  <data name="AVoidTaskOrTaskOfTATaskLikeTypeOrAsyncEnumerable__Text" xml:space="preserve">
    <value>一个 '{0}'、'{1}'、'{2}'、类似任务的类型、'{3}' 或 '{4}'</value>
  </data>
  <data name="CodeCleanupTask_ArrangeTypeMemberAccessModifier" xml:space="preserve">
    <value>对类型成员使用显式或隐式修饰符定义</value>
  </data>
  <data name="Redundant_Modifier_Text" xml:space="preserve">
    <value>冗余的 '{0}' 修饰符</value>
  </data>
  <data name="OnlyMethodsOperatorsAndAccessorsCouldContainyieldStatementMessage" xml:space="preserve">
    <value>只有方法、运算符和访问器才能包含 'yield' 语句</value>
  </data>
  <data name="PossibleSystemArgumentOutOfRangeExceptionZeroIndexFromEndDescription" xml:space="preserve">
    <value>在索引表达式中使用 '^0' 会导致 'System.ArgumentOutOfRangeException'；使用 '^1' 引用最后一个元素</value>
  </data>
  <data name="CompilerWarning_CS0078_Title" xml:space="preserve">
    <value>'l' 后缀容易与数字 '1' 混淆</value>
  </data>
  <data name="OtherValueArgumentCodeStyleRule_Description" xml:space="preserve">
    <value>对除字面量、命名和匿名函数外的所有表达式首选使用命名/位置实参</value>
  </data>
  <data name="readonlyKeywordMustFollowrefKeywordAndImmediatelyPrecedeTheTypeMessage" xml:space="preserve">
    <value>'readonly' 关键字必须跟在 'ref' 关键字之后，并紧跟在类型之前</value>
  </data>
  <data name="CompilerWarning_CS8850_Title" xml:space="preserve">
    <value>加载的程序集引用了 .NET Framework，而此操作不受支持。</value>
  </data>
  <data name="KindNameAccessReturnsTemporaryValue_Text" xml:space="preserve">
    <value>{0} 访问返回临时值。</value>
  </data>
  <data name="GenericTypeHasNoValueOrClassConstraintTheConditionCouldBeAlwaysfalse" xml:space="preserve">
    <value>泛型类型没有值或类约束，条件可以始终为 'false'</value>
  </data>
  <data name="VarUsageInDeclarations_Text" xml:space="preserve">
    <value>声明中的 'var' 用法</value>
  </data>
  <data name="MustReturnToMatchTheOverriddenMemberMessage" xml:space="preserve">
    <value>'{0}' 必须返回{1}才能匹配被重写的成员 '{2}'</value>
  </data>
  <data name="CompilerWarning_CS3014_Title" xml:space="preserve">
    <value>由于程序集没有 CLSCompliant 特性，因此不能将类型或成员标记为符合 CLS</value>
  </data>
  <data name="StackAllocResultMayBeExposedOutsideWarningMessage" xml:space="preserve">
    <value>此上下文中的 stackalloc 表达式的结果可能会在包含方法以外公开</value>
  </data>
  <data name="RedundantConfigureAwaitTrueCanBeRemovedThisInspectionIsControlledByTheConfigureAwaitAnalysisModeProjectLevelPropertyWhichIsSetToDisabledByDefaultSetConfigureAwaitAnalysisModeProjectLevelPropertyToUIToAnalyzeawaitExpressionsAndStatementsForRedundantConfigureAwaitTrueCalls" xml:space="preserve">
    <value>可以移除冗余的 'ConfigureAwait(true)' 或 'ConfigureAwait(ConfigureAwaitOptions.ContinueOnCapturedContext)'。此检查由 'ConfigureAwait analysis mode' 项目级别属性控制，默认情况下，该属性被设置为 'Disabled'。
        将 'ConfigureAwait analysis mode' 项目级别属性设置为 'UI' 可分析 'await' 表达式和语句以发现冗余的 'ConfigureAwait' 调用。</value>
  </data>
  <data name="AccessorShouldUseFieldReferenceMessage" xml:space="preserve">
    <value>属性 '{1}' 的 '{0}' 访问器应使用 '{2}'，因为另一个访问器正在使用它。</value>
  </data>
  <data name="CompilerWarning_CS3001_Title" xml:space="preserve">
    <value>参数类型不符合 CLS</value>
  </data>
  <data name="UnresolvedJumpMessage" xml:space="preserve">
    <value>未被解析的跳转</value>
  </data>
  <data name="FunctionNeverReturns" xml:space="preserve">
    <value>函数从未返回</value>
  </data>
  <data name="InitializingFieldPropertyEventWithDefaultValueIsRedundant" xml:space="preserve">
    <value>使用默认值初始化字段/属性/事件冗余</value>
  </data>
  <data name="AParamsParameterCannotBeUsedWiththisModifierOnAnExtensionMethodMessage" xml:space="preserve">
    <value>'params' 形参不能与 'this' 修饰符一起在扩展方法中使用</value>
  </data>
  <data name="PreferUsingNamedPositionalArgumentFor_Text" xml:space="preserve">
    <value>对命名表达式首选使用命名/位置实参</value>
  </data>
  <data name="TypeIsAlreadyImplementedImplicitlyMessage" xml:space="preserve">
    <value>类型 '{0}' 已被隐式实现</value>
  </data>
  <data name="RedundantIEnumerableOfTypeTCallConsiderComparingWithnullInsteadMessage" xml:space="preserve">
    <value>冗余的 'IEnumerable.OfType&lt;T&gt;' 调用。请考虑改为与 'null' 进行比较。</value>
  </data>
  <data name="UsingSymbolRequiresOptingIntoPreviewFeaturesSeeUrl_Text" xml:space="preserve">
    <value>{0}。使用 {1} 需要选择预览功能。如需了解详情，请参阅 {2}。</value>
  </data>
  <data name="MultipleCqrsEntityTitle" xml:space="preserve">
    <value>未识别的 CQRS 实体</value>
  </data>
  <data name="RedundantCaseLabelMessage" xml:space="preserve">
    <value>冗余的 case 标签</value>
  </data>
  <data name="caseLabelStatementWithEnumValueInFrontOfDefaultSectionIsRedundant" xml:space="preserve">
    <value>default 部分前面带有枚举值的 'case' 标签语句冗余</value>
  </data>
  <data name="CanSimplifyDictionaryTryGetValueWithGetValueOrDefaultDescription" xml:space="preserve">
    <value>可以使用 'GetValueOrDefault' 扩展方法简化字典查找</value>
  </data>
  <data name="AsyncIteratorInvocationWithoutawaitForeach" xml:space="preserve">
    <value>没有 'await foreach' 的异步迭代器调用</value>
  </data>
  <data name="ExpressionIsAlwaysAccordingToNullableReferenceTypesAnnotationsMessage" xml:space="preserve">
    <value>根据可以为 null 的引用类型的注解，表达式始终为 {0}</value>
  </data>
  <data name="CallToBaseMemberWithImplicitDefaultParameters24" xml:space="preserve">
    <value>使用隐式默认形参调用基成员</value>
  </data>
  <data name="ItIsNotLegalToUseNullableTypeInAPatternUseTheUnderlyingTypeInsteadMessage" xml:space="preserve">
    <value>在模式中使用可以为 null 的类型 '{0}' 不合法；请改用基础类型 '{1}'</value>
  </data>
  <data name="MethodHasTheReturnValueNamedWhichIsTheSameAsAParameterNameWinRTMethodParametersAndReturnValueMustHaveUniqueNamesUseReturnValueNameAttributeToSpecifyDifferentReturnValueNameMessage" xml:space="preserve">
    <value>方法具有名为 '{0}' 的返回值，该名称与形参名称相同。WinRT 方法形参和返回值必须具有唯一名称，请使用 'ReturnValueNameAttribute' 指定其他返回值名称。</value>
  </data>
  <data name="ConvertStatementBodiedLambdaToExpressionBodiedWhenPossible" xml:space="preserve">
    <value>如果可能，将语句体 lambda 转换为表达式体</value>
  </data>
  <data name="ReturnValueOfIteratorIsNotUsedMessage" xml:space="preserve">
    <value>迭代器的返回值未使用</value>
  </data>
  <data name="CompilerWarning_CS2023_Title" xml:space="preserve">
    <value>/noconfig 选项是在响应文件中指定的，因此被忽略</value>
  </data>
  <data name="DuplicateDictionaryElementInitializationMessage" xml:space="preserve">
    <value>在初始化 '{1}' 集合时发现重复键 '{0}'</value>
  </data>
  <data name="PossiblyMisleadingDefaultValueAttributeUsageToDefineOptionalParameterValue" xml:space="preserve">
    <value>可能使用误导性 'DefaultValueAttribute' 来定义可选形参值</value>
  </data>
  <data name="CannotConvertInitializerType_ToTarget_Text" xml:space="preserve">
    <value>不能将初始值设定项类型 '{0}' 转换为目标类型 '{1}'</value>
  </data>
  <data name="DuplicatedefaultTypeConstraintMessage" xml:space="preserve">
    <value>重复的 'default' 类型约束</value>
  </data>
  <data name="ReturnTypeOfCanBeNonNullableMessage" xml:space="preserve">
    <value>'{0}' 的返回值类型可以设为不可为 null</value>
  </data>
  <data name="CannotUseOfByrefLikeTypePrimaryParameterInsideIntanceMemberMessage" xml:space="preserve">
    <value>不能在实例成员中使用具有类似 ref 的类型 '{1}' 的主构造函数形参 '{0}'</value>
  </data>
  <data name="NotDisposedResourceIsReturnedByPropertyMessage" xml:space="preserve">
    <value>{0} 的返回值必须由被调用者处置</value>
  </data>
  <data name="HidesFromOuterClassMessage" xml:space="preserve">
    <value>{0} '{1}' 会隐藏外部类中的{2}</value>
  </data>
  <data name="PossibleViolationOfValueRangeNonNegativeValueAttributeMessage" xml:space="preserve">
    <value>可能违反了 'ValueRange'/'NonNegativeValue' 特性</value>
  </data>
  <data name="RemoveRedundantBracesIfPossible_Caption" xml:space="preserve">
    <value>尽可能移除冗余的大括号</value>
  </data>
  <data name="GetOnlyAutoPropertyIsReadonlyByDefault_Text" xml:space="preserve">
    <value>只获取自动属性默认为 'readonly'</value>
  </data>
  <data name="CannotInitializeTypeWithACollectionInitializerBecauseItDoesNotImplementSystemCollectionsIEnumerableMessage" xml:space="preserve">
    <value>无法使用集合初始值设定项初始化类型“{0}”，原因是它不实现“System.Collections.IEnumerable”</value>
  </data>
  <data name="AnonymousFunctionsInsideStructsCannotAccessParametersOfPrimaryConstructorAlsoUsedInInstanceMemberMessage" xml:space="preserve">
    <value>结构中的匿名方法、lambda 表达式、局部函数和查询表达式不能访问也在实例成员内部使用的主构造函数。请考虑将 'this' 复制到闭包以外的局部变量，并改用该局部变量。</value>
  </data>
  <data name="ImplicitlyTypedVariables_Text" xml:space="preserve">
    <value>隐式类型化变量</value>
  </data>
  <data name="UseBuiltInTypesMessage" xml:space="preserve">
    <value>使用{0}(内置类型)</value>
  </data>
  <data name="ReplaceWithSingleCallToCount_Text" xml:space="preserve">
    <value>替换为对 Count(..) 的单个调用</value>
  </data>
  <data name="RedundantTypeSpecification_Text" xml:space="preserve">
    <value>冗余类型规范</value>
  </data>
  <data name="MoveLocalFunctionAfterJumpStatement_Title" xml:space="preserve">
    <value>将局部函数放置在 'return' 或 'continue' 之后</value>
  </data>
  <data name="TypeNamesAndCannotDifferInCaseOnlyMessage" xml:space="preserve">
    <value>类型名称 '{0}' 和 '{1}' 不能仅大小写不同</value>
  </data>
  <data name="UseDeconstructionMessage" xml:space="preserve">
    <value>使用析构</value>
  </data>
  <data name="CannotApplyOverloadResolutionPriorityToMember_Text" xml:space="preserve">
    <value>无法在此成员上使用 'OverloadResolutionPriorityAttribute'</value>
  </data>
  <data name="WhenInitializingExplicitlyTypedLocalVariableOrFieldOfArrayTypeArrayCreationExpressionCanBeReplacedWithArrayInitializer" xml:space="preserve">
    <value>初始化显式类型化局部变量或数组类型的字段时，可以将数组创建表达式替换为数组初始值设定项</value>
  </data>
  <data name="TheinitAccessorIsNotValidOnStaticMembersMessage" xml:space="preserve">
    <value>"Init" 访问器对静态成员无效</value>
  </data>
  <data name="MoveVariableDeclarationInsideLoopCondition" xml:space="preserve">
    <value>在循环条件内移动变量声明</value>
  </data>
  <data name="ExpressionIsAlwaysNullMessage" xml:space="preserve">
    <value>表达式始终为 null</value>
  </data>
  <data name="BothMemberDeclarationPartsMustUseTheSameTupleElementNamesMessage" xml:space="preserve">
    <value>'partial' 成员声明的两个部分必须使用相同的元组元素名称。</value>
  </data>
  <data name="Delegate_ReturnType_Text" xml:space="preserve">
    <value>委托 '{0}' 返回值类型</value>
  </data>
  <data name="CompilerWarning_CS8603_Title" xml:space="preserve">
    <value>可能返回 null 引用。</value>
  </data>
  <data name="RightOperandOfDynamicShiftOperationShouldBeConvertibleToint11" xml:space="preserve">
    <value>动态移位运算的右操作数应该可以转换为 'int'</value>
  </data>
  <data name="Increment_Text" xml:space="preserve">
    <value>增量</value>
  </data>
  <data name="CanSimplifyDictionaryRemovingWithSingleCallDescription" xml:space="preserve">
    <value>可以使用具有 out 形参的单个 'Remove' 简化字典条目移除</value>
  </data>
  <data name="UnusedNullableDirectiveDescription" xml:space="preserve">
    <value>可以为 null 的指令不起任何作用，可以安全地移除</value>
  </data>
  <data name="BuiltInTypeReferenceForMemberAccessCodeStyleRule_CategoryText" xml:space="preserve">
    <value>在成员访问表达式中引用内置类型时，首选</value>
  </data>
  <data name="AttributeIsNotValidAtThisPointMessage" xml:space="preserve">
    <value>特性 '{0}' 在此位置无效</value>
  </data>
  <data name="ThePredefinedTypeSystemRuntimeCompilerServicesIsExternalInitMustBeDefinedOrImportedInOrderToDeclareInitOnlySetterMessage" xml:space="preserve">
    <value>必须定义或导入预定义类型 'System.Runtime.CompilerServices.IsExternalInit'，以声明仅初始化 setter</value>
  </data>
  <data name="RefOrOutAreNotValidInThisContextMessage" xml:space="preserve">
    <value>ref 或 out 在此上下文中无效</value>
  </data>
  <data name="NullabilityAttributeUsageWithDeclarationOfVoidOrValueType" xml:space="preserve">
    <value>具有 void 或值类型声明的为 null 性特性用法</value>
  </data>
  <data name="CannotResolveSymbolInTextArgument" xml:space="preserve">
    <value>不能解析文本实参中的符号</value>
  </data>
  <data name="RedundantBoolCompare_SupportChecksForFalse_Title" xml:space="preserve">
    <value>建议移除 '== false' 检查</value>
  </data>
  <data name="CompilerWarning_CS0420_Title" xml:space="preserve">
    <value>对可变字段的引用不被视为可变字段</value>
  </data>
  <data name="PossibleOverflowInUncheckedContext" xml:space="preserve">
    <value>在 unchecked 上下文中可能溢出</value>
  </data>
  <data name="RemoveRedundantBraces" xml:space="preserve">
    <value>移除冗余大括号</value>
  </data>
  <data name="RedundantControlFlowJumpStatementMessage" xml:space="preserve">
    <value>冗余的控制流跳过语句</value>
  </data>
  <data name="RefReturnCapturesMemberOfLocalEntityWarningMessage" xml:space="preserve">
    <value>'{0}' 的成员通过引用返回，但已被初始化为不能通过引用返回的值</value>
  </data>
  <data name="AConstructorDeclaredInAWithParameterListMustHaveAthisInitializerThatCallsThePrimaryConstructorOrAnExplicitlyDeclaredConstructorMessage" xml:space="preserve">
    <value>在 '{0}' 中声明的带有形参列表的构造函数必须具有调用主构造函数或显式声明的构造函数的 'this' 初始值设定项</value>
  </data>
  <data name="WinRTDoesNotSupportSetterOnlyPropertiesMessage" xml:space="preserve">
    <value>WinRT 不支持仅 setter 属性</value>
  </data>
  <data name="CompilerWarning_CS0435_Title" xml:space="preserve">
    <value>命名空间与导入类型冲突</value>
  </data>
  <data name="Capitalized_Field_Text" xml:space="preserve">
    <value>字段</value>
  </data>
  <data name="ActualShiftCountEqualsZeroLeftOperandWillRemainUnchanged" xml:space="preserve">
    <value>实际位移计数等于零。左操作数将保持不变。</value>
  </data>
  <data name="CompilerWarning_CS9197_Title" xml:space="preserve">
    <value>形参的引用种类修饰符与被隐藏的成员中的相应形参不匹配</value>
  </data>
  <data name="ClassCannotBeInstantiatedMessage" xml:space="preserve">
    <value>类不能实例化</value>
  </data>
  <data name="CompilerWarning_CS1927_Title" xml:space="preserve">
    <value>对模块忽略 /win32manifest，因为它仅应用于程序集</value>
  </data>
  <data name="ThereIsNoImplicitConversionBetweenAndMessage" xml:space="preserve">
    <value>'{0}' 与 '{1}' 之间没有隐式转换</value>
  </data>
  <data name="FixedSizeFieldCannotBeDeclaredReadonlyMessage" xml:space="preserve">
    <value>固定大小的字段不能被声明为 readonly</value>
  </data>
  <data name="TypeUsedInAMustBeImplicitlyConvertibleToSystemIDisposableMessage" xml:space="preserve">
    <value>{1}中使用的类型 '{0}' 必须可隐式转换为 '{2}'</value>
  </data>
  <data name="TypeCannotBeUsedInforeachStatementBecauseItNeitherImplementsIEnumerableOrIEnumerableTNorHasSuitableGetEnumeratorMethodWhichReturnTypeHasCurrentPropertyAndMoveNextMethodDidYouMeanToUseawaitForeachInsteadOfforeachMessage" xml:space="preserve">
    <value>只有类型 '{0}' 实现 'IEnumerable' 或 'IEnumerable&lt;T&gt;'，或者具有合适的 'GetEnumerator' 方法(返回值类型具有 'Current' 属性和 'MoveNext' 方法)，才能用于 'foreach' 语句。您是要使用 'await foreach' 而不是 'foreach' 吗?</value>
  </data>
  <data name="NullabilityOfReferenceTypesInReturnTypeDoesntMatchPartialMethodDeclarationMessage" xml:space="preserve">
    <value>返回值类型中引用类型的为 null 性在方法声明的各部分之间不匹配</value>
  </data>
  <data name="CannotBereadonlyMessage" xml:space="preserve">
    <value>{0}不能为 'readonly'</value>
  </data>
  <data name="CompilerWarning_CS8766_Title" xml:space="preserve">
    <value>返回类型中引用类型的为 Null 性与隐式实现的成员不匹配(可能是由于为 Null 性特性)。</value>
  </data>
  <data name="TheSourceExpressionOfisOperatorOrswitchStatementAlwaysMatchesTheProvidedPattern" xml:space="preserve">
    <value>'is' 运算符或 'switch' 语句的源表达式始终与提供的模式匹配</value>
  </data>
  <data name="NullabilityInConstraintsForTypeParameterOfMethodDoesntMatchTheConstraintsForTypeParameterTOfInterfaceMethodConsiderUsingAnExplicitInterfaceImplementationInsteadMessage" xml:space="preserve">
    <value>方法 '{1}' 的类型形参 '{0}' 的约束中的为 null 性与接口方法 '{2}' 类型形参 'T' 的约束不匹配。请考虑改用显式接口实现。</value>
  </data>
  <data name="ConditionalExpressionCanBeRewrittenAsNullCoalescing" xml:space="preserve">
    <value>条件表达式可被重写为 null 合并</value>
  </data>
  <data name="ValueTypeIsImplicitlyConvertibleToItsNullableSoExplicitNullableTypeCreationIsRedundant" xml:space="preserve">
    <value>值类型可以隐式转换为其可以为 null 的形式，因此显式可以为 null 的类型创建冗余</value>
  </data>
  <data name="ExplicitNameSpecificationOfAnonymousTypePropertyIsRedundantItIsInferredFromInitializerExpression" xml:space="preserve">
    <value>匿名类型属性的显式名称规范冗余。它是从初始值设定项表达式中推断得出的。</value>
  </data>
  <data name="CannotUseOfByrefLikeTypeInsideMessage" xml:space="preserve">
    <value>不能在{3}内使用类似 byref 的类型 '{2}' 的{0} '{1}'</value>
  </data>
  <data name="JoinLocalVariableDeclarationAndAssignment3" xml:space="preserve">
    <value>联接局部变量声明和赋值</value>
  </data>
  <data name="UseArrayCreationExpression_Text" xml:space="preserve">
    <value>使用数组创建表达式</value>
  </data>
  <data name="StaticMemberCannotBeReferencedInASubpatternMessage" xml:space="preserve">
    <value>不能在子模式中引用 static 成员 '{0}'</value>
  </data>
  <data name="DoesNotContainAConstructorMessage" xml:space="preserve">
    <value>'{0}' 不包含构造函数 '{0}({1})'</value>
  </data>
  <data name="partialMemberDeclarationsMustBeEitherBothOrNeitherRequiredMessage" xml:space="preserve">
    <value>'partial' 成员声明必须两个都为 'required' 或都不为 'required'</value>
  </data>
  <data name="CanSimplifyDictionaryLookupWithTryGetValueDescription" xml:space="preserve">
    <value>可以使用 'TryGetValue' 简化字典查找</value>
  </data>
  <data name="IncludeUnconstrainedGenericsSettingsDescription" xml:space="preserve">
    <value>警告无约束泛型类型的主要构造函数形参的可能变异(仅当泛型类型将被值类型替换时才会发生变异)</value>
  </data>
  <data name="CompilerWarning_CS8965_Title" xml:space="preserve">
    <value>应用于参数的 CallerArgumentExpressionAttribute 将不起任何作用，因为它是自引用的。</value>
  </data>
  <data name="InstanceExtensionMemberWithUnnamedReceiverParameterErrorMessage" xml:space="preserve">
    <value>无法在具有未命名接收器形参的扩展中声明实例成员</value>
  </data>
  <data name="CompilerWarning_CS1981_Title" xml:space="preserve">
    <value>使用 "is" 测试与 "dynamic" 的兼容性和测试与 "object" 的兼容性实质上是相同的</value>
  </data>
  <data name="TypeParameterHasTheClassTypeConstraintSoCannotBeUsedAsAConstraintForMessage" xml:space="preserve">
    <value>类型形参 '{0}' 具有类类型约束，因此 '{1}' 不能用作 '{2}' 的约束</value>
  </data>
  <data name="MemoryStackAllocationInsideALoopCanCauseATemporaryMemoryLeakBecauseTheAllocatedMemoryIsFreedOnlyWhenTheMethodReturns" xml:space="preserve">
    <value>循环内的内存堆栈分配可能会导致临时内存泄漏，因为仅在方法返回时才会释放分配的内存</value>
  </data>
  <data name="TheisExpressionMustBeAValueFoundMessage" xml:space="preserve">
    <value>'is' 表达式必须为值；实际为 '{0}'</value>
  </data>
  <data name="EntityFramework_UnlimitedStringLengthHighlighting_Title_Text" xml:space="preserve">
    <value>由于字符串长度不受限，可能会出现性能问题</value>
  </data>
  <data name="CompilerWarning_CS8784_Title" xml:space="preserve">
    <value>生成器初始化失败。</value>
  </data>
  <data name="MethodReturnTypes_Text" xml:space="preserve">
    <value>方法返回值类型</value>
  </data>
  <data name="AnExpressionCannotBeUsedInThisContextBecauseItMayNotBePassedOrReturnedByReferenceMessage" xml:space="preserve">
    <value>表达式不能在此上下文中使用，因为它不能通过引用传递或返回</value>
  </data>
  <data name="AModuleInitializerMustBeAnOrdinaryMemberMethodMessage" xml:space="preserve">
    <value>模块初始值设定项必须是普通成员方法</value>
  </data>
  <data name="CompilerWarning_CS8632_Title" xml:space="preserve">
    <value>只能在 "#nullable" 注释上下文内的代码中使用可为 null 的引用类型的注释。</value>
  </data>
  <data name="TypeUsedInAMustBeImplicitlyConvertibleToSystemIDisposableDidYouMeanToUseawaitUsingInsteadOfusingMessage" xml:space="preserve">
    <value>{1}中使用的类型 '{0}' 必须可隐式转换为 '{2}'。您是要使用 '{3}' 而不是 '{4}' 吗?</value>
  </data>
  <data name="GetInitAutoPropertyIsReadonlyByDefault_Text" xml:space="preserve">
    <value>{ get; init; } 自动属性默认为 'readonly'</value>
  </data>
  <data name="GlobalUsingDirectiveIsNotRequiredByTheCodeAndCanBeSafelyRemovedMessage" xml:space="preserve">
    <value>代码不需要 global using 指令，可以将其安全地移除</value>
  </data>
  <data name="MergeSequentialChecksIntoSingleConditionalAccessCheckWhenPossible" xml:space="preserve">
    <value>将顺序检查合并到单个条件访问检查中(如果可能)</value>
  </data>
  <data name="RedundantNullnessAttributeWithNullableReferenceTypesSettingKeepRedundantJetBrainsAnnotationsOnPublicAPITitle" xml:space="preserve">
    <value>在公共 API 中保留 JetBrains.Annotations 特性</value>
  </data>
  <data name="CommentsDocCommentsAttribute_RiderPresentableName" xml:space="preserve">
    <value>注释//文档注释//特性</value>
  </data>
  <data name="RedundantDictionaryContainsKeyBeforeAddingMessage" xml:space="preserve">
    <value>在将条目添加到字典之前，'ContainsKey' 调用冗余</value>
  </data>
  <data name="VarUsageInDiscardDeclarations_Text" xml:space="preserve">
    <value>弃元声明中的 'var' 用法</value>
  </data>
  <data name="CannotConstructvoidTypeMessage" xml:space="preserve">
    <value>不能构造 'void' 类型</value>
  </data>
  <data name="CCompilerErrors_Text" xml:space="preserve">
    <value>C# 编译器错误</value>
  </data>
  <data name="InconsistentAccessibilityConstraintTypeIsLessAccessibleThanMessage" xml:space="preserve">
    <value>可访问性不一致: 约束类型 '{0}' 的可访问性低于{1} '{2}'</value>
  </data>
  <data name="CompilerWarning_CS9100_Title" xml:space="preserve">
    <value>参数在 lambda 中具有参数修饰符，但在目标委托类型中没有参数修饰符。</value>
  </data>
  <data name="StructMembersCannotReturnthisOrOtherInstanceMembersByReferenceMessage" xml:space="preserve">
    <value>结构成员无法通过引用返回 "this" 或其他实例成员</value>
  </data>
  <data name="TheResultOfTheExpressionIsAlwaysSinceAValueOfTypeIsNeverEqualTonullOfTypeMessage" xml:space="preserve">
    <value>表达式的结果始终为 '{0}'，因为 '{1}' 类型的值从不等于 '{2}' 类型的 'null'</value>
  </data>
  <data name="InvalidExperimentalDiagnosticIdMessage" xml:space="preserve">
    <value>'Experimental' 特性的 diagnosticId 实参必须是有效的标识符</value>
  </data>
  <data name="TheAnnotationForNullableReferenceTypesShouldOnlyBeUsedInCodeWithinANullableAnnotationsContextMessage" xml:space="preserve">
    <value>只能在 "#nullable" 注释上下文内的代码中使用可为 null 的引用类型的注释</value>
  </data>
  <data name="ThreadStaticHasInitializerItWillBeEvaluatedOnlyOnceMessage" xml:space="preserve">
    <value>线程 static {0}具有初始值设定项: 仅由第一个线程对其求一次值(在调用包含类型的 static 构造函数时)，其他线程将观察{0}的默认值</value>
  </data>
  <data name="privateModifierCanBeSafelyAddedRemovedFromTypeMembersWithoutChangingCodeSemantics" xml:space="preserve">
    <value>可以安全地在类型成员中添加/移除 'private' 修饰符而不更改代码语义</value>
  </data>
  <data name="ReplaceOrdinaryVariableDeclarationWithInlineVariableDeclarationUnderOutArgument" xml:space="preserve">
    <value>将普通变量声明替换为 'out' 实参下的内联变量声明</value>
  </data>
  <data name="CannotCreateDelegateFromMethodBecauseItIsAPartialMethodWithoutAnImplementingDeclarationMessage" xml:space="preserve">
    <value>无法通过方法“{0}”创建委托，因为该方法是没有实现声明的分部方法</value>
  </data>
  <data name="CompilerWarning_CS8882_Title" xml:space="preserve">
    <value>控制离开方法之前必须对 out 参数赋值</value>
  </data>
  <data name="EmptySwitchBlockMessage" xml:space="preserve">
    <value>空的 switch 块</value>
  </data>
  <data name="AnonymousTypeProjectionInitializerShouldBeSimpleNameOrMemberAccessExpressionMessage" xml:space="preserve">
    <value>匿名类型投影初始值设定项应为简单名称或成员访问表达式</value>
  </data>
  <data name="APrimaryConstructorParameter_OfAReadonly_Text" xml:space="preserve">
    <value>'{1}' 类型的主构造函数形参 '{0}' 无法分配(在该类型的仅初始化 setter 或变量初始值设定项中除外)。</value>
  </data>
  <data name="VariableLengthStringHexEscapeSequenceMessage" xml:space="preserve">
    <value>避免混合可变长度的转义序列和文本</value>
  </data>
  <data name="MergeNestedPropertyPatterns" xml:space="preserve">
    <value>合并嵌套属性模式</value>
  </data>
  <data name="AutoPropertysetAccessorCannotBeMarkedreadonlyMessage" xml:space="preserve">
    <value>自动属性 'set' 访问器不能被标记为 'readonly'</value>
  </data>
  <data name="AGotoCannotJumpToALocationBeforeAUsingVariableDeclarationWithinTheSameBlockMessage" xml:space="preserve">
    <value>goto 不能跳转到同一个块中 using 变量声明之前的位置</value>
  </data>
  <data name="CompilerWarning_CS7023_Title" xml:space="preserve">
    <value>“is”或“as”运算符的第二个操作数不能是静态类型</value>
  </data>
  <data name="CodeCleanupTask_ArrangeCodeBodyStyle" xml:space="preserve">
    <value>应用代码主体样式(表达式主体与块主体)</value>
  </data>
  <data name="UseNegatedPatternMessage" xml:space="preserve">
    <value>使用求反模式</value>
  </data>
  <data name="RecordsMayOnlyInheritFromObjectOrAnotherRecordMessage" xml:space="preserve">
    <value>记录只能从对象或另一个记录继承</value>
  </data>
  <data name="ItIsNotLegalToUseStaticClassTypeInAPatternMessage" xml:space="preserve">
    <value>在模式中使用 static 类类型 '{0}' 不合法</value>
  </data>
  <data name="EmptyGeneralCatchClause" xml:space="preserve">
    <value>空常规 catch 子句</value>
  </data>
  <data name="intIsDefaultUnderlyingTypeOfEnumSoItIsNotNecessaryToSpecifyItExplicitly" xml:space="preserve">
    <value>'int' 是默认的枚举基础类型，因此无需显式指定</value>
  </data>
  <data name="IteratorsCannotHaveByReferenceLocalsMessage" xml:space="preserve">
    <value>迭代器不能有按引用局部变量</value>
  </data>
  <data name="InOrderToBeApplicableAsAShortCircuitOperatorAUserDefinedLogicalOperatorMustHaveTheSameReturnTypeAsTheTypeOfItsParametersMessage" xml:space="preserve">
    <value>为了能够用作短路运算符，用户定义的逻辑运算符('{0}')必须具有与其 2 个形参的类型相同的返回值类型</value>
  </data>
  <data name="RedundantDiscardDesignationMessage" xml:space="preserve">
    <value>冗余的弃元指定</value>
  </data>
  <data name="CompilerWarning_CS1911_Title" xml:space="preserve">
    <value>通过匿名方法、lambda 表达式、查询表达式或迭代器中的 'base' 关键字访问成员会产生无法验证的代码。</value>
  </data>
  <data name="BackingFieldForAutoProperty_Text" xml:space="preserve">
    <value>自动属性的支持字段</value>
  </data>
  <data name="UnscopedRefAttributeUnsupportedMemberTargetMessage" xml:space="preserve">
    <value>'UnscopedRefAttribute' 只能应用于结构或虚拟接口实例方法和属性，不能应用于构造函数或仅初始化成员</value>
  </data>
  <data name="MergeNullPatternChecksIntoComplexPattern" xml:space="preserve">
    <value>将 null/模式检查合并到复杂模式中</value>
  </data>
  <data name="DelegatesCannotHaveArglistParametersMessage" xml:space="preserve">
    <value>委托不能有 '__arglist' 形参</value>
  </data>
  <data name="ConflictCqrsAttributeTitle" xml:space="preserve">
    <value>冲突的 CQRS 特性</value>
  </data>
  <data name="AnAttributeArgumentArrayCreationMustBeSingleDimensionArrayOfTypeMessage" xml:space="preserve">
    <value>特性实参数组创建必须为 '{0}' 类型的一维数组</value>
  </data>
  <data name="TheOperatorRequiresAMatchingOperatortruefalseToAlsoBeDefinedMessage" xml:space="preserve">
    <value>运算符 '{0}' 也要求定义匹配的 'true'/'false' 运算符</value>
  </data>
  <data name="BitwiseOperationOnEnumWhichIsNotMarkedByFlagsAttributeMessage" xml:space="preserve">
    <value>枚举上的按位运算未通过 [Flags] 特性进行标记</value>
  </data>
  <data name="CompilerWarning_CS1580_Title" xml:space="preserve">
    <value>XML 注释 cref 特性中参数的类型无效</value>
  </data>
  <data name="CompilerWarning_CS0067_Title" xml:space="preserve">
    <value>事件从未使用过</value>
  </data>
  <data name="TypeOrExpectedMessage" xml:space="preserve">
    <value>应为类型或 []</value>
  </data>
  <data name="CompilerWarning_CS9179_Title" xml:space="preserve">
    <value>主构造函数形参被基中的成员隐藏。</value>
  </data>
  <data name="ToStringCallCouldBeReplacedWithAFormatSpecifier" xml:space="preserve">
    <value>'.ToString()' 调用可被替换为格式说明符</value>
  </data>
  <data name="InvalidXMLDocumentationComment" xml:space="preserve">
    <value>XML 文档注释无效</value>
  </data>
  <data name="ConflictingStaticExtensionTypeArgumentErrorMessage_QualifierTypeArgument" xml:space="preserve">
    <value>限定符指定: {0}</value>
  </data>
  <data name="CannotSpecifyTheDefaultMemberAttributeOnTypeContainingAnIndexerMessage" xml:space="preserve">
    <value>不能在包含索引器的类型上指定 DefaultMember 特性</value>
  </data>
  <data name="FixedSizeBufferCannotBeAccessedThroughUsedInsideAMessage" xml:space="preserve">
    <value>不能通过{2}内使用的 {0} '{1}' 访问固定大小的缓冲区</value>
  </data>
  <data name="AnAnonymousFunctionOrMethodGroupCannotBeUsedAsAConstituentValueOfADynamicallyBoundOperationMessage" xml:space="preserve">
    <value>匿名函数或方法组不能用作动态绑定运算的组成值</value>
  </data>
  <data name="ObjectReferenceEqualsIsAlwaysFalseBecauseItIsCalledWithValueType1" xml:space="preserve">
    <value>'Object.ReferenceEquals' 始终为 false，因为它使用值类型进行调用</value>
  </data>
  <data name="RedundantExplicitPositionalPropertyDeclarationMessage" xml:space="preserve">
    <value>冗余的显式位置属性声明</value>
  </data>
  <data name="AnonymousMethodExpression_Text" xml:space="preserve">
    <value>匿名方法表达式</value>
  </data>
  <data name="ApartialMemberMustBeDeclaredWithinApartialClassOrStructMessage" xml:space="preserve">
    <value>'partial' 成员必须在 'partial' 类或结构中声明</value>
  </data>
  <data name="ParenthesesSurroundingAPatternAreRedundantIfTheyDontChangePrecedenceOforandPatterns" xml:space="preserve">
    <value>如果模式周围的圆括号不改变 `or`-/`and` 模式的优先级，则它们冗余</value>
  </data>
  <data name="CompilerWarning_CS3023_Title" xml:space="preserve">
    <value>CLSCompliant 特性在应用于返回类型时无意义</value>
  </data>
  <data name="AMethodMarkedDoesNotReturnShouldNotReturnMessage" xml:space="preserve">
    <value>不应返回标记为 [DoesNotReturn] 的方法</value>
  </data>
  <data name="CannotConvertAnonymousMethodReturnTypeMessage" xml:space="preserve">
    <value>不能将 lambda 表达式转换为类型 '{0}'，因为返回值类型与委托返回值类型不匹配</value>
  </data>
  <data name="IncompleteDataUsageMessage" xml:space="preserve">
    <value>使用导航属性可能会返回不完整的数据</value>
  </data>
  <data name="CapturedFieldReferenceOfAMarshalByReferenceClassMayCauseARuntimeException" xml:space="preserve">
    <value>引用封送类的捕获字段引用可能会导致运行时异常</value>
  </data>
  <data name="ConvertToLambdaExpressionSettingApplyStyleHeuristicsTitle" xml:space="preserve">
    <value>应用代码样式启发</value>
  </data>
  <data name="AGlobalUsingDirectiveMustPrecedeAllNonGlobalUsingDirectivesMessage" xml:space="preserve">
    <value>global using 指令必须在所有非 global using 指令之前</value>
  </data>
  <data name="CannotUseUnsafeConstructInSafeContextMessage" xml:space="preserve">
    <value>不能在 safe 上下文中使用 unsafe 构造</value>
  </data>
  <data name="StaticFieldOrAutoPropertyInGenericTypeMayResultInStateDuplicationPerEachGenericTypeInstantiation" xml:space="preserve">
    <value>泛型类型中的 static 字段或自动属性可能导致每个泛型类型实例化的状态重复</value>
  </data>
  <data name="TheDelegateTypeCouldNotBeInferredMessage" xml:space="preserve">
    <value>无法推断委托类型</value>
  </data>
  <data name="RedundantVerbatimStringPrefix" xml:space="preserve">
    <value>冗余的逐字字符串字符串前缀</value>
  </data>
  <data name="PossibleOverflowInCheckedContext" xml:space="preserve">
    <value>在 checked 上下文中可能溢出</value>
  </data>
  <data name="EnforceBracesInFixedStatement_Caption" xml:space="preserve">
    <value>在 'fixed' 语句中强制使用大括号</value>
  </data>
  <data name="ArgumentsMismatchMessage" xml:space="preserve">
    <value>实参不匹配</value>
  </data>
  <data name="ReadOnlySpanNotResolvedMessage" xml:space="preserve">
    <value>类型 'System.ReadOnlySpan' 未被解析</value>
  </data>
  <data name="ArgumentOfTypeCannotBeUsedForParameterOfTypeInDueToDifferencesInTheNullabilityOfReferenceTypesMessage" xml:space="preserve">
    <value>'{0}' 类型的实参不能用作 '{3}' 中 '{1}' 类型的形参 '{2}'，因为引用类型的为 null 性不同</value>
  </data>
  <data name="RefFieldInNonRefStructMessage" xml:space="preserve">
    <value>'ref' 字段只能在 'ref' 结构中声明</value>
  </data>
  <data name="RedundantRangeBound" xml:space="preserve">
    <value>冗余的范围界限</value>
  </data>
  <data name="InvocationOfvirtualOroverrideFieldLikeEventLeadsToUnpredictableResultSinceInvocationListIsNotVirtual" xml:space="preserve">
    <value>调用 'virtual' 或 'override' 类似字段的事件会导致不可预知的结果，因为调用列表不为 virtual</value>
  </data>
  <data name="UsageOfDefaultStructEqualityTitle" xml:space="preserve">
    <value>默认结构相等性的用法</value>
  </data>
  <data name="PossibleSystemInvalidOperationExceptionCollectionWasModifiedMessage" xml:space="preserve">
    <value>可能的 'System.InvalidOperationException: 集合已被修改'</value>
  </data>
  <data name="UsePositionalDeconstructionPattern" xml:space="preserve">
    <value>使用位置析构模式</value>
  </data>
  <data name="PossibleMistakenCallToGetTypeMessage" xml:space="preserve">
    <value>可能存在错误的 'GetType()' 调用</value>
  </data>
  <data name="CompilerWarning_CS8887_Title" xml:space="preserve">
    <value>使用未赋值的局部变量</value>
  </data>
  <data name="StyleCopDefaults_Text" xml:space="preserve">
    <value>StyleCop 默认值</value>
  </data>
  <data name="ParenthesesAreRedundantIfAttributeHasNoArguments" xml:space="preserve">
    <value>如果特性没有实参，则圆括号冗余</value>
  </data>
  <data name="CompilerWarning_CS8971_Title" xml:space="preserve">
    <value>应用于 lambda 参数时，InterpolatedStringHandlerArgument 不起任何作用，并将在调用点被忽略。</value>
  </data>
  <data name="RedundantDiscardDesignation" xml:space="preserve">
    <value>冗余的弃元指定</value>
  </data>
  <data name="MissingTypeSpecification_Text" xml:space="preserve">
    <value>缺少类型规范</value>
  </data>
  <data name="SuggestVarOrType_DeconstructionDeclarationsSettingAlwaysKeepVarInMultiVariableDeconstructionTitle" xml:space="preserve">
    <value>将 'var' 关键字保持在圆括号外: 'var (x, y, ...) = source'</value>
  </data>
  <data name="ConditionalAccessExpressionCannotBeUsedAsOperandMessage" xml:space="preserve">
    <value>条件访问表达式不能用作{0}操作数</value>
  </data>
  <data name="TopLevelStatementsMustPrecedeNamespaceAndTypeDeclarationsMessage" xml:space="preserve">
    <value>顶级语句必须位于命名空间和类型声明之前</value>
  </data>
  <data name="InterfaceCannotContainInstanceFieldsMessage" xml:space="preserve">
    <value>接口不能包含实例字段</value>
  </data>
  <data name="CannotConvertNullLiteralToNonNullableReferenceTypeMessage" xml:space="preserve">
    <value>无法将 null 字面量转换为不可为 null 的引用类型</value>
  </data>
  <data name="caseLabelStatementIsRedundant" xml:space="preserve">
    <value>'case' 标签语句冗余</value>
  </data>
  <data name="InitOnlyCanOnlyBeAssignedInAnObjectInitializerOrOnthisOrbaseInAnInstanceConstructorOrAninitAccessorMessage" xml:space="preserve">
    <value>仅初始化{0} '{1}' 只能在对象初始值设定项中分配，或者在实例构造函数或 'init' 访问器中分配给 'this' 或 'base'</value>
  </data>
  <data name="DuplicateDefinitionPossiblyMissingKeywordpartialMessage" xml:space="preserve">
    <value>重复的定义 '{0}'。可能缺少关键字 'partial'</value>
  </data>
  <data name="TheResultOfTheExpressionIsAlwaysnullOfTypeMessage" xml:space="preserve">
    <value>表达式的结果始终为 '{0}' 类型的 'null'</value>
  </data>
  <data name="CannotUseAttributeConstructorBecauseItHasinParameterMessage" xml:space="preserve">
    <value>不能使用特性构造函数 '{0}'，因为它具有 'in' 或 'ref readonly' 形参</value>
  </data>
  <data name="RedundantConfigureAwaitTrueCanBeRemovedMessage" xml:space="preserve">
    <value>可以移除冗余的 'ConfigureAwait'</value>
  </data>
  <data name="CompilerWarning_CS7035_Title" xml:space="preserve">
    <value>指定版本字符串不符合建议格式 - major.minor.build.revision</value>
  </data>
  <data name="BracesAndOperatorsComma_RiderPresentableName" xml:space="preserve">
    <value>大括号和运算符//逗号</value>
  </data>
  <data name="RequiredMemberMustBeSettableMessage" xml:space="preserve">
    <value>必需成员 '{0}' 必须为可设置</value>
  </data>
  <data name="CompilerWarning_CS9067_Title" xml:space="preserve">
    <value>已多次指定分析器引用</value>
  </data>
  <data name="InterfaceCannotContainInstanceConstructorMessage" xml:space="preserve">
    <value>接口不能包含实例构造函数</value>
  </data>
  <data name="AnExpressionTreeLambdaCannotContainAninoutOrrefParameterMessage" xml:space="preserve">
    <value>表达式树 lambda 不能包含 'in'、'out' 或 'ref' 形参</value>
  </data>
  <data name="CompilerWarning_CS1030_Title" xml:space="preserve">
    <value>#warning 指令</value>
  </data>
  <data name="sealedModifierForMemberInASealedClassIsRedundant" xml:space="preserve">
    <value>sealed 类中成员的 'sealed' 修饰符冗余</value>
  </data>
  <data name="AddOrRemoveTrailingCommaBeforeNewLineInMultilineListsAccordingToTheSelectedCodeStyle" xml:space="preserve">
    <value>根据代码样式设置，在多行列表中的新行之前添加或移除尾随逗号</value>
  </data>
  <data name="UseSymbolAliasMessage" xml:space="preserve">
    <value>使用{0}别名 '{1}'</value>
  </data>
  <data name="ApartialMethodCannotHavevirtualoverridenewsealedexternModifiersUnlessLanguageVersionOrGreaterIsUsedMessage" xml:space="preserve">
    <value>除非使用语言版本 '9.0' 或更高版本，否则 'partial' 方法不能有 'virtual'、'override'、'new'、'sealed'、'extern' 修饰符</value>
  </data>
  <data name="ComparisonToIntegralConstantIsUseless" xml:space="preserve">
    <value>与整型常量进行比较没有意义</value>
  </data>
  <data name="OverflowInConstantValueComputationMessage" xml:space="preserve">
    <value>常量值计算中溢出</value>
  </data>
  <data name="InlineArrayIndexOutOfRangeMessage" xml:space="preserve">
    <value>索引超出内联数组的界限</value>
  </data>
  <data name="UseTypeAnnotationSyntaxMessage" xml:space="preserve">
    <value>使用类型注解语法</value>
  </data>
  <data name="CannotResolveTypeParameterMessage" xml:space="preserve">
    <value>不能解析类型形参 '{0}'</value>
  </data>
  <data name="ConvertToLambdaExpressionSettingApplyStyleHeuristicsDescription" xml:space="preserve">
    <value>使用此选项，只有在更改不会影响可读性的情况下才会建议转换。例如，当 lambda 表达式包含嵌套闭包或赋值时，它将禁止建议。</value>
  </data>
  <data name="InvalidModifierOnExtensionDeclarationErrorMessage" xml:space="preserve">
    <value>修饰符 '{0}' 对扩展无效</value>
  </data>
  <data name="EnforceBracesInusingStatement" xml:space="preserve">
    <value>在 'using' 语句中强制使用大括号</value>
  </data>
  <data name="WinRTParametersOfArrayTypeCannotBeBothAnnotatedWithReadOnlyArrayAttributeAndWriteOnlyArrayAttributeAtributesMessage" xml:space="preserve">
    <value>不能同时使用 'ReadOnlyArrayAttribute' 和 'WriteOnlyArrayAttribute' 特性注解数组类型的 WinRT 形参</value>
  </data>
  <data name="RedundantRangeBoundMessage" xml:space="preserve">
    <value>冗余的范围界限</value>
  </data>
  <data name="UseDiscardAssignmentTitle" xml:space="preserve">
    <value>使用弃元赋值</value>
  </data>
  <data name="AccessToThroughbaseKeywordFromAnonymousMethodLambdaExpressionQueryExpressionOrIteratorResultsInUnverifiableCodeMessage" xml:space="preserve">
    <value>通过匿名方法、lambda 表达式、查询表达式或迭代器中的 'base' 关键字访问 '{0}' 会产生无法验证的代码</value>
  </data>
  <data name="ParamsMemberCannotBeLessVisibleThanDeclaringMemberMessage" xml:space="preserve">
    <value>{0} 的可见性不能低于具有 params 集合的成员: {1}</value>
  </data>
  <data name="ApplyingNullnessAnnotationToVoidTypeIsMeaninglessMessage" xml:space="preserve">
    <value>对 '{0}' 类型应用为 null 性注解毫无意义</value>
  </data>
  <data name="AvoidUsingasyncLambdaWhenDelegateTypeReturnsvoid" xml:space="preserve">
    <value>当委托类型返回 'void' 时避免使用 'async' lambda</value>
  </data>
  <data name="MultipleNullnessAttributeUsageMessage" xml:space="preserve">
    <value>多个为 null 性特性用法</value>
  </data>
  <data name="CannotConvertExpressionType_ToYield_Text" xml:space="preserve">
    <value>不能将表达式类型 '{0}' 转换为 yield 类型 '{1}'</value>
  </data>
  <data name="ValueAssignedToAPropertyOfNonVariableQualifierExpressionCanBeLostIfStructTypeWillBeSubstitutedAsGenericTypeArgument" xml:space="preserve">
    <value>如果将结构类型替换为泛型类型实参，则赋给非变量限定符表达式属性的值可能丢失</value>
  </data>
  <data name="CompilerWarning_CS0402_Title" xml:space="preserve">
    <value>入口点不能是泛型的或属于泛型类型</value>
  </data>
  <data name="InconsistentAttributesGroupingStyleMessage" xml:space="preserve">
    <value>特性分组样式不一致</value>
  </data>
  <data name="XFoldedElements_Text" xml:space="preserve">
    <value>{0} 个{0:choice:one#元素|other#元素}</value>
  </data>
  <data name="ConvertifTo" xml:space="preserve">
    <value>将 'if' 转换为 '||'</value>
  </data>
  <data name="DuplicateKeyCollectionInitializationDescription" xml:space="preserve">
    <value>字典或集合只能包含一个具有给定键的元素。在集合初始化期间多次使用同一个键很可能是一个 bug，可能导致运行时异常。</value>
  </data>
  <data name="ApplyingNullnessAnnotationToValueTypeIsMeaninglessMessage" xml:space="preserve">
    <value>对值类型应用为 null 性注解毫无意义</value>
  </data>
  <data name="PartiallyOpenedTypeIsNotPermittedInNameofExpressionMessage" xml:space="preserve">
    <value>'nameof' 表达式中不允许使用部分打开的类型</value>
  </data>
  <data name="DoNotStoreSpinLockInReadonlyField" xml:space="preserve">
    <value>请勿将 SpinLock 存储在只读字段中</value>
  </data>
  <data name="ValueType_Text" xml:space="preserve">
    <value>ValueType</value>
  </data>
  <data name="InconsistentArgumentStyleMissingNameIdentifierMessage" xml:space="preserve">
    <value>实参样式不一致: 缺少名称标识符</value>
  </data>
  <data name="ExtensionReceiverParameterCannotBeDynamicMessage" xml:space="preserve">
    <value>扩展的接收器形参不能为类型 'dynamic'</value>
  </data>
  <data name="CollectionExpressionMissingAddMethod_Text" xml:space="preserve">
    <value>集合表达式目标类型 '{0}' 必须具有可以使用单个实参调用的适用实例或扩展方法 'Add'</value>
  </data>
  <data name="CompilerWarning_CS9182_Title" xml:space="preserve">
    <value>内联数组 'Slice' 方法不会用于元素访问表达式。</value>
  </data>
  <data name="TypeParameterHasTheSameNameAsTheContainingMessage" xml:space="preserve">
    <value>类型形参 '{0}' 与包含{1}同名</value>
  </data>
  <data name="RuntimeDoesNotSupportInlineArrayTypesMessage" xml:space="preserve">
    <value>目标运行时不支持内联数组类型</value>
  </data>
  <data name="InterfaceMember_IsNotImplemented_CannotImplicitlyImplementANonPublicMemberMessage" xml:space="preserve">
    <value>接口成员 '{0}' 未实现。'{1}' 不能隐式实现非 public 成员。</value>
  </data>
  <data name="TypesStaticClass_RiderPresentableName" xml:space="preserve">
    <value>类型//static 类</value>
  </data>
  <data name="AStaticAnonymousFunctionCannotContainAReferenceTothisOrbaseMessage" xml:space="preserve">
    <value>static 匿名函数不能包含对 'this' 或 'base' 的引用</value>
  </data>
  <data name="SuggestCollectionExpressionWithSingleSpreadTitle" xml:space="preserve">
    <value>建议使用 '[..anotherCollection]'</value>
  </data>
  <data name="OnlyClassTypesCanContainDestructorsMessage" xml:space="preserve">
    <value>只有类类型才能包含析构函数</value>
  </data>
  <data name="ConvertToLambdaExpression" xml:space="preserve">
    <value>转换为 lambda 表达式</value>
  </data>
  <data name="BaseMemberHasparamsParameterButOverriderHasnt" xml:space="preserve">
    <value>基成员具有 'params' 形参，但强制替代项没有</value>
  </data>
  <data name="CanSimplifySetAddingWithSingleCallMessage" xml:space="preserve">
    <value>'Add' 前面的 'Contains' 冗余</value>
  </data>
  <data name="ShowMatchingBraceHeaderWithInlayHint_TurnOffAction_Text" xml:space="preserve">
    <value>当文本光标位于右大括号时，不显示匹配的块标头作为嵌入提示</value>
  </data>
  <data name="QueryInvasionDescription" xml:space="preserve">
    <value>CQRS 上下文交集。查询从“命令”上下文调用。</value>
  </data>
  <data name="AccessToAStaticMemberOfATypeViaADerivedType" xml:space="preserve">
    <value>通过派生类型访问某一类型的 static 成员</value>
  </data>
  <data name="CompilerWarning_CS0626_Title" xml:space="preserve">
    <value>方法、运算符或访问器标记为外部对象并且上面没有任何特性</value>
  </data>
  <data name="ConvertNegatedIsExpressionToIsExpressionWithNegatedPattern" xml:space="preserve">
    <value>将求反的 'is' 表达式转换为具有求反模式的 'is' 表达式</value>
  </data>
  <data name="CannotBeOverrideMessage" xml:space="preserve">
    <value>{0}不能为 override</value>
  </data>
  <data name="BitwiseOrOperatorUsedOnASignExtendedOperandConsiderCastingToASmallerUnsignedTypeFirstMessage" xml:space="preserve">
    <value>在经符号扩展的操作数上使用了按位“或”运算符；请考虑首先强制转换为较小的无符号类型</value>
  </data>
  <data name="RecordDoesNotOverrideExpectedFromMessage" xml:space="preserve">
    <value>记录{1} '{0}' 不重写 '{2}' 中的预期{1}</value>
  </data>
  <data name="CompilerWarning_CS8947_Title" xml:space="preserve">
    <value>处理程序参数之后，要进行内插字符串处理程序转换的参数</value>
  </data>
  <data name="VariantTypeParametersCouldBeDeclaredInInterfacesOrDelegatesOnlyMessage" xml:space="preserve">
    <value>只能在接口或委托中声明变体类型形参</value>
  </data>
  <data name="awaitCannotBeUsedAsAnIdentifierWithinAnAsyncMethodOrLambdaExpressionMessage" xml:space="preserve">
    <value>'“await”不能用作异步方法或 lambda 表达式中的标识符</value>
  </data>
  <data name="PossibleSystemNullReferenceException" xml:space="preserve">
    <value>可能出现 'System.NullReferenceException'</value>
  </data>
  <data name="partialMemberDeclarationsMustBeEitherBothOrNeitherunsafeMessage" xml:space="preserve">
    <value>'partial' 成员声明必须两个都为 'unsafe' 或都不为 'unsafe'</value>
  </data>
  <data name="SpinLockShouldNotBeStoredInReadonlyFieldMessage" xml:space="preserve">
    <value>SpinLock 不应存储在只读字段中</value>
  </data>
  <data name="TheSuppressionOperatorIsNotAllowedInThisContextMessage" xml:space="preserve">
    <value>此上下文中不允许使用抑制运算符</value>
  </data>
  <data name="ImplicitlyTypedLocalVariablesCannotHaveMultipleDeclaratorsMessage" xml:space="preserve">
    <value>隐式类型化局部变量不能有多个声明符</value>
  </data>
  <data name="CannotSpecifyBothAConstraintClassAndTheclassstructOrunmanagedConstraintMessage" xml:space="preserve">
    <value>不能同时指定约束类和 'class'、'struct' 或 'unmanaged' 约束</value>
  </data>
  <data name="CSharp14OverloadResolutionWithSpanBreakingChangeInExpressionTreeMessage" xml:space="preserve">
    <value>由于带跨度的重载解析发生了重大变化，C# 14 中对此调用的解析也发生了变化。这可能会导致在使用解释进行编译时出现运行时异常。</value>
  </data>
  <data name="UsageOfEnumerableCountMethodCanBeReplacedWithDirectCollectionCountPropertyAccess" xml:space="preserve">
    <value>'Enumerable.Count()' 方法的用法可被替换为直接集合计数属性访问</value>
  </data>
  <data name="MathSignMethodAlwaysGivesTheSameResultMessage" xml:space="preserve">
    <value>Math.Sign() 方法始终给出相同的结果({0})</value>
  </data>
  <data name="CheckForReferenceEqualityInstead_Text" xml:space="preserve">
    <value>改为检查引用相等性</value>
  </data>
  <data name="TheDllImportAttributeCannotBeAppliedToAMethodThatIsGenericOrContainedInAGenericMethodOrTypeMessage" xml:space="preserve">
    <value>DllImport 特性不能应用于属于泛型类型的方法，或者包含在泛型方法/类型中</value>
  </data>
  <data name="EnforceBracesInforStatement" xml:space="preserve">
    <value>在 'for' 语句中强制使用大括号</value>
  </data>
  <data name="IsAlreadyImplementedMessage" xml:space="preserve">
    <value>'{0}' 已实现</value>
  </data>
  <data name="EmptyTypeParameterListMessage" xml:space="preserve">
    <value>空类型形参列表</value>
  </data>
  <data name="AnExplicitInterfaceImplementationOfAnEventMustExplicitlyDeclareaddremoveAccessorsMessage" xml:space="preserve">
    <value>事件的显式接口实现必须显式声明 'add'/'remove' 访问器</value>
  </data>
  <data name="ExpectedAMethodWithSignatureMessage" xml:space="preserve">
    <value>应为具有 '{0}{1} {2}{3}' 签名的方法</value>
  </data>
  <data name="ReplaceNullnessAttributesSuchAsCanBeNullOrItemCanBeNullWithNullableReferenceTypesAnnotationSyntax" xml:space="preserve">
    <value>将 [CanBeNull] 或 [ItemCanBeNull] 等为 null 性特性替换为可以为 null 的引用类型的注解语法</value>
  </data>
  <data name="ConditionIsNeverNullAccordingToNullableReferenceTypesAnnotations" xml:space="preserve">
    <value>根据可以为 null 的引用类型的注解，'??' 条件永远不为 null</value>
  </data>
  <data name="EnforceBracesInwhileStatement" xml:space="preserve">
    <value>在 'while' 语句中强制使用大括号</value>
  </data>
  <data name="CannotSpecifyMainIfThereIsACompilationUnitWithTopLevelStatementsMessage" xml:space="preserve">
    <value>如果存在包含顶级语句的编译单元，则不能指定 /main</value>
  </data>
  <data name="WinRTTypeCannotContainExternallyVisibleConstantsConstantsCanOnlyAppearOnWinRTEnumerationsMessage" xml:space="preserve">
    <value>WinRT 类型不能包含外部可见约束。约束只能出现在 WinRT 枚举上。</value>
  </data>
  <data name="CannotCreateAnInstanceOfTheTypeParameterBecauseItDoesNotHaveTheNewConstraintMessage" xml:space="preserve">
    <value>不能创建类型形参 '{0}' 的实例，因为它没有 new() 约束</value>
  </data>
  <data name="PossibleLossOfFractionMessage" xml:space="preserve">
    <value>分数可能丢失</value>
  </data>
  <data name="CompilerWarning_CS1072_Title" xml:space="preserve">
    <value>应为标识符或数字参数</value>
  </data>
  <data name="ExplicitScopedRefAttributeMessage" xml:space="preserve">
    <value>请勿使用 'System.Runtime.CompilerServices.ScopedRefAttribute'。改用 'scoped' 关键字.</value>
  </data>
  <data name="PropertiesAndVariablesProperty_RiderPresentableName" xml:space="preserve">
    <value>属性和变量//属性</value>
  </data>
  <data name="voidMethodIsAnnotatedByMustUseReturnValueAttribute27" xml:space="preserve">
    <value>使用 [MustUseReturnValue] 特性注解 'void' 方法毫无意义</value>
  </data>
  <data name="VariableResultedFromACallToTheIndexer_Text" xml:space="preserve">
    <value>调用索引器 '{0}' 生成的变量</value>
  </data>
  <data name="TheGivenExpressionIsAlwaysOfTheProvidedTypeMessage" xml:space="preserve">
    <value>表达式始终为提供的类型</value>
  </data>
  <data name="ConvertIfStatementToSwitchExpressionMessage" xml:space="preserve">
    <value>将 '{0}' 语句转换为 '{1}' 表达式</value>
  </data>
  <data name="BothContextCallDescription" xml:space="preserve">
    <value>方法从两种 CQRS 上下文调用</value>
  </data>
  <data name="TypeCheckForNullableTypeIsEqualToUnderlyingTypeCheckMessage" xml:space="preserve">
    <value>可以为 null 的类型的类型检查等于基础类型检查</value>
  </data>
  <data name="SpecifyACultureInStringConversionExplicitly" xml:space="preserve">
    <value>显式指定字符串转换中的区域性</value>
  </data>
  <data name="PreferSingleDeconstructionDeclaration_Caption" xml:space="preserve">
    <value>首选单个析构声明</value>
  </data>
  <data name="RedundantStringInterpolationMessage" xml:space="preserve">
    <value>冗余的字符串内插</value>
  </data>
  <data name="ForceMergeSequentialOrChecksSettingDescription" xml:space="preserve">
    <value>禁用时，如果整个 '||' 序列可以转换为单个 'or' 模式，则顺序 '||' 检查仅合并为 'or' 模式。
启用时，顺序 '||' 检查将尽可能合并，即使结果最终可能表现为: `a is constA or constB || a == nonConst`</value>
  </data>
  <data name="CodeCleanupTask_CSFixBuiltinTypeReferences" xml:space="preserve">
    <value>修正内置类型引用</value>
  </data>
  <data name="APatternContainsARedundantTypeCheckThatMatchesOnAnyNonNullableValuesThatAreAlreadyHandledInThePattern" xml:space="preserve">
    <value>模式包含与模式中已处理的任何不可以为 null 的值匹配的冗余类型检查</value>
  </data>
  <data name="APartialMemberMayNotHaveMultipleDefiningDeclarationsMessage" xml:space="preserve">
    <value>分部{0}不能有多个定义声明</value>
  </data>
  <data name="SwapViaDeconstructionMessage" xml:space="preserve">
    <value>通过析构交换</value>
  </data>
  <data name="IterationVariableCanBeDeclaredWithAMoreSpecificType" xml:space="preserve">
    <value>可以使用更具体的类型声明迭代变量</value>
  </data>
  <data name="TheDefaultValueSpecifiedForParameterWillHaveNoEffectBecauseItAppliesToAMemberThatIsUsedInContextsThatDoNotAllowOptionalArgumentsMessage" xml:space="preserve">
    <value>为形参“{0}”指定的默认值将不起任何作用，因为它适用于在不允许指定可选实参的上下文中使用的成员</value>
  </data>
  <data name="UseBracesToSeparateUsingStatementBody_Text" xml:space="preserve">
    <value>使用大括号分隔 'using' 语句体</value>
  </data>
  <data name="TheLeftHandSideOfArefAssignmentMustBeArefLocalVariableOrinrefoutParameterMessage" xml:space="preserve">
    <value>'ref' 赋值的左侧必须为 'ref' 局部变量、'ref' 字段或 'in'/'ref'/'out' 形参</value>
  </data>
  <data name="UsePreferredStyleOfDefaultValueExpressionWhenTypeIsEvident" xml:space="preserve">
    <value>当类型明确时，使用首选的默认值表达式样式</value>
  </data>
  <data name="DynamicDispatchToParamsCollectionMessage" xml:space="preserve">
    <value>{0} '{1}' 仅适用于非数组 'params' 集合的扩展形式，动态调度时不支持该形式</value>
  </data>
  <data name="TheTypeParameterCannotBeUsedWithTheasOperatorBecauseItDoesNotHaveAClassTypeConstraintNorAclassConstraintMessage" xml:space="preserve">
    <value>由于类型参数“{0}”既没有类类型约束也没有“class”约束，因此不能与“as”运算符一起使用</value>
  </data>
  <data name="TypesClass_RiderPresentableName" xml:space="preserve">
    <value>类型//类</value>
  </data>
  <data name="AnExpressionTreeLambdaMayNotContainADictionaryInitializerMessage" xml:space="preserve">
    <value>表达式树 lambda 不能包含字典初始值设定项</value>
  </data>
  <data name="ActualShiftCountEqualsZero" xml:space="preserve">
    <value>实际位移计数等于零</value>
  </data>
  <data name="NullnessAnnotationConflictWithJetBrainsAnnotationsDescription" xml:space="preserve">
    <value>成员的为 null 性与其层次结构中的特性注解冲突。使用基成员时，可能会传递或返回意外的值，例如 null 值可能会传递给不可以为 null 的形参，因为基成员的形参允许使用它，或者可能不会检查返回值是否为 null，因为基成员指示它永远不应返回 null。</value>
  </data>
  <data name="EmptywithExpressionIsRedundantMessage" xml:space="preserve">
    <value>空 'with' 表达式冗余</value>
  </data>
  <data name="CompilerWarning_CS0465_Title" xml:space="preserve">
    <value>引入 "Finalize" 方法可能会妨碍析构函数调用</value>
  </data>
  <data name="MathAbsMethodInvocationCanBeRemoved" xml:space="preserve">
    <value>可以移除 Math.Abs() 方法调用</value>
  </data>
  <data name="AmbiguousReference_Text" xml:space="preserve">
    <value>引用</value>
  </data>
  <data name="CodeCleanupTask_ArrangeDefaultValue" xml:space="preserve">
    <value>应用默认值样式('default' 与 'default(T)')</value>
  </data>
  <data name="CannotProvideArgumentsWhenCreatingAnInstanceOfATypeParameterMessage" xml:space="preserve">
    <value>创建类型形参 '{0}' 的实例时不能提供实参</value>
  </data>
  <data name="PreferExplicitlyProvidedTupleComponentNameDescription" xml:space="preserve">
    <value>首选通过显式名称使用元组组件，而不是 ItemN 这样基于位置的隐式名称</value>
  </data>
  <data name="LambdaExpressionParameters_Text" xml:space="preserve">
    <value>lambda 表达式形参</value>
  </data>
  <data name="CSharpFormatterHighlightingProvider_InternalConfigurableSeverityItems_Line_indent_should_not_be_changed_relative_to_the_previous_line_elsewhere" xml:space="preserve">
    <value>其他位置有冗余的缩进/减少缩进</value>
  </data>
  <data name="ConstraintsForOverrideAndExplicitInterfaceImplementationMethodsAreInheritedFromTheBaseMethodSoTheyCannotBeSpecifiedDirectlyMessage" xml:space="preserve">
    <value>重写和显式接口实现方法的约束继承自基方法，因此不能直接指定</value>
  </data>
  <data name="BadAllowByRefLikeEnumeratorMessage" xml:space="preserve">
    <value>'foreach' 语句无法在类型 '{0}' 的枚举器上操作，因为它是允许 ref 结构的类型形参，并且在编译时不知道是否实现 'IDisposable'</value>
  </data>
  <data name="NamespaceNameExpectedMessage" xml:space="preserve">
    <value>应为命名空间名称{0}</value>
  </data>
  <data name="ImmediateDelegateInvocationIsRedundant" xml:space="preserve">
    <value>即时委托调用冗余</value>
  </data>
  <data name="NotResolvedParamsCollectionAddReferenceFromCallSiteMessage" xml:space="preserve">
    <value>从 '{1}' 中找不到 '{0}' 类型的 'Add' 方法来填充 'params' 集合</value>
  </data>
  <data name="PossiblyUnintendedStringInterpolationInsteadOfFormatStringTemplate" xml:space="preserve">
    <value>可能是非有意的字符串内插而非格式字符串模板</value>
  </data>
  <data name="YouCannotUseFixedSizeBuffersContainedInUnfixedExpressionsTryUsingThefixedStatementMessage" xml:space="preserve">
    <value>不能在非固定表达式中使用固定大小缓冲区。请尝试使用 'fixed' 语句。</value>
  </data>
  <data name="CompilerWarning_CS0109_Title" xml:space="preserve">
    <value>成员不会隐藏继承的成员；不需要关键字 new</value>
  </data>
  <data name="QualifierIsRedundantMessage" xml:space="preserve">
    <value>限定符冗余</value>
  </data>
  <data name="ifStatementCanBeReWrittenAsAssignment" xml:space="preserve">
    <value>'if' 语句可被重写为 '??=' 赋值</value>
  </data>
  <data name="SomeExpression_Text" xml:space="preserve">
    <value>'{0}' 表达式</value>
  </data>
  <data name="CannotDefineUndefinePreprocessorSymbolsAfterFirstTokenInFileMessage" xml:space="preserve">
    <value>不能在文件中第一个令牌后定义/取消定义预处理程序符号</value>
  </data>
  <data name="CannotDeconstructDynamicObjectMessage" xml:space="preserve">
    <value>不能析构动态对象</value>
  </data>
  <data name="MethodWillNotBeUsedAsAnEntryPointBecauseASynchronousEntryPointWasFoundMessage" xml:space="preserve">
    <value>方法“{0}”将不会用作入口点，因为找到了同步入口点“{1}”</value>
  </data>
  <data name="PossibleOverflowInUncheckedContextMessage" xml:space="preserve">
    <value>在 unchecked 上下文中可能溢出</value>
  </data>
  <data name="TypeAliasKindName" xml:space="preserve">
    <value>类型</value>
  </data>
  <data name="EntityFramework_NavigationPropertyInitializationHighlighting_Description_Text" xml:space="preserve">
    <value>报告不初始化可能导致错误的实体属性</value>
  </data>
  <data name="DeclareVariableInsideALoopConditionUsingPatternMatchingSyntaxToReduceItsScopeAndAvoidDoingACStyleAssignmentAsASideEffect" xml:space="preserve">
    <value>使用模式匹配语法在循环条件内声明变量，以减小其作用域并避免出现 C 样式赋值的副作用</value>
  </data>
  <data name="NonNullableIsUninitializedConsiderDeclaringTheAsNullableOrUseAttributesMessage" xml:space="preserve">
    <value>不可以为 null 的{0} '{1}' 未被初始化。请考虑添加 '{2}' 修饰符或将{0}声明为可以为 null{3}。</value>
  </data>
  <data name="PossibleSystemInvalidOperationException" xml:space="preserve">
    <value>可能出现 'System.InvalidOperationException'</value>
  </data>
  <data name="ObjectReferenceEqualsIsAlwaysFalseBecauseItIsCalledWithValueTypeMessage" xml:space="preserve">
    <value>'Object.ReferenceEquals' 始终为 false，因为它使用值类型进行调用</value>
  </data>
  <data name="ReplaceExplicitFieldDeclarationWithPrimaryConstructorParameter" xml:space="preserve">
    <value>将显式字段声明替换为相应的主构造函数形参</value>
  </data>
  <data name="LocalFunctionReturnValueIsNeverUsed3" xml:space="preserve">
    <value>局部函数返回值从未被使用</value>
  </data>
  <data name="BothPartialMemberDeclarationsMustHaveTheSameReturnTypeMessage" xml:space="preserve">
    <value>两个分部{0}声明必须具有相同的返回值类型</value>
  </data>
  <data name="Elsewhere" xml:space="preserve">
    <value>其他地方</value>
  </data>
  <data name="TypeParameterHasTheConstraintSoCannotBeUsedAsAConstraintForMessage" xml:space="preserve">
    <value>类型形参 '{0}' 具有 '{1}' 约束，因此 '{0}' 不能用作 '{2}' 的约束</value>
  </data>
  <data name="TypeUsedInAImplementsDisposeAsyncMethodButItsReturnTypeIsNotAwaitableTypeWithvoidResultMessage" xml:space="preserve">
    <value>{1}中使用的类型 '{0}' 实现 'DisposeAsync' 方法，但其返回值类型不是具有 'void' 结果的可等待类型</value>
  </data>
  <data name="AValueOfTypeCannotBeUsedAsADefaultParameterBecauseThereAreNoStandardConversionsToTypeMessage" xml:space="preserve">
    <value>不能将“{0}”类型的值用作默认参数，因为没有到类型“{1}”的标准转换</value>
  </data>
  <data name="TurnOffMissingConstructHints_Text" xml:space="preserve">
    <value>关闭缺少构造提示</value>
  </data>
  <data name="MismatchOfOptionalParameterValueInOverriddenMethod5" xml:space="preserve">
    <value>被重写的方法中的可选形参值不匹配</value>
  </data>
  <data name="ValueParameterSameNameAsExtensionReceiverParameterErrorMessage" xml:space="preserve">
    <value>'value': 自动生成的形参名称与扩展形参名称冲突</value>
  </data>
  <data name="ParameterHidesMemberMessage" xml:space="preserve">
    <value>形参 '{0}' 会隐藏{1} '{2}'</value>
  </data>
  <data name="CompilerWarning_CS0164_Title" xml:space="preserve">
    <value>这个标签尚未被引用</value>
  </data>
  <data name="EmptyDestructor" xml:space="preserve">
    <value>空析构函数</value>
  </data>
  <data name="WinRTTypeCannotBeNestedMessage" xml:space="preserve">
    <value>WinRT 类型不能嵌套</value>
  </data>
  <data name="TheKeywordnewIsRedundantBecauseHidesNothingMessage" xml:space="preserve">
    <value>关键字 '{0}' 冗余，因为{1} '{2}' 不隐藏任何内容</value>
  </data>
  <data name="TheIndexerNameAttributeMustBeUsedWithTheSameNameOnEveryIndexerWithinATypeMessage" xml:space="preserve">
    <value>在类型中的每个索引器上的 'IndexerName' 特性都必须使用相同的名称</value>
  </data>
  <data name="WinRTStructMayOnlyContainPublicFieldsMessage" xml:space="preserve">
    <value>WinRT 结构只能包含 public 字段</value>
  </data>
  <data name="StaticDelegateInstanceIsRequiredMethodGroupPassedAsADelegateAlwaysAllocatesNewDelegateInstanceReplaceItWithALambdaExpressionOrCachedDelegateInstanceToAvoidAllocationMessage" xml:space="preserve">
    <value>需要 static 委托实例。作为委托传递的方法组始终分配新的委托实例。请将其替换为 lambda 表达式或缓存的委托实例以避免分配。</value>
  </data>
  <data name="CannotConvertNullToNonNullableCollectionExpressionIterationType_Text" xml:space="preserve">
    <value>不能将 null 转换为迭代器类型 '{0}'，因为后者是不可为 null 的值类型</value>
  </data>
  <data name="CompilerWarning_CS9017_Title" xml:space="preserve">
    <value>使用可能未分配的字段。请考虑更新到语言版本以自动默认字段。</value>
  </data>
  <data name="TheGuidAttributeMustBeSpecifiedWithTheComImportAttributeMessage" xml:space="preserve">
    <value>[Guid] 特性必须用 [ComImport] 特性指定</value>
  </data>
  <data name="LambdaParameterCannotBeOptionalMessage" xml:space="preserve">
    <value>Lambda 形参不能是可选形参</value>
  </data>
  <data name="InlineArrayConversionOperatorNotUsedMessage" xml:space="preserve">
    <value>内联数组转换运算符不会用于从声明类型的表达式的转换</value>
  </data>
  <data name="DuplicateUnmanagedTypeConstraintMessage" xml:space="preserve">
    <value>重复的非托管类型约束</value>
  </data>
  <data name="InterceptorPositionBadTokenMessage" xml:space="preserve">
    <value>提供的行号和字符编号未引用可拦截的方法名称，而是引用了令牌 '{0}'</value>
  </data>
  <data name="CSharpFormatterHighlightingProvider_InternalConfigurableSeverityItems_Around_expression_braces" xml:space="preserve">
    <value>表达式大括号周围</value>
  </data>
  <data name="UseRawString_Description" xml:space="preserve">
    <value>使用原始字符串以消除转义序列并保持正常缩进</value>
  </data>
  <data name="CLanguageHints_Text" xml:space="preserve">
    <value>C# 语言提示</value>
  </data>
  <data name="ReplaceUsingStatementWithUsingDeclaration" xml:space="preserve">
    <value>将 'using' 语句替换为 'using' 声明</value>
  </data>
  <data name="ReplaceArrayIndexerArgumentWithIndexFromEndExpression" xml:space="preserve">
    <value>将数组索引器实参替换为从结尾索引表达式</value>
  </data>
  <data name="_TypeParameter_IsUsedIn_Position_Text" xml:space="preserve">
    <value>{0}类型形参 '{1}' 用于{2}位置</value>
  </data>
  <data name="SuggestToReplaceEmptyCollectionObject" xml:space="preserve">
    <value>为空集合对象构造建议</value>
  </data>
  <data name="TheFieldIsSometimesUsedInsideSynchronizedBlockAndSometimesUsedWithoutSynchronizationMessage" xml:space="preserve">
    <value>该字段有时在同步块内使用，有时在不同步的情况下使用</value>
  </data>
  <data name="CapturedFieldReferenceOfAMarshalByReferenceClassMayCauseARuntimeException7" xml:space="preserve">
    <value>引用封送类的捕获字段引用可能会导致运行时异常</value>
  </data>
  <data name="ConstantExpectedInParent_Message" xml:space="preserve">
    <value>由于被实现或重写方法的方法注解，需要 {0} 特性</value>
  </data>
  <data name="CallerInfoAttributePreferredOverAnother_Message" xml:space="preserve">
    <value>应用于形参 '{1}' 的 [{0}] 特性不起任何作用，因为它被 [{2}] 重写</value>
  </data>
  <data name="JoinNullCheckWithAssignmentMessage" xml:space="preserve">
    <value>将 null 检查与赋值联接在一起</value>
  </data>
  <data name="RedundantAttributeSuffixCanBeOmittedWhenReferencingAttributeType" xml:space="preserve">
    <value>引用特性类型时可以省略冗余的 'Attribute' 后缀</value>
  </data>
  <data name="PreferUsingNamedPositionalArgumentWhen_Text" xml:space="preserve">
    <value>传递 'string' 字面量值时，首选使用命名/位置实参</value>
  </data>
  <data name="CompilerWarning_CS8775_Title" xml:space="preserve">
    <value>在某些条件下退出时，成员必须具有非 null 值。</value>
  </data>
  <data name="ExplicitImplementationOfAUserDefinedOperatorMustBeDeclaredStaticMessage" xml:space="preserve">
    <value>用户定义运算符的显式实现必须被声明为 static</value>
  </data>
  <data name="ExplicitDelegateCreationExpressionIsRedundant" xml:space="preserve">
    <value>显式委托创建表达式冗余</value>
  </data>
  <data name="InterpolatedStringHandlerArgumentHasNoEffectWhenAppliedToLambdaParametersAndWillBeIgnoredAtTheCallSiteMessage" xml:space="preserve">
    <value>[InterpolatedStringHandlerArgument] 在应用于 lambda 形参时不起任何作用，将在调用点被忽略</value>
  </data>
  <data name="PartialMethodMustHaveAccessibilityModifiersBecauseItHasANonVoidReturnTypeMessage" xml:space="preserve">
    <value>分部方法“{0}”必须具有可访问性修饰符，因为它具有非 void 返回类型</value>
  </data>
  <data name="SafeCastExpressionAlwaysSucceedsConsiderDirectCastInsteadMessage" xml:space="preserve">
    <value>安全转换表达式始终成功，请考虑改为直接转换</value>
  </data>
  <data name="InvalidVariance_Text" xml:space="preserve">
    <value>无效的差异:</value>
  </data>
  <data name="TryCatchAndTryFinallyStatementsCanBeMergedMessage" xml:space="preserve">
    <value>可以合并 try-catch 和 try-finally 语句</value>
  </data>
  <data name="ExplicitInterfaceDeclarationCanOnlyBeDeclaredInAClassOrStructMessage" xml:space="preserve">
    <value>显式接口声明只能在类或结构中进行声明</value>
  </data>
  <data name="paramsModifierIsAlwaysIgnoredOnOverridesMessage" xml:space="preserve">
    <value>重写时始终忽略 'params' 修饰符</value>
  </data>
  <data name="StringLiteralCanBeInlined" xml:space="preserve">
    <value>字符串字面量可以内联</value>
  </data>
  <data name="PartOfforeachForEachForVBNETStatementsBodyCanBeConvertedIntoALINQExpression" xml:space="preserve">
    <value>'foreach' (对于 VB.NET 为 'For Each')语句体的一部分可以转换为 LINQ 表达式</value>
  </data>
  <data name="paramsModifierIsAlwaysIgnoredOnOverrides" xml:space="preserve">
    <value>重写时始终忽略 'params' 修饰符</value>
  </data>
  <data name="UseValueOfTypeProvidedByMessage" xml:space="preserve">
    <value>使用{1}提供的 '{0}' 类型的值</value>
  </data>
  <data name="LiteralValues_Caption" xml:space="preserve">
    <value>字面量值</value>
  </data>
  <data name="CompilerWarning_CS7090_Title" xml:space="preserve">
    <value>将忽略特性，以便支持源中出现的实例</value>
  </data>
  <data name="CannotAccessStaticInNonStaticContextMessage" xml:space="preserve">
    <value>不能在非 static 上下文中访问 static {0} '{1}'</value>
  </data>
  <data name="UseBracesToSeparateforStatementBody" xml:space="preserve">
    <value>使用大括号分隔 'for' 语句体</value>
  </data>
  <data name="CSharp14OverloadResolutionWithSpanBreakingChangeInXunitMessage" xml:space="preserve">
    <value>由于 C# 14 中带有跨度的重载解析发生了重大变化，可能会出现不明确的调用错误。更新 xUnit 可能会解决此问题。</value>
  </data>
  <data name="CompilerWarning_CS9019_Title" xml:space="preserve">
    <value>字段在显式分配之前被读取，导致前面的隐式分配为 'default'。</value>
  </data>
  <data name="NoConversionForCallerInfoAttributeParam_Message" xml:space="preserve">
    <value>无法应用 [{0}] 特性，因为不存在从类型 '{1}' 到类型 '{2}' 的标准转换</value>
  </data>
  <data name="OperatorCannotBeAppliedToOperandOfTypeMessage" xml:space="preserve">
    <value>运算符 '.' 不能应用于 '{0}' 类型的操作数</value>
  </data>
  <data name="WinRTStaticCannotBeProtectedMessage" xml:space="preserve">
    <value>WinRT static {0} 不能为 protected</value>
  </data>
  <data name="VirtualMemberCallInConstructorMessage" xml:space="preserve">
    <value>构造函数中存在 virtual 成员调用</value>
  </data>
  <data name="AnInterpolatedStringHandlerConstructionCannotUseDynamicManuallyConstructAnInstanceOfMessage" xml:space="preserve">
    <value>内插字符串处理程序构造不能使用动态。请手动构造 '{0}' 的实例。</value>
  </data>
  <data name="EqualityComparisonOfFloatingPointNumbersMessage" xml:space="preserve">
    <value>浮点数的相等比较。{0}</value>
  </data>
  <data name="RedundantCqrsAttribute_Title" xml:space="preserve">
    <value>CQRS 特性冗余，可以将其移除</value>
  </data>
  <data name="NestedStringInterpolationCanBeInlined" xml:space="preserve">
    <value>嵌套字符串内插可以内联</value>
  </data>
  <data name="ConvertSingleExtensionMethodTitle" xml:space="preserve">
    <value>转换单个扩展方法</value>
  </data>
  <data name="ExtensionMethodCanOnlyBeDeclaredInNonGenericNonNestedStaticClassMessage" xml:space="preserve">
    <value>扩展方法只能在非泛型、非嵌套 static 类中声明</value>
  </data>
  <data name="CannotAccessStaticSymbolInTextArgument15" xml:space="preserve">
    <value>不能访问文本实参中的 static 符号</value>
  </data>
  <data name="AccessorMustDeclareABodyBecauseIsNotMarkedAsabstractOrexternMessage" xml:space="preserve">
    <value>访问器必须声明主体，因为{0}未被标记为 'abstract' 或 'extern'</value>
  </data>
  <data name="BaseInterfaceIsRedundantBecauseInheritsMessage" xml:space="preserve">
    <value>基接口 '{0}' 冗余，因为{1}继承 '{2}'</value>
  </data>
  <data name="CompilerWarning_CS9087_Title" xml:space="preserve">
    <value>这会按引用返回一个参数，但它不是 ref 参数</value>
  </data>
  <data name="CircularDependencyInvolvingAndMessage" xml:space="preserve">
    <value>涉及 '{1}' 和 '{2}' 的循环{0}依赖项</value>
  </data>
  <data name="TupleElementNamesAreNotPermittedOnTheLeftOfADeconstructionMessage" xml:space="preserve">
    <value>析构左侧不允许使用元组元素名称</value>
  </data>
  <data name="FilterExpressionIsAConstantConsiderRemovingTheFilterMessage" xml:space="preserve">
    <value>筛选器表达式是一个常量，请考虑移除该筛选器</value>
  </data>
  <data name="NonReadonlyFieldOrAutoPropertyReferencedInGetHashCode" xml:space="preserve">
    <value>'GetHashCode()' 中引用了非只读字段或自动属性</value>
  </data>
  <data name="CompilerWarning_CS8500_Title" xml:space="preserve">
    <value>这会获取托管类型的地址、获取其大小或声明指向它的指针</value>
  </data>
  <data name="InvalidInitializerMemberDeclaratorMissingNameMessage" xml:space="preserve">
    <value>初始值设定项成员声明符无效: 缺少名称</value>
  </data>
</root>
