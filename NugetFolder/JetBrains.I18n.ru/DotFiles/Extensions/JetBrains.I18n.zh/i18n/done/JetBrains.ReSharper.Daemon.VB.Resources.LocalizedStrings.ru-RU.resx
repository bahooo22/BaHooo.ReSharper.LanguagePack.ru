<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="InconsistentAccessibilityTupleComponentTypeIsLessAccessibleThanMessage" xml:space="preserve">
    <value>可访问性不一致: 元组组件类型 '{0}' 的可访问性低于{1} '{2}'</value>
  </data>
  <data name="MethodWithTheFollowingSignatureIsExpectedMessage" xml:space="preserve">
    <value>应为具有以下签名的方法: '{0} {1}{2}'</value>
  </data>
  <data name="LabelIsAlreadyDefinedInTheCurrentMethodOrMultilineLambdaExpressionMessage" xml:space="preserve">
    <value>标签 '{0}' 已在当前方法或多行 lambda 表达式中定义</value>
  </data>
  <data name="AttributeSystemRuntimeInteropServicesPreserveSigAttributeIsNotSupportedInWinRTMessage" xml:space="preserve">
    <value>WinRT 中不支持特性 'System.Runtime.InteropServices.PreserveSigAttribute'</value>
  </data>
  <data name="WinRTStructureShouldContainAtLeastOnePublicFieldMessage" xml:space="preserve">
    <value>WinRT 结构应至少包含一个 public 字段</value>
  </data>
  <data name="ExplicitArgumentPassedToParameterWithCallerInfoAttributeMessage" xml:space="preserve">
    <value>显式实参被传递给具有调用方信息特性的形参</value>
  </data>
  <data name="IncorrectArgumentTypesCandidatesAreMessage" xml:space="preserve">
    <value>实参类型不正确。候选项为: {0}</value>
  </data>
  <data name="ConstantMustHaveAValueMessage" xml:space="preserve">
    <value>常量必须有值</value>
  </data>
  <data name="SimplifyIIfMessage" xml:space="preserve">
    <value>简化 'IIf'</value>
  </data>
  <data name="CannotBecauseTheyDifferByParamArrayParameterMessage" xml:space="preserve">
    <value>'{0}' 不能{1} '{2}'，因为它们的 'ParamArray' 形参不同</value>
  </data>
  <data name="ImportClauseIsNotUsedInTheFileAndCouldBeSafelyRemoved" xml:space="preserve">
    <value>文件中未使用 import 子句，可以安全地移除</value>
  </data>
  <data name="AsyncModifierCannotBeUsedInPartialMethodDeclarationMessage" xml:space="preserve">
    <value>'async' 修饰符不能在部分方法声明中使用</value>
  </data>
  <data name="TheParameterHasCallerArgumentExpressionAttributeAppliedSoArgumentCouldBeOmittedMessage" xml:space="preserve">
    <value>形参 '{0}' 应用了 'CallerArgumentExpression' 特性，因此可以省略实参</value>
  </data>
  <data name="CallToBaseMemberWithImplicitDefaultParametersMessage" xml:space="preserve">
    <value>使用隐式默认形参调用基成员</value>
  </data>
  <data name="WinRTEnumerationTypeShouldBeBackedByValuesOfTypeIntegerOrUIntegerMessage" xml:space="preserve">
    <value>WinRT 枚举类型应当受 'Integer' 或 'UInteger' 类型的值支持</value>
  </data>
  <data name="HidesMessage" xml:space="preserve">
    <value>{0} '{1}' 会隐藏{2} '{3}'</value>
  </data>
  <data name="CannotApplyOperatorToOperandOfTypeMessage" xml:space="preserve">
    <value>不能将运算符 '{0}' 应用于 '{1}' 类型的操作数</value>
  </data>
  <data name="TypeIsNotAValidWinRTTypeMessage" xml:space="preserve">
    <value>类型 '{0}' 不是有效的 WinRT 类型</value>
  </data>
  <data name="OnlyletQueryStatementCanContainExplicitTypeNameInVariableDeclarationMessage" xml:space="preserve">
    <value>只有 'let' 查询语句才能在变量声明中包含显式类型名称</value>
  </data>
  <data name="WinRTConstructorCannotBeProtectedMessage" xml:space="preserve">
    <value>WinRT 构造函数不能为 protected</value>
  </data>
  <data name="QualifierIsRedundant" xml:space="preserve">
    <value>限定符冗余</value>
  </data>
  <data name="WinRTDoesNotSupportOperatorOverloadsMessage" xml:space="preserve">
    <value>WinRT 不支持运算符重载</value>
  </data>
  <data name="NoAccessibleCanBeCalledWithoutANarrowingConversionCandidatesAreMessage" xml:space="preserve">
    <value>没有收缩转换，不能调用可访问的 '{0}'。候选项为: {1}</value>
  </data>
  <data name="VisualBasicLanguageFeatureMessage4" xml:space="preserve">
    <value>Visual Basic 15.5 语言功能</value>
  </data>
  <data name="VisualBasicLanguageFeatureMessage5" xml:space="preserve">
    <value>Visual Basic 16.0 语言功能</value>
  </data>
  <data name="VisualBasicLanguageFeatureMessage2" xml:space="preserve">
    <value>Visual Basic 15.0 语言功能</value>
  </data>
  <data name="VisualBasicLanguageFeatureMessage3" xml:space="preserve">
    <value>Visual Basic 15.3 语言功能</value>
  </data>
  <data name="VisualBasicLanguageFeatureMessage1" xml:space="preserve">
    <value>Visual Basic 14.0 语言功能</value>
  </data>
  <data name="InconsistentAccessibilityTypeArgumentIsLessAccessibleThanMessage" xml:space="preserve">
    <value>可访问性不一致: 类型实参 '{0}' 的可访问性低于{1} '{2}'</value>
  </data>
  <data name="AutoPropertiesCannotBeDeclaredIteratorMessage" xml:space="preserve">
    <value>自动属性不能被声明为 'iterator'</value>
  </data>
  <data name="ProcessingRedundancies_Text" xml:space="preserve">
    <value>处理冗余</value>
  </data>
  <data name="WinRTSharedCannotBeProtectedMessage" xml:space="preserve">
    <value>WinRT 共享 {0} 不能为 protected</value>
  </data>
  <data name="ShouldBeParameterlessInOrderToInitializeItThroughAnObjectInitializerMessage" xml:space="preserve">
    <value>'{0}' 应为无形参，以便通过对象初始值设定项对其进行初始化</value>
  </data>
  <data name="MustHavePublicParameterlessConstructorMessage" xml:space="preserve">
    <value>类型 '{0}' 必须具有 public 无形参构造函数，才能在泛型{2} '{3}' 中将其用作形参 '{1}'</value>
  </data>
  <data name="CannotUseAsATypeArgumentMessage" xml:space="preserve">
    <value>不能将 '{0}' 用作类型实参</value>
  </data>
  <data name="OnlyIndexExpressionIsAllowedAsAStatementMessage" xml:space="preserve">
    <value>仅允许将索引表达式作为语句</value>
  </data>
  <data name="TypeSystemValueTupleIsNotResolvedMessage" xml:space="preserve">
    <value>类型 'System.ValueTuple' 未被解析</value>
  </data>
  <data name="CannotAccessHereDueToProtectionLevelMessage" xml:space="preserve">
    <value>由于保护级别的原因，不能在此处访问{0} '{1}'</value>
  </data>
  <data name="IsExpressionOperandMustBeReferenceOrNullableTypeMessage" xml:space="preserve">
    <value>'Is' 表达式操作数必须为引用或可以为 null 的类型</value>
  </data>
  <data name="OnlyMemberAccessExpressionCanStartAnInvocationStatementMessage" xml:space="preserve">
    <value>只有成员访问表达式才能启动调用语句</value>
  </data>
  <data name="ModuleCannotBeUsedAsTypeArgumentMessage" xml:space="preserve">
    <value>'{0}': 模块不能用作类型实参</value>
  </data>
  <data name="ParameterWithparamsModifierMustHaveAnArrayTypeMessage" xml:space="preserve">
    <value>带有 'params' 修饰符的形参必须具有数组类型</value>
  </data>
  <data name="OperatorCannotHaveParamArrayParameterMessage" xml:space="preserve">
    <value>运算符不能有 'ParamArray' 形参</value>
  </data>
  <data name="MeQualifierIsRedundantAndCanBeSafelyRemovedWithoutChangingCodeSemantics" xml:space="preserve">
    <value>'Me.' 限定符冗余，可以安全地移除而不更改代码语义。</value>
  </data>
  <data name="NameIsNotValidAtThisPointMessage" xml:space="preserve">
    <value>{0}名称在此位置无效</value>
  </data>
  <data name="ParameterlessPropertyParenthesesAreRedundant" xml:space="preserve">
    <value>无形参属性圆括号冗余</value>
  </data>
  <data name="ShouldBeUsedAsSimpleNameMessage" xml:space="preserve">
    <value>{0} '{1}' 应当用作简单名称</value>
  </data>
  <data name="OverriddenGetHashCodeCallsBaseObjectGetHashCodeMessage" xml:space="preserve">
    <value>被重写的 GetHashCode 调用基 'Object.GetHashCode()'</value>
  </data>
  <data name="outParameterIsNotAssignedUponExit" xml:space="preserve">
    <value>'out' 形参未在退出时赋值</value>
  </data>
  <data name="SubCannotBeIteratorMessage" xml:space="preserve">
    <value>Sub 不能是 iterator</value>
  </data>
  <data name="IsReadOnlyMessage" xml:space="preserve">
    <value>{0} '{1}' 为 'ReadOnly'</value>
  </data>
  <data name="ImplementingFriendInterfaceIsNotAllowedInWinRTMessage" xml:space="preserve">
    <value>不允许在 WinRT 中实现友元接口</value>
  </data>
  <data name="InvokeAsExtensionMethodMessage" xml:space="preserve">
    <value>作为扩展方法调用</value>
  </data>
  <data name="ArrayBoundsCannotAppearInTypeSpecifiersMessage" xml:space="preserve">
    <value>类型说明符中不能出现数组界限</value>
  </data>
  <data name="WinRTTypeCannotContainExternallyVisibleConstantsMessage" xml:space="preserve">
    <value>WinRT 类型不能包含外部可见的常量</value>
  </data>
  <data name="CannotBecauseTheyDifferByOptionalParameterMessage" xml:space="preserve">
    <value>'{0}' 不能{1} '{2}'，因为它们的可选形参不同</value>
  </data>
  <data name="WinRTTypesCannotHaveMultipleConstructorsWithTheSameNumberOfArgumentsMessage" xml:space="preserve">
    <value>WinRT 类型不能具有多个拥有相同实参数量的构造函数</value>
  </data>
  <data name="WinRTTypeCannotBeGenericMessage" xml:space="preserve">
    <value>WinRT 类型不能为泛型</value>
  </data>
  <data name="CustomAsyncOperationsAreNotSupportedUseAsyncInfoFactoryInsteadMessage" xml:space="preserve">
    <value>不支持自定义异步操作，请改用 AsyncInfoFactory</value>
  </data>
  <data name="IncorrectNumberOfArgumentsInReferenceToMessage" xml:space="preserve">
    <value>'{0}' 引用中的实参数量不正确</value>
  </data>
  <data name="ConvertPropertyToAutoPropertyWithPrivateSetter" xml:space="preserve">
    <value>将属性转换为带 private setter 的自动属性</value>
  </data>
  <data name="TheValuePassedToTheMethodIsNeverUsedBecauseItIsOverwrittenInTheMethodBodyBeforeBeingReadMessage" xml:space="preserve">
    <value>传递给方法的值从未被使用，因为它在读取之前在方法体中被覆盖</value>
  </data>
  <data name="OnlyVariableOrPropertyCanBeTheTargetOfAnAssignemntMessage" xml:space="preserve">
    <value>只有变量或属性可以作为赋值的目标</value>
  </data>
  <data name="RedundantOperandInLogicalConditionalExpressionMessage" xml:space="preserve">
    <value>逻辑条件表达式中存在冗余的操作数</value>
  </data>
  <data name="ThreadStaticDoesntWorkWithInstanceFieldsMessage" xml:space="preserve">
    <value>&lt;ThreadStatic&gt; 对实例字段无效</value>
  </data>
  <data name="CannotAccessNonSharedInSharedContextMessage" xml:space="preserve">
    <value>不能在共享上下文中访问非共享{0} '{1}'</value>
  </data>
  <data name="RedundantPropertyParenthesesMessage" xml:space="preserve">
    <value>冗余的属性圆括号</value>
  </data>
  <data name="EventsCannotBeDeclaredWithADelegateTypeThatHasAReturnTypeMessage" xml:space="preserve">
    <value>不能使用具有返回值类型的委托类型声明事件</value>
  </data>
  <data name="CodeIsUnreachable" xml:space="preserve">
    <value>代码不可到达</value>
  </data>
  <data name="MethodCannotHandleEventBecauseTheyDoNotHaveACompatibleSignatureMessage" xml:space="preserve">
    <value>方法 '{0}' 不能处理事件 '{1}'，因为它们没有兼容的签名</value>
  </data>
  <data name="AnnotationIsAppliedImplicitlyMessage" xml:space="preserve">
    <value>注解被隐式应用</value>
  </data>
  <data name="TheReturnTypeOfAnIteratorMustBeIEnumerableOfTIEnumeratorOfTIEnumerableOrIEnumeratorMessage" xml:space="preserve">
    <value>iterator {0} 的返回值类型必须为 IEnumerable(Of T)、IEnumerator(Of T)、IEnumerable 或 IEnumerator</value>
  </data>
  <data name="NamespaceOrTypeSpecifiedInTheImportsDoesntContainAnyPublicMemberOrCannotBeFoundMessage" xml:space="preserve">
    <value>在 Imports '{0}' 中指定的命名空间或类型不含任何 public 成员，找不到</value>
  </data>
  <data name="TheAsyncMethodMustEitherBeSubOrFunctionThatReturnsTaskOrTaskOfTMessage" xml:space="preserve">
    <value>async 方法必须为返回 Task 或 Task(Of T) 的 Sub 或 Function</value>
  </data>
  <data name="UseImplicitByValModifier" xml:space="preserve">
    <value>使用隐式 'ByVal' 修饰符</value>
  </data>
  <data name="ReturnValueOfPureMethodIsNotUsedMessage" xml:space="preserve">
    <value>纯方法的返回值未使用</value>
  </data>
  <data name="RedundantAttributeParenthesesMessage" xml:space="preserve">
    <value>冗余的特性圆括号</value>
  </data>
  <data name="NewConstraintCannotHaveRequiredMembersMessage" xml:space="preserve">
    <value>'{0}' 不能在泛型 {2} '{3}' 中满足形参 '{1}' 上的 'New' 约束，因为 '{0}' 具有必需成员</value>
  </data>
  <data name="ConstantExpressionIsRequiredMessage" xml:space="preserve">
    <value>需要常量表达式</value>
  </data>
  <data name="TypeArgumentsForCannotBeInferredFromTheUsageTrySpecifyingTypeArgumentsExplicitlyMessage" xml:space="preserve">
    <value>不能从用法中推断 '{0}' 的类型实参。请尝试显式指定类型实参</value>
  </data>
  <data name="ConstantsMustBeOfAnIntrinsicOrEnumeratedTypeNotAClassStructureTypeParameterOrArrayTypeMessage" xml:space="preserve">
    <value>常量必须为内部或枚举类型，而不是类、结构、类型形参或数组类型</value>
  </data>
  <data name="NameAndNameCannotDifferInCaseOnlyMessage" xml:space="preserve">
    <value>{0}名称 '{1}' 和{2}名称 '{3}' 不能仅大小写不同</value>
  </data>
  <data name="InconsistentAccessibilityBaseIsLessAccessibleThanMessage" xml:space="preserve">
    <value>可访问性不一致: 基{0} '{1}' 的可访问性低于{2} '{3}'</value>
  </data>
  <data name="TypeNameExpectedMessage" xml:space="preserve">
    <value>应为类型名称</value>
  </data>
  <data name="QualifierMeIsRedundantMessage" xml:space="preserve">
    <value>限定符 'Me.' 冗余</value>
  </data>
  <data name="CannotApplyIndexingToTypeMessage" xml:space="preserve">
    <value>不能对 '{0}' 类型应用索引</value>
  </data>
  <data name="CodeIsUnreachableMessage" xml:space="preserve">
    <value>代码不可到达</value>
  </data>
  <data name="PropertyWithoutAReadOnlyOrWriteOnlySpecifierMustProvideBothAGetAndASetMessage" xml:space="preserve">
    <value>没有 'ReadOnly' 或 'WriteOnly' 说明符的属性必须同时提供 'Get' 和 'Set'</value>
  </data>
  <data name="UsingDirectCastOperatorToCastAValueTypeToTheSameTypeIsObsoleteMessage" xml:space="preserve">
    <value>使用 DirectCast 运算符将值类型转换为同一类型已过时</value>
  </data>
  <data name="ImpureMethodIsCalledForReadonlyFieldOfValueTypeMessage" xml:space="preserve">
    <value>对值类型的只读字段调用了不纯的方法</value>
  </data>
  <data name="WinRTClassCannotContainExternallyVisibleFieldsMessage" xml:space="preserve">
    <value>WinRT 类不能包含外部可见字段</value>
  </data>
  <data name="CannotBeIndexedBecauseItHasNoDefaultPropertyMessage" xml:space="preserve">
    <value>{0} '{1}' 不能索引，因为它没有默认属性</value>
  </data>
  <data name="TheTypeMustBeConvertibleToInOrderToUseItAsParameterInTheGenericMessage" xml:space="preserve">
    <value>类型 '{0}' 必须可以转换为 '{1}' 才能在泛型{3} '{4}' 中将其用作形参 '{2}'</value>
  </data>
  <data name="ParameterHidesMessage" xml:space="preserve">
    <value>形参 '{0}' 会隐藏{1} '{2}'</value>
  </data>
  <data name="TheParameterizedConstructorHasAParameterNamedvalueWhichIsTheSameAsTheDefaultReturnValueNameConsiderUsingAnotherNameForTheParameterMessage" xml:space="preserve">
    <value>形参化构造函数具有名为 'value' 的形参，它与默认返回值名称相同。请考虑为该形参使用其他名称</value>
  </data>
  <data name="UnusedImportClause" xml:space="preserve">
    <value>未使用的 import 子句</value>
  </data>
  <data name="ArrayInitializerLengthDoesNotMatchTheSpecifiedArraySizeMessage" xml:space="preserve">
    <value>数组初始值设定项长度与指定的数组大小不匹配</value>
  </data>
  <data name="HidesAVariableInAnEnclosingBlockAPreviouslyDefinedRangeVariableOrAnImplicitlyDeclaredVariableInAQueryExpressionMessage" xml:space="preserve">
    <value>{0} '{1}' 会隐藏封闭块中的变量、先前定义的范围变量或查询表达式中隐式声明的变量</value>
  </data>
  <data name="ConvertToAutoPropertyWithPrivateSetterMessage" xml:space="preserve">
    <value>转换为带 private setter 的自动属性</value>
  </data>
  <data name="TupleElementNameIsOnlyAllowedAtPositionMessage" xml:space="preserve">
    <value>仅在位置 {1} 允许元组元素名称 '{0}'。</value>
  </data>
  <data name="ThereIsNoMatchingInInterfaceCandidatesAreMessage" xml:space="preserve">
    <value>接口 '{3}' 中没有匹配的{0} '{1}{2}'。候选项为: {4}</value>
  </data>
  <data name="WinRTMethodCannotHaveOptionalParametersMessage" xml:space="preserve">
    <value>WinRT 方法不能有可选形参</value>
  </data>
  <data name="UseImplicitlyTypedVariableDeclarationEvident" xml:space="preserve">
    <value>使用隐式类型化变量声明(明显)</value>
  </data>
  <data name="EventNameExpectedMessage" xml:space="preserve">
    <value>应为事件名称</value>
  </data>
  <data name="CannotUseBeforeItIsDeclaredMessage" xml:space="preserve">
    <value>不能在声明{0} '{1}' 之前使用它</value>
  </data>
  <data name="LoopCanBeConvertedIntoLINQExpressionMessage" xml:space="preserve">
    <value>循环可以转换为 LINQ 表达式</value>
  </data>
  <data name="CannotBeUsedInThisContextBecauseTheAccessorIsInaccessibleMessage" xml:space="preserve">
    <value>{0} '{1}' 不能用于此上下文，因为 {2} 访问器无法访问</value>
  </data>
  <data name="PossibleMultipleEnumerationOfIEnumerableMessage" xml:space="preserve">
    <value>可能多次枚举 IEnumerable</value>
  </data>
  <data name="LongLiteralEndingWithlInsteadOfLMessage" xml:space="preserve">
    <value>长整型字面量以 'l' 而不是 'L' 结尾</value>
  </data>
  <data name="FieldInWinRTStructureCannotHaveInitializerMessage" xml:space="preserve">
    <value>WinRT 结构中的字段不能有初始值设定项</value>
  </data>
  <data name="AccessToModifiedClosureMessage" xml:space="preserve">
    <value>访问已修改的闭包</value>
  </data>
  <data name="RedundantMeQualifier" xml:space="preserve">
    <value>冗余的 'Me.' 限定符</value>
  </data>
  <data name="BranchingOutOfAFinallyIsNotValidMessage" xml:space="preserve">
    <value>从 'finally' 分支无效</value>
  </data>
  <data name="AmbiguousmatchMessage" xml:space="preserve">
    <value>不明确的 {0}:{1}{2}匹配</value>
  </data>
  <data name="ImplementationInheritanceIsNotAllowedInWinRTMessage" xml:space="preserve">
    <value>WinRT 中不允许实现继承</value>
  </data>
  <data name="ExplicitvalueParameterDeclarationIsRedundant" xml:space="preserve">
    <value>显式 'value' 形参声明冗余</value>
  </data>
  <data name="WinRTDoesNotSupportEventsWithParametersMessage" xml:space="preserve">
    <value>WinRT 不支持带有形参的事件</value>
  </data>
  <data name="NamespaceNameExpectedButNameFoundMessage" xml:space="preserve">
    <value>应为命名空间名称，但实际为{0}名称</value>
  </data>
  <data name="SimplifyConditionalOperator" xml:space="preserve">
    <value>简化条件运算符</value>
  </data>
  <data name="OverridesMultipleMembersWithTheSameNameAndSignatureMessage" xml:space="preserve">
    <value>{0} '{1}' 会重写多个具有相同名称和签名的成员: {2}{3}</value>
  </data>
  <data name="SyntaxErrorMessage" xml:space="preserve">
    <value>语法错误</value>
  </data>
  <data name="IncorrectNumberOfTypeParametersInReferenceToMessage" xml:space="preserve">
    <value>'{0}' 引用中的类型形参的数量不正确</value>
  </data>
  <data name="AsyncCannotHaveByRefParametersMessage" xml:space="preserve">
    <value>async {0} 不能有 ByRef 形参</value>
  </data>
  <data name="RedundantQualifier" xml:space="preserve">
    <value>冗余限定符</value>
  </data>
  <data name="BecauseThisCallIsNotAwaitedExecutionOfTheCurrentMethodContinuesBeforeTheCallIsCompletedConsiderApplyingTheAwaitOperatorToTheResultOfTheCallMessage" xml:space="preserve">
    <value>由于不等待此调用，当前方法会在调用完成之前继续执行。请考虑对调用结果应用 'await' 运算符。</value>
  </data>
  <data name="WinRTCannotBeOverridableMessage" xml:space="preserve">
    <value>WinRT {0} 不能为 'Overridable'</value>
  </data>
  <data name="IteratorCannotHaveByRefParametersMessage" xml:space="preserve">
    <value>iterator {0}不能有 ByRef 形参</value>
  </data>
  <data name="ExplicitInitializationIsNotPermittedForArraysDeclaredWithExplicitBoundsMessage" xml:space="preserve">
    <value>不允许对使用显式界限声明的数组进行显式初始化</value>
  </data>
  <data name="AsyncOrIteratorLambdaExpressionCannotBeConvertedToExpressionTreesMessage" xml:space="preserve">
    <value>不能将 async 或 iterator lambda 表达式转换为表达式树</value>
  </data>
  <data name="DoesNotHaveTypeParametersMessage" xml:space="preserve">
    <value>'{0}' 没有类型形参</value>
  </data>
  <data name="CannotInferAReturnTypeConsiderAddingAnAsClauseToSpecifyTheReturnTypeMessage" xml:space="preserve">
    <value>不能推断返回值类型。请考虑添加 'as' 子句以指定返回值类型</value>
  </data>
  <data name="KeywordThenIsRedundantInMultilineIfStatementMessage" xml:space="preserve">
    <value>关键字 'Then' 在多行 'If' 语句中冗余</value>
  </data>
  <data name="TheCallerArgumentExpressionAttributeAppliedToParameterWillHaveNoEffectBecauseItsSelfReferentialMessage" xml:space="preserve">
    <value>应用于形参 '{0}' 的 CallerArgumentExpressionAttribute 不起任何作用，因为它是自引用的</value>
  </data>
  <data name="CannotConvertExpressionOfTypeToTypeMessage" xml:space="preserve">
    <value>不能将 '{0}' 类型的表达式转换为 '{1}' 类型</value>
  </data>
  <data name="InheritsKeywordMustBeUsedWithAnInterfaceMessage" xml:space="preserve">
    <value>inherits 关键字必须与接口一起使用</value>
  </data>
  <data name="InconsistentAccessibilityParameterTypeIsLessAccessibleThanMessage" xml:space="preserve">
    <value>可访问性不一致: 形参类型 '{0}' 的可访问性低于{1} '{2}'</value>
  </data>
  <data name="ValueAssignedIsNotUsedInAnyExecutionPathMessage" xml:space="preserve">
    <value>所赋的值未在任何执行路径中使用</value>
  </data>
  <data name="AwaitCanOnlyBeUsedInAMethodMarkedWithTheAsyncModifierMessage" xml:space="preserve">
    <value>只能在使用 'async' 修饰符标记的方法中使用 await</value>
  </data>
  <data name="FunctionNeverReturnsMessage" xml:space="preserve">
    <value>函数从未返回</value>
  </data>
  <data name="CannotImplicitlyConvertTypeToSystemIDisposableMessage" xml:space="preserve">
    <value>不能将 '{0}' 类型隐式转换为 'System.IDisposable'</value>
  </data>
  <data name="ExceptionRethrowPossiblyIntendedMessage" xml:space="preserve">
    <value>可能打算重新抛出异常</value>
  </data>
  <data name="QualifierMyBaseIsRedundantMessage" xml:space="preserve">
    <value>限定符 'MyBase.' 冗余</value>
  </data>
  <data name="ArrayModifierCannotContainBothSpecifiedAndUnspecifiedBoundsMessage" xml:space="preserve">
    <value>数组修饰符不能同时包含指定的和未指定的界限</value>
  </data>
  <data name="DynamicExtensionMethodsAreNotSupportedMessage" xml:space="preserve">
    <value>不支持动态扩展方法</value>
  </data>
  <data name="UnreachableCode" xml:space="preserve">
    <value>不可到达的代码</value>
  </data>
  <data name="PossibleIncorrectImplementationOfDoubleCheckLockingPossibleMultipleWriteAccessToCheckedFieldMessage" xml:space="preserve">
    <value>可能错误地实现了双重检查锁定。可能对 checked 字段进行了多次写入访问</value>
  </data>
  <data name="TheArgumentTypeDoesNotMatchByRefParameterTypeMessage" xml:space="preserve">
    <value>实参类型与 'ByRef' 形参类型不匹配</value>
  </data>
  <data name="TypeOfCannotBeInferredFromAnExpressionContainingMessage" xml:space="preserve">
    <value>不能从包含 '{1}' 的表达式中推断{0} '{1}' 的类型</value>
  </data>
  <data name="CannotCallMethodUseInsteadMessage" xml:space="preserve">
    <value>不能调用方法 '{0}()'。请改用{1} '{2}'</value>
  </data>
  <data name="AccessToDisposedClosureMessage" xml:space="preserve">
    <value>访问已处置的闭包</value>
  </data>
  <data name="OverloadsWithTheSameNumberOfParametersAreNotAllowedPleaseMarkOneOfThemWithDefaultOverloadAttributeMessage" xml:space="preserve">
    <value>不允许使用具有相同数量形参的重载。请将其中一个标记为 'DefaultOverloadAttribute'</value>
  </data>
  <data name="DuplicateBaseTypeSpecificationMessage" xml:space="preserve">
    <value>重复的基类型规范</value>
  </data>
  <data name="TheReturnTypeOfAnIteratorLambdaExpressionMustBeIEnumerableOfTIEnumeratorOfTIEnumerableOrIEnumeratorMessage" xml:space="preserve">
    <value>iterator lambda 表达式的返回值类型必须为 IEnumerable(Of T)、IEnumerator(Of T)、IEnumerable 或 IEnumerator</value>
  </data>
  <data name="WinRTOutParametersOfArrayTypeCannotBeAnnotatedWithReadOnlyArrayAttributeSinceTheContentsOfOutputArraysAreWritableMessage" xml:space="preserve">
    <value>不能使用 'ReadOnlyArrayAttribute' 注解数组类型的 WinRT out 形参，因为输出数组的内容是可写的</value>
  </data>
  <data name="UnableToChooseAMoreApplicableCandidateCandidatesAreMessage" xml:space="preserve">
    <value>不能选择更适用的候选项。候选项为: {0}</value>
  </data>
  <data name="ReturnStatementInASubOrASetCannotReturnAValueMessage" xml:space="preserve">
    <value>Sub 或 Set 中的 'Return' 语句不能返回值</value>
  </data>
  <data name="TypeCastIsRedundantMessage" xml:space="preserve">
    <value>类型转换冗余</value>
  </data>
  <data name="newCannotBeUsedWithValueTupleTypeUseATupleLiteralExpressionInsteadMessage" xml:space="preserve">
    <value>'new' 不能与值元组类型一起使用。请改用元组字面量表达式。</value>
  </data>
  <data name="EventNameExpectedButNameFoundMessage" xml:space="preserve">
    <value>应为事件名称，但实际为{0}名称</value>
  </data>
  <data name="ReadOnlyPropertyMustProvideGetterMessage" xml:space="preserve">
    <value>'ReadOnly' 属性必须提供 getter</value>
  </data>
  <data name="CannotUseOverloadResolutionPriorityOnOverrideMessage" xml:space="preserve">
    <value>无法在重写成员上使用 'OverloadResolutionPriorityAttribute'</value>
  </data>
  <data name="CannotBeDeclaredOverridesBecauseThereIsNoMatchingMemberToOverrideInTheBaseClassMessage" xml:space="preserve">
    <value>{0} '{1}' 不能被声明为 'Overrides'，因为基类中没有要重写的匹配成员</value>
  </data>
  <data name="InactivePreprocessorBranch" xml:space="preserve">
    <value>停用的预处理程序分支</value>
  </data>
  <data name="CannotAccessHereMessage" xml:space="preserve">
    <value>不能在此处访问{0}{1} '{2}'</value>
  </data>
  <data name="MultilineLambdaCannotBeConvertedToExpressionTreesMessage" xml:space="preserve">
    <value>不能将多行 lambda 转换为表达式树</value>
  </data>
  <data name="RedundantvalueParameterDeclarationMessage" xml:space="preserve">
    <value>冗余的 'value' 形参声明</value>
  </data>
  <data name="ConvertToAutoPropertyMessage" xml:space="preserve">
    <value>转换为自动属性</value>
  </data>
  <data name="SimplifyConditionalOperatorMessage" xml:space="preserve">
    <value>简化条件运算符</value>
  </data>
  <data name="WinRTMethodCannotBeGenericMessage" xml:space="preserve">
    <value>WinRT 方法不能为泛型</value>
  </data>
  <data name="LoopCanBeConvertedIntoLINQExpressionButAnotherGetEnumeratorMethodWillBeUsedMessage" xml:space="preserve">
    <value>循环可以转换为 LINQ 表达式，但将使用另一个 'GetEnumerator' 方法</value>
  </data>
  <data name="LowerArrayBoundsCanOnlyBeSetToMessage" xml:space="preserve">
    <value>数组下限只能设置为 '0'</value>
  </data>
  <data name="WinRTDoNotSupportsoutParametersOnConstructorsMessage" xml:space="preserve">
    <value>WinRT 在构造函数上不支持 'out' 形参</value>
  </data>
  <data name="IncorrectNumberOfTypeParametersCandidatesAreMessage" xml:space="preserve">
    <value>类型形参的数量不正确。候选项为: {0}</value>
  </data>
  <data name="VisualBasic17_13LanguageFeatureMessage" xml:space="preserve">
    <value>Visual Basic 17.13 语言功能</value>
  </data>
  <data name="IteratorFunctionWithoutYieldStatements" xml:space="preserve">
    <value>不带 'yield' 语句的 iterator 函数</value>
  </data>
  <data name="AwaitCannotCurrentlyBeUsedInALINQQueryMessage" xml:space="preserve">
    <value>'await' 当前不能在 LINQ 查询中使用</value>
  </data>
  <data name="WriteOnlyPropertyMustNotHaveGetterMessage" xml:space="preserve">
    <value>'WriteOnly' 属性不得有 getter</value>
  </data>
  <data name="TheparamsParameterCannotBeDeclaredAsByRefMessage" xml:space="preserve">
    <value>'params' 形参不能被声明为 'ByRef'</value>
  </data>
  <data name="MethodHasAsInvalidReturnValueNameMessage" xml:space="preserve">
    <value>方法具有无效的返回值名称</value>
  </data>
  <data name="ApplyingNullnessAnnotationToTypeIsMeaninglessMessage" xml:space="preserve">
    <value>对{0}类型应用为 null 性注解毫无意义</value>
  </data>
  <data name="WinRTDoesNotSupportPropertiesWithParametersMessage" xml:space="preserve">
    <value>WinRT 不支持带有形参的属性</value>
  </data>
  <data name="HasNoSetterMessage" xml:space="preserve">
    <value>{0} '{1}' 没有 setter</value>
  </data>
  <data name="SharedFieldInGenericTypeMessage" xml:space="preserve">
    <value>泛型类型中存在共享字段</value>
  </data>
  <data name="WriteOnlyPropertyMustProvideSetterMessage" xml:space="preserve">
    <value>'WriteOnly' 属性必须提供 setter</value>
  </data>
  <data name="DoesntReturnAValueOnAllCodePathsMessage" xml:space="preserve">
    <value>{0} 不在所有代码路径上返回值</value>
  </data>
  <data name="KeywordThenIsRedundantInMultilineIfStatement" xml:space="preserve">
    <value>关键字 'Then' 在多行 'If' 语句中冗余</value>
  </data>
  <data name="AparamsParameterMustBeTheLastParameterInAFormalParameterListMessage" xml:space="preserve">
    <value>'params' 形参必须为形参列表中的最后一个形参</value>
  </data>
  <data name="TypeIsNotEnumerableMessage" xml:space="preserve">
    <value>类型 '{0}' 不可枚举</value>
  </data>
  <data name="RedundantArrayLowerBoundSpecification" xml:space="preserve">
    <value>冗余的数组下限规范</value>
  </data>
  <data name="TheTypeMustBeANonNullableValueTypeInOrderToUseItAsParameterMessage" xml:space="preserve">
    <value>类型 '{0}' 必须为不可以为 null 的值类型才能将其用作形参 '{1}'</value>
  </data>
  <data name="CannotResolveSymbolMessage" xml:space="preserve">
    <value>无法解析符号'{0}'</value>
  </data>
  <data name="PartOfLoopsBodyCanBeConvertedIntoLINQExpressionButAnotherGetEnumeratorMethodWillBeUsedMessage" xml:space="preserve">
    <value>循环体的一部分可以转换为 LINQ 表达式，但将使用另一个 'GetEnumerator' 方法</value>
  </data>
  <data name="WinRTTypeCannotContainBothSharedAndInstanceWithNameMessage" xml:space="preserve">
    <value>WinRT 类型不能同时包含 Shared 和名为 '{1}' 的实例{0}</value>
  </data>
  <data name="MyBaseQualifierIsRedundantAndCanBeSafelyRemovedWithoutChangingCodeSemantics" xml:space="preserve">
    <value>'MyBase.' 限定符冗余，可以安全地移除而不更改代码语义。</value>
  </data>
  <data name="ReferenceToRequiresTypeMessage" xml:space="preserve">
    <value>对 '{0}' 的引用需要 {1} 个类型{2}</value>
  </data>
  <data name="AutoPropertyCannotHaveParametersMessage" xml:space="preserve">
    <value>自动属性不能有形参</value>
  </data>
  <data name="WinRTTypeShouldBeNotInheritableMessage" xml:space="preserve">
    <value>WinRT 类型应为 'NotInheritable'</value>
  </data>
  <data name="UseImplicitlyTypedVariableDeclarationMessage" xml:space="preserve">
    <value>使用隐式类型化变量声明</value>
  </data>
  <data name="ConditionArgumentMustBeBooleanMessage" xml:space="preserve">
    <value>条件实参必须为 'Boolean'</value>
  </data>
  <data name="TypeArgumentsCannotBeInferredFromTheQueryCandidatesAreMessage" xml:space="preserve">
    <value>不能从查询中推断类型实参。候选项为: {0}</value>
  </data>
  <data name="TheTypeMustBeUnmanagedTypeMessage" xml:space="preserve">
    <value>类型 '{0}' 必须是不可为 null 值的类型，并且在任何嵌套级别具有所有非托管类型的字段，才能用作 '{1}' 形参的类型实参</value>
  </data>
  <data name="MethodHasReturnValueNameThatDiffersFromImplementedInterfaceMethodReturnValueNamePleaseMakeSureThatTheNamesAreIdenticalMessage" xml:space="preserve">
    <value>方法的返回值名称与实现的接口方法返回值名称 '{0}' 不同。请确保名称相同</value>
  </data>
  <data name="RemoveRedundantParentheses" xml:space="preserve">
    <value>移除冗余括号</value>
  </data>
  <data name="EventsOfSharedWithEventsVariablesCannotBeHandledByNonSharedMethodsMessage" xml:space="preserve">
    <value>非共享方法不能处理共享的 WithEvents 变量的事件</value>
  </data>
  <data name="TypeDeclarationHasTheSameNameAsInterfaceGeneratedForTypeMessage" xml:space="preserve">
    <value>类型声明的名称与为类型 '{1}' 生成的接口 '{0}' 相同</value>
  </data>
  <data name="InconsistentAccessibilityTypeIsLessAccessibleThanMessage" xml:space="preserve">
    <value>可访问性不一致: {0}类型 '{1}' 的可访问性低于{2} '{3}'</value>
  </data>
  <data name="MissingImplementationOfMembersFromBaseTypesMessage" xml:space="preserve">
    <value>缺少来自基类型的成员的实现: {0}{1}</value>
  </data>
  <data name="NullnessAnnotationConflictsWithAnnotationInSuperTypeMessage" xml:space="preserve">
    <value>Nullness 注解与超类型中的注解冲突</value>
  </data>
  <data name="WinRTTypesCanOnlyImplementOtherWinRTInterfacesMessage" xml:space="preserve">
    <value>WinRT 类型只能实现其他 WinRT 接口</value>
  </data>
  <data name="VariableMightNotBeInitializedBeforeAccessingANullReferenceExceptionCouldOccurAtRuntimeMessage" xml:space="preserve">
    <value>变量 '{0}' 可能在访问之前未初始化。运行时可能发生 null 引用异常。</value>
  </data>
  <data name="ImplementsMoreThanOneInterfaceMemberPleaseMakeSureThisMemberOnlyImplementsOneInterfaceMemberMessage" xml:space="preserve">
    <value>{0} '{1}' 实现多个接口成员。请确保此成员仅实现一个接口成员。</value>
  </data>
  <data name="SharedFieldInitializerRefersToSharedFieldBelowOrInOtherPartMessage" xml:space="preserve">
    <value>共享字段初始值设定项引用以下或其他部分中的共享字段</value>
  </data>
  <data name="IteratorNeverReturnsMessage" xml:space="preserve">
    <value>迭代器从未返回</value>
  </data>
  <data name="RedundantMyClassQualifier" xml:space="preserve">
    <value>冗余的 'MyClass.' 限定符</value>
  </data>
  <data name="YieldCannotBeUsedInATryCatchOrATryFinallyOrASyncLockMessage" xml:space="preserve">
    <value>'yield' 不能在 try catch 或 try finally 或 SyncLock 中使用</value>
  </data>
  <data name="UseImplicitlyTypedVariableDeclaration" xml:space="preserve">
    <value>使用隐式类型化变量声明</value>
  </data>
  <data name="InheritsKeywordMustBeUsedWithClassMessage" xml:space="preserve">
    <value>inherits 关键字必须与类一起使用</value>
  </data>
  <data name="CannotInferACommonTypeBecauseMoreThanOneTypeIsPossibleForAndMessage" xml:space="preserve">
    <value>不能推断通用类型，因为 '{0}' 和 '{1}' 可能有多个类型</value>
  </data>
  <data name="TupleElementNameIsDisallowedAtAnyPositionMessage" xml:space="preserve">
    <value>任何位置都不允许使用元组元素名称“{0}”</value>
  </data>
  <data name="ExpressionIsNotAnArrayOrAMethodAndCannotHaveAnArgumentListMessage" xml:space="preserve">
    <value>表达式不是数组或方法，不能有实参列表</value>
  </data>
  <data name="CannotInferACommonTypeForAndAndOptionStrictOnDoesNotAllowObjectToBeAssumedMessage" xml:space="preserve">
    <value>不能推断 '{0}' 和 '{1}' 的通用类型，并且 Option Strict On 不允许假定 'Object'</value>
  </data>
  <data name="WithEventsVariablesCanOnlyBeTypedAsClassesInterfacesOrTypeParametersWithClassConstraintsMessage" xml:space="preserve">
    <value>'WithEvents' 变量只能类型化为类、接口或具有类约束的类型形参</value>
  </data>
  <data name="VariableNameExpectedMessage" xml:space="preserve">
    <value>应为变量名称</value>
  </data>
  <data name="AMidAssignmentStatementShouldHaveSyntaxMidStringIntegerOptionalIntegerStringMessage" xml:space="preserve">
    <value>Mid 赋值语句应具有语法 'Mid(String, Integer, [Optional]Integer) = String'</value>
  </data>
  <data name="TupleMustContainAtLeastTwoElementsMessage" xml:space="preserve">
    <value>元组必须至少包含两个元素。</value>
  </data>
  <data name="WinRTMethodCannotHaveByRefParametersMessage" xml:space="preserve">
    <value>WinRT 方法不能有 'ByRef' 形参</value>
  </data>
  <data name="ReturnStatementInAFunctionGetOrOperatorMustReturnAValueMessage" xml:space="preserve">
    <value>Function、Get 或 Operator 中的 'Return' 语句必须返回值</value>
  </data>
  <data name="PossibleWriteToMeMessage" xml:space="preserve">
    <value>可能写入到 'Me'</value>
  </data>
  <data name="CannotApplyOperatorToOperandsOfTypeAndMessage" xml:space="preserve">
    <value>不能将运算符 '{0}' 应用于 '{1}' 和 '{2}' 类型的操作数</value>
  </data>
  <data name="SingleLineLambdaCannotHaveTheIteratorModifierMessage" xml:space="preserve">
    <value>单行 lambda 不能具有 'iterator' 修饰符</value>
  </data>
  <data name="IteratorWithoutYieldStatementMessage" xml:space="preserve">
    <value>不带 Yield 语句的 iterator</value>
  </data>
  <data name="IsValidOnlyWithinAnInstanceMethodMessage" xml:space="preserve">
    <value>'{0}' 仅在实例方法中有效</value>
  </data>
  <data name="MethodDiffersOnlyByOptionalParameterIsAlreadyDeclaredInMessage" xml:space="preserve">
    <value>已在{0} '{1}' 中声明仅可选形参不同的方法</value>
  </data>
  <data name="TypeIsNotAwaitableMessage" xml:space="preserve">
    <value>类型 '{0}' 不可等待</value>
  </data>
  <data name="ThelSuffixIsEasilyConfusedWithTheDigit" xml:space="preserve">
    <value>'l' 后缀容易与数字 '1' 混淆</value>
  </data>
  <data name="ParenthesesCanBeSafelyRemovedFromExpressionsWithoutChangingCodeSemantics" xml:space="preserve">
    <value>可以安全地从表达式中移除圆括号而不更改代码语义</value>
  </data>
  <data name="DontProvideGenericArgumentsWhenTakingMethodNamesMessage" xml:space="preserve">
    <value>请勿在获取方法命名时提供泛型实参</value>
  </data>
  <data name="RedundantEmptyCaseElseMessage" xml:space="preserve">
    <value>冗余的空 case else</value>
  </data>
  <data name="BaseClassDoesntContainParameterlessConstructorMessage" xml:space="preserve">
    <value>基类 '{0}' 不包含无形参构造函数</value>
  </data>
  <data name="TheTypeMustBeAReferenceTypeInOrderToUseItAsParameterMessage" xml:space="preserve">
    <value>类型 '{0}' 必须为引用类型才能将其用作形参 '{1}'</value>
  </data>
  <data name="ArrayExceedsTheLimitOfDimensionsMessage" xml:space="preserve">
    <value>数组超出 32 个维度的限制</value>
  </data>
  <data name="PartOfLoopsBodyCanBeConvertedIntoLINQExpressionMessage" xml:space="preserve">
    <value>循环体的一部分可以转换为 LINQ 表达式</value>
  </data>
  <data name="IIfInvocationWithIdenticalSecondAndThirdArgumentsMessage" xml:space="preserve">
    <value>'IIf' 调用的第二个和第三个实参相同</value>
  </data>
  <data name="ConditionalOperatorContainsTrueOrFalseInResultBranchForExamplepreIfConditionTrueElseBranchIfConditionThenBranchTruePre" xml:space="preserve">
    <value>条件运算符在结果分支中包含 'True' 或 'False'，例如
              &lt;pre&gt;
                If(condition, True, elseBranch)
                If(condition, thenBranch : True)
              &lt;/pre&gt;</value>
  </data>
  <data name="MemberInAModuleCannotBeDeclaredSharedMessage" xml:space="preserve">
    <value>模块中的成员不能被声明为 'Shared'</value>
  </data>
  <data name="TypeArgumentsForCannotBeInferredFromTheQueryMessage" xml:space="preserve">
    <value>不能从查询中推断 '{0}' 的类型实参</value>
  </data>
  <data name="BaseDeclarationHasTheSameAnnotationMessage" xml:space="preserve">
    <value>基方法声明具有相同的注解</value>
  </data>
  <data name="ArrayInitializerCannotBeSpecifiedForANonConstantDimensionUseEmptyInitializerInsteadMessage" xml:space="preserve">
    <value>不能为非常量维度指定数组初始值设定项；请改用空初始值设定项 '{}'</value>
  </data>
  <data name="HasNoGetterMessage" xml:space="preserve">
    <value>{0} '{1}' 没有 getter</value>
  </data>
  <data name="AllPublicTypesMustBelongToNamespacesWithACommonPrefixMessage" xml:space="preserve">
    <value>所有 public 类型都应属于具有共同前缀的命名空间</value>
  </data>
  <data name="VBCompilerErrors_Text" xml:space="preserve">
    <value>VB 编译器错误</value>
  </data>
  <data name="MemberWithTheSameNameOrSignatureIsAlreadyDeclaredInMessage" xml:space="preserve">
    <value>已在{0} '{1}' 中声明了具有相同名称或签名的成员</value>
  </data>
  <data name="ConvertsPropertyDeclarationToVBNETAutoPropertySyntax" xml:space="preserve">
    <value>将属性声明转换为 VB.NET 自动属性语法。</value>
  </data>
  <data name="ConditionalExpressionHasIdenticalTrueAndFalseBranchesMessage" xml:space="preserve">
    <value>条件表达式具有相同的 true 和 false 分支</value>
  </data>
  <data name="ThereIsNoMatchingInInterfaceMessage" xml:space="preserve">
    <value>接口 '{3}' 中没有匹配的{0} '{1}{2}'</value>
  </data>
  <data name="ReadOnlyPropertyMustNotHaveSetterMessage" xml:space="preserve">
    <value>'ReadOnly' 属性不得有 setter</value>
  </data>
  <data name="AnnotatingSubByPureIsMeaninglessMessage" xml:space="preserve">
    <value>通过 &lt;Pure&gt; 注解 'Sub' 毫无意义</value>
  </data>
  <data name="ArrayInitializerIsExpectedMessage" xml:space="preserve">
    <value>应为数组初始值设定项</value>
  </data>
  <data name="PossibleIncorrectImplementationOfDoubleCheckLockingCheckedFieldMustBeVolatileOrAssignedFromLocalVariableAfterThreadMemoryBarrierCallMessage" xml:space="preserve">
    <value>可能错误地实现了双重检查锁定。checked 字段必须为 volatile 或在 'Thread.MemoryBarrier()' 调用之后从局部变量中赋值</value>
  </data>
  <data name="NamespaceShouldBeTheDefaultNamespaceOfThisProjectMessage" xml:space="preserve">
    <value>命名空间 '{0}' 应为此项目的默认命名空间</value>
  </data>
  <data name="MeCannotBeTheTargetOfAnAssignmentMessage" xml:space="preserve">
    <value>'Me' 不能是赋值的目标</value>
  </data>
  <data name="ArraysInWinRTPublicAPIMustBeSingleDimensionalMessage" xml:space="preserve">
    <value>WinRT 公开 API 中的数组应该是一维数组</value>
  </data>
  <data name="WinRTParametersOfArrayTypeMustBeAnnotatedWithEitherReadOnlyArrayAttributeOrWriteOnlyArrayAttributeAttributeMessage" xml:space="preserve">
    <value>必须使用 'ReadOnlyArrayAttribute' 或 'WriteOnlyArrayAttribute' 特性注解数组类型的 WinRT 形参</value>
  </data>
  <data name="AwaitCannotBeUsedInATryCatchOrATryFinallyOrASyncLockMessage" xml:space="preserve">
    <value>'await' 不能在 try catch 或 try finally 或 SyncLock 中使用</value>
  </data>
  <data name="UseImplicitlyTypedVariableDeclarationWhenVariableTypeIsEvidentFromInitializerExpression" xml:space="preserve">
    <value>在可以从初始值设定项表达式中明显看出变量类型时，使用隐式类型化变量声明</value>
  </data>
  <data name="DoesntReturnAValueOnAllCodePathsAreYouMissingAReturnStatementMessage" xml:space="preserve">
    <value>{0} 不在所有代码路径上返回值。您是否缺少 'Return' 语句?</value>
  </data>
  <data name="TypeNameExpectedButNameFoundMessage" xml:space="preserve">
    <value>应为类型名称，但实际为{0}名称</value>
  </data>
  <data name="NamespaceWithPublicTypesShouldStartWithCommonPrefixMessage" xml:space="preserve">
    <value>具有 public 类型的命名空间应以公共前缀 '{0}' 开头</value>
  </data>
  <data name="PropertiesWithNoRequiredParametersCannotBeDeclaredDefaultMessage" xml:space="preserve">
    <value>没有所需形参的属性不能被声明为 'Default'</value>
  </data>
  <data name="ImplementsKeywordMustBeUsedWithAnInterfaceMessage" xml:space="preserve">
    <value>implements 关键字必须与接口一起使用</value>
  </data>
  <data name="RedundantEmptyCaseElseStatement" xml:space="preserve">
    <value>冗余的空 'case else' 语句</value>
  </data>
  <data name="CannotBecauseTheyDifferByTheDefaultValuesOfOptionalParameterMessage" xml:space="preserve">
    <value>'{0}' 不能{1} '{2}'，因为它们的可选形参默认值不同</value>
  </data>
  <data name="PointerTypesAreNotAllowedInWinRTPublicAPIMessage" xml:space="preserve">
    <value>WinRT 公开 API 中不允许使用指针类型</value>
  </data>
  <data name="QualifierMyClassIsRedundantMessage" xml:space="preserve">
    <value>限定符 'MyClass.' 冗余</value>
  </data>
  <data name="MyClassQualifierIsRedundantAndCanBeSafelyRemovedWithoutChangingCodeSemantics" xml:space="preserve">
    <value>'MyClass.' 限定符冗余，可以安全地移除而不更改代码语义。</value>
  </data>
  <data name="ToReturnAValueFromAnIteratorFunctionUseYieldMessage" xml:space="preserve">
    <value>要从 iterator 函数返回值，请使用 'yield'</value>
  </data>
  <data name="UseImplicitByValModifierInParameterDeclaration" xml:space="preserve">
    <value>在形参声明中使用隐式 'ByVal' 修饰符</value>
  </data>
  <data name="MultipleWithTheSameNumberOfParametersCannotBeMarkedWithDefaultOverloadAttributeMessage" xml:space="preserve">
    <value>不能使用 'DefaultOverloadAttribute' 标记具有相同数量形参的多个{0}</value>
  </data>
  <data name="YieldCannotCurrentlyBeUsedInALINQQueryMessage" xml:space="preserve">
    <value>'yield' 当前不能在 LINQ 查询中使用</value>
  </data>
  <data name="ExpressionIsAlwaysMessage" xml:space="preserve">
    <value>表达式始终为 {0}</value>
  </data>
  <data name="NonReadonlyFieldReferencedInGetHashCodeMessage" xml:space="preserve">
    <value>'GetHashCode()' 中引用了非只读字段</value>
  </data>
  <data name="MethodNameExpectedMessage" xml:space="preserve">
    <value>应为方法名称</value>
  </data>
  <data name="ThelSuffixIsEasilyConfusedWithTheDigitUseLForClarity" xml:space="preserve">
    <value>'l' 后缀容易与数字 '1' 混淆，为了清楚起见，请使用 'L'</value>
  </data>
  <data name="ReadOnlyCannotBeUsedAsAnAssignmentTargetMessage" xml:space="preserve">
    <value>'ReadOnly' {0} 不能用作赋值目标</value>
  </data>
  <data name="WinRTFieldCannotBeOfTypeEachFieldInAWinRTStructureCanOnlyBeUIntIntUIntIntUIntIntUIntSingleDoubleBooleanStringEnumCharOrItselfAStructureMessage" xml:space="preserve">
    <value>WinRT 字段不能为 '{0}' 类型。WinRT 结构中的每个字段只能为 UInt8、Int16、UInt16、Int32、UInt32、Int64、UInt64、Single、Double、Boolean、String、Enum、Char 或本身就是结构.</value>
  </data>
  <data name="YieldCanOnlyBeUsedInAMethodMarkedWithTheIteratorModifierMessage" xml:space="preserve">
    <value>只能在使用 'iterator' 修饰符标记的方法中使用 Yield</value>
  </data>
  <data name="CannotUseOverloadResolutionPriorityOnThisMemberMessage" xml:space="preserve">
    <value>无法在此成员上使用 'OverloadResolutionPriorityAttribute'</value>
  </data>
  <data name="SubCannotHaveReturnTypeMessage" xml:space="preserve">
    <value>'Sub' 不能有返回值类型</value>
  </data>
  <data name="TryCastOperandsMustBeClassConstrainedTypeParameterButHasNoClassConstraintMessage" xml:space="preserve">
    <value>'TryCast' 操作数必须为类约束的类型形参，但 '{0}' 没有类约束</value>
  </data>
  <data name="ApplyingContainerNullnessAnnotationToNonContainerTypeIsMeaninglessMessage" xml:space="preserve">
    <value>对非容器类型应用容器为 null 性注解毫无意义</value>
  </data>
  <data name="IsNotAnAttributeMessage" xml:space="preserve">
    <value>'{0}' 不是特性</value>
  </data>
  <data name="NullableTypeArgumentIsNotValueTypeMessage" xml:space="preserve">
    <value>类型 '{0}' 必须是值类型或约束为 ‘Structure' 的类型实参，才能与 ‘Nullable’ 或可以为 null 修饰符 ‘?’ 一起使用</value>
  </data>
  <data name="GCSuppressFinalizeIsInvokedForTypeWithoutDestructorMessage" xml:space="preserve">
    <value>为不带析构函数的类型调用了 'GC.SuppressFinalize'</value>
  </data>
  <data name="InconsistentAccessibilityReturnTypeIsLessAccessibleThanMessage" xml:space="preserve">
    <value>可访问性不一致: 返回值类型 '{0}' 的可访问性低于{1} '{2}'</value>
  </data>
  <data name="IsNotAMemberOfMessage" xml:space="preserve">
    <value>'{0}' 不是 '{1}' 的成员</value>
  </data>
  <data name="ArrayInitializerHasTooManyDimensionsMessage" xml:space="preserve">
    <value>数组初始值设定项的维度太多</value>
  </data>
  <data name="MethodNameExpectedButNameFoundMessage" xml:space="preserve">
    <value>应为方法名称，但实际为{0}名称</value>
  </data>
  <data name="TheparamsParameterMustBeASingleDimensionalArrayMessage" xml:space="preserve">
    <value>'params' 形参必须为一维数组</value>
  </data>
  <data name="MethodDoesNotHaveASignatureCompatibleWithDelegateMessage" xml:space="preserve">
    <value>方法 '{0}' 没有与委托 '{1}' 兼容的签名</value>
  </data>
  <data name="AccessToForeachVariableInClosureMayHaveDifferentBehaviourWhenCompiledWithDifferentVersionsOfCompilerMessage" xml:space="preserve">
    <value>访问闭包中的 foreach 变量。当使用其他版本的编译器编译时，可能具有不同的行为。</value>
  </data>
  <data name="SimplifyIIf" xml:space="preserve">
    <value>简化 'IIf'</value>
  </data>
  <data name="CanBeReplacedWithDimTryCastIfIsNotNothingEndIfMessage" xml:space="preserve">
    <value>可被替换为 'Dim {0}{3} = TryCast({1}, {2}) If ({0} IsNot Nothing) ... EndIf'</value>
  </data>
  <data name="InactivePreprocessorBranchMessage" xml:space="preserve">
    <value>停用的预处理程序分支</value>
  </data>
  <data name="AssignmentToAPropertyOfAReadonlyFieldCanBeUselessFieldTypeIsNotKnownToBeReferenceTypeMessage" xml:space="preserve">
    <value>对只读字段属性赋值可能没有意义。字段类型并非已知为引用类型</value>
  </data>
  <data name="UseImplicitByValParameterModifierMessage" xml:space="preserve">
    <value>使用隐式 'ByVal' 形参修饰符</value>
  </data>
  <data name="HandlesClauseRequiresAWithEventsVariableDefinedInTheContainingTypeOrOneOfItsBaseTypesMessage" xml:space="preserve">
    <value>Handles 子句需要在包含类型或其中一个基类型中定义 WithEvents 变量</value>
  </data>
  <data name="ConstantCannotBeUsedAsAnAssignmentTargetMessage" xml:space="preserve">
    <value>常量不能用作赋值目标</value>
  </data>
  <data name="ParameterlessPropertyParameterParenthesesAreRedundant" xml:space="preserve">
    <value>无形参属性形参圆括号冗余</value>
  </data>
  <data name="TupleElementNamesMustBeUniqueMessage" xml:space="preserve">
    <value>元组元素名称必须唯一。</value>
  </data>
  <data name="WhenInitializingAnArrayOfArraysBoundsCanOnlyBeSpecifiedForTheTopLevelArrayMessage" xml:space="preserve">
    <value>初始化一组数组时，只能为顶级数组指定界限</value>
  </data>
  <data name="TryCastOperandMustBeReferenceTypeButIsAValueTypeMessage" xml:space="preserve">
    <value>'TryCast' 操作数必须为引用类型，但 '{0}' 为值类型</value>
  </data>
  <data name="PropertyMightHaveOnlyGetAndASetMessage" xml:space="preserve">
    <value>属性可能只有 'Get' 和 'Set'</value>
  </data>
  <data name="CannotInvokeAnExtensionMethodOverImplicitClassInstanceInStaticContextMessage" xml:space="preserve">
    <value>不能在静态上下文中对隐式类实例调用扩展方法 '{0}'</value>
  </data>
  <data name="ExplicitSetAccessorvalueParameterDeclarationIsRedundant" xml:space="preserve">
    <value>显式 set 访问器 'value' 形参声明冗余</value>
  </data>
  <data name="ConvertPropertyToAutoProperty" xml:space="preserve">
    <value>将属性转换为自动属性</value>
  </data>
  <data name="ClassCannotInheritSealedClassMessage" xml:space="preserve">
    <value>类不能继承密封类</value>
  </data>
  <data name="TheCallerArgumentExpressionAttributeAppliedToParameterWillHaveNoEffectItIsAppliedWithAnInvalidParameterNameMessage" xml:space="preserve">
    <value>应用于形参 '{0}' 的 CallerArgumentExpressionAttribute 不起任何作用。应用它时使用了无效的形参名称。</value>
  </data>
  <data name="TheAsyncLambdaExpressionMustEitherBeSubOrFunctionThatReturnsTaskOrTaskOfTMessage" xml:space="preserve">
    <value>async lambda 表达式必须为返回 Task 或 Task(Of T) 的 Sub 或 Function</value>
  </data>
  <data name="AsyncAndIteratorModifiersCannotBeUsedTogetherMessage" xml:space="preserve">
    <value>'async' 和 'iterator' 修饰符不能一起使用</value>
  </data>
  <data name="DuplicateDefinitionModifierPartialIsPossiblyMissingMessage" xml:space="preserve">
    <value>重复的定义 '{0}'。可能缺少修饰符 'Partial'</value>
  </data>
  <data name="LateboundOverloadResolutionCannotBeAppliedToBecauseTheAccessingInstanceIsAnInterfaceTypeMessage" xml:space="preserve">
    <value>不能对 '{0}' 应用后期绑定重载解析，因为访问实例为接口类型</value>
  </data>
  <data name="ArraysCannotBeNestedInWinRTPublicAPIMessage" xml:space="preserve">
    <value>数组不能嵌套在 WinRT 公开 API 中</value>
  </data>
  <data name="UnableToChooseAMoreSpecificCandidateCandidatesAreMessage" xml:space="preserve">
    <value>不能选择更具体的候选项。候选项为: {0}</value>
  </data>
  <data name="MethodHasTheReturnValueNamedWhichIsTheSameAsAParameterNameWinRTMethodParametersAndReturnValueMustHaveUniqueNamesMessage" xml:space="preserve">
    <value>方法具有名为 '{0}' 的返回值，该名称与形参名称相同。WinRT 方法形参和返回值必须具有唯一名称。</value>
  </data>
  <data name="CannotAssignToAPropertyWithoutSetterOrWithInaccessibleSetterMessage" xml:space="preserve">
    <value>不能对没有 setter 或 setter 无法访问的属性赋值</value>
  </data>
  <data name="Message" xml:space="preserve">
    <value>{0}</value>
  </data>
  <data name="EventsDeclaredWithAnAsClauseMustHaveADelegateTypeMessage" xml:space="preserve">
    <value>使用 'as' 子句声明的事件必须具有委托类型</value>
  </data>
  <data name="PossibleIncorrectImplementationOfDoubleCheckLockingReadAccessToCheckedFieldMessage" xml:space="preserve">
    <value>可能错误地实现了双重检查锁定。请对 checked 字段进行读取访问</value>
  </data>
  <data name="DuplicateDefinitionMessage" xml:space="preserve">
    <value>重复的定义 '{0}'</value>
  </data>
  <data name="ConvertsPropertyDeclarationToVBNETAutoPropertySyntaxWithPrivateSetterDeclared" xml:space="preserve">
    <value>将属性声明转换为声明了 private setter 的 VB.NET 自动属性语法。</value>
  </data>
  <data name="CannotResolveSymbolErrorTypeMessage" xml:space="preserve">
    <value>不能解析符号 '{0}'。错误类型: {1}</value>
  </data>
  <data name="TypeArgumentsCannotBeInferredFromTheUsageTrySpecifyingTypeArgumentsExplicitlyCandidatesAreMessage" xml:space="preserve">
    <value>不能从用法中推断类型实参。请尝试显式指定类型实参。候选项为: {0}</value>
  </data>
  <data name="WinRTStructureMayOnlyContainPublicFieldsMessage" xml:space="preserve">
    <value>WinRT 结构只能包含 public 字段</value>
  </data>
  <data name="CannotInferAnElementTypeOfAnonymousArrayAndOptionStrictOnDoesNotAllowObjectToBeAssumedMessage" xml:space="preserve">
    <value>不能推断匿名数组的元素类型，Option Strict On 不允许假定 'Object'</value>
  </data>
  <data name="ConvertPropertyToAutoPropertyWhenPossible" xml:space="preserve">
    <value>如果可能，将属性转换为自动属性</value>
  </data>
  <data name="RedundantArrayLowerBoundSpecificationMessage" xml:space="preserve">
    <value>冗余的数组下限规范</value>
  </data>
  <data name="CannotSpecifyADefaultValueForAParameterArrayMessage" xml:space="preserve">
    <value>无法为参数数组指定默认值</value>
  </data>
  <data name="AsyncMethodWithoutAwaitOperatorMessage" xml:space="preserve">
    <value> async 方法没有 await 运算符</value>
  </data>
  <data name="DigitSeparatorCannotBeUsedInAPositionWhereItsNotSeparatingTheDigitsMessage" xml:space="preserve">
    <value>不能在不分隔数字的位置使用数字分隔符</value>
  </data>
  <data name="RedundantExplicitArraySizeSpecificationMessage" xml:space="preserve">
    <value>冗余的显式数组大小规范</value>
  </data>
  <data name="CannotCreateAnInstanceOfTypeParameterBecauseItDoesNotHaveANewConstraintMessage" xml:space="preserve">
    <value>不能创建类型形参 '{0}' 的实例，因为它没有 'new' 约束</value>
  </data>
  <data name="SimilarExpressionsComparisonMessage" xml:space="preserve">
    <value>类似表达式比较</value>
  </data>
  <data name="RemoveRedundantParenthesesMessage" xml:space="preserve">
    <value>移除冗余圆括号</value>
  </data>
  <data name="SpecifyStringComparisonExplicitlyMessage" xml:space="preserve">
    <value>显式指定字符串比较</value>
  </data>
  <data name="AmbiguousReferenceMessage" xml:space="preserve">
    <value>不明确的引用 '{0}'</value>
  </data>
  <data name="SharedFieldOrPropertyCannotBeAssignedInAnObjectInitializerMessage" xml:space="preserve">
    <value>不能在对象初始值设定项中对共享字段或属性 '{0}' 赋值</value>
  </data>
  <data name="UnresolvedJumpMessage" xml:space="preserve">
    <value>未被解析的跳转</value>
  </data>
  <data name="ReturnStatementInThisAsyncMethodCannotReturnAValueConsiderChangingTheMethodReturnTypeToTaskOfTMessage" xml:space="preserve">
    <value>此 async 方法中的 'Return' 语句不能返回值。请考虑将方法返回值类型改为 'Task(Of T)'</value>
  </data>
  <data name="MissingImplementationOfMembersMessage" xml:space="preserve">
    <value>缺少成员的实现: {0}{1}</value>
  </data>
  <data name="InterfaceIsNotImplementedByThisClassMessage" xml:space="preserve">
    <value>接口 '{0}' 不由此类实现</value>
  </data>
  <data name="ShadowsAnOverridableMethodInTheBaseClassMessage" xml:space="preserve">
    <value>{0} '{1}' 在基类 '{2}' 中隐藏可重写的方法</value>
  </data>
  <data name="ArrayInitializerHasTooFewDimensionsMessage" xml:space="preserve">
    <value>数组初始值设定项的维度太少</value>
  </data>
  <data name="VisualBasicLanguageFeatureMessage" xml:space="preserve">
    <value>Visual Basic 11.0 语言功能</value>
  </data>
  <data name="WinRTDoesNotSupportSetterOnlyPropertiesMessage" xml:space="preserve">
    <value>WinRT 不支持仅 setter 属性</value>
  </data>
  <data name="AndCannotBeCombinedMessage" xml:space="preserve">
    <value>'{0}' 和 '{1}' 不能组合</value>
  </data>
  <data name="TheModifierIteratorIsNotValidForThisItemMessage" xml:space="preserve">
    <value>修饰符 'iterator' 对此条目无效</value>
  </data>
  <data name="Message6" xml:space="preserve">
    <value />
  </data>
  <data name="Message2" xml:space="preserve">
    <value>{0}：{1}</value>
  </data>
  <data name="InconsistentAccessibilityConstraintTypeIsLessAccessibleThanMessage" xml:space="preserve">
    <value>可访问性不一致: 约束类型 '{0}' 的可访问性低于{1} '{2}'</value>
  </data>
  <data name="ThreadStaticFieldHasInitializerMessage" xml:space="preserve">
    <value>线程 static 字段具有初始值设定项</value>
  </data>
  <data name="MultipleNullnessAttributesUsageMessage" xml:space="preserve">
    <value>多个为 null 性特性用法</value>
  </data>
  <data name="CannotAwaitNothingConsiderAwaitingTaskExYieldInsteadMessage" xml:space="preserve">
    <value>不能等待 Nothing。请考虑改为等待 'TaskEx.Yield()'</value>
  </data>
  <data name="AnalysisIsNotAvailableForTheFileFileLanguageIsNotVBNETMessage" xml:space="preserve">
    <value>无法分析该文件。文件语言不是 Visual Basic。</value>
  </data>
  <data name="ArgumentsMismatchMessage" xml:space="preserve">
    <value>实参不匹配</value>
  </data>
  <data name="IIfContainsTrueOrFalseInResultBranchForExamplepreIIfConditionTrueElseBranchIIfConditionThenBranchTruePre" xml:space="preserve">
    <value>'IIf' 在结果分支中包含 'True' 或 'False'，例如
              &lt;pre&gt;
                IIf(condition, True, elseBranch)
                IIf(condition, thenBranch : True)
              &lt;/pre&gt;</value>
  </data>
  <data name="InterfaceCannotInheritFromATypeNestedWithinItMessage" xml:space="preserve">
    <value>接口 '{0}' 不能继承自嵌套在其中的类型</value>
  </data>
  <data name="IfOperatorRequiresEitherTwoOrThreeOperandsMessage" xml:space="preserve">
    <value>'If' 运算符需要两个或三个操作数</value>
  </data>
  <data name="TheModifierAsyncIsNotValidForThisItemMessage" xml:space="preserve">
    <value>修饰符 'async' 对此条目无效</value>
  </data>
  <data name="WinRTParametersOfArrayTypeCannotBeBothAnnotatedWithReadOnlyArrayAttributeAndWriteOnlyArrayAttributeAtributesMessage" xml:space="preserve">
    <value>不能同时使用 'ReadOnlyArrayAttribute' 和 'WriteOnlyArrayAttribute' 特性注解数组类型的 WinRT 形参</value>
  </data>
  <data name="CannotCreateAnArrayOfNegativeSizeMessage" xml:space="preserve">
    <value>不能创建大小为负的数组</value>
  </data>
  <data name="IncorrectNumberOfArgumentsCandidatesAreMessage" xml:space="preserve">
    <value>实参类型的数量不正确。候选项为: {0}</value>
  </data>
  <data name="AccessOfSharedMemberConstantMemberEnumMemberOrNestedTypeThroughAnInstanceQualifyingExpressionWillNotBeEvaluatedMessage" xml:space="preserve">
    <value>通过实例访问共享成员、常量成员、枚举成员或嵌套类型；将不对限定表达式求值</value>
  </data>
  <data name="ExpressionDoesNotProduceAValueMessage" xml:space="preserve">
    <value>表达式不生成值</value>
  </data>
  <data name="CannotCreateAnInstanceOfInterfaceMessage" xml:space="preserve">
    <value>不能创建接口 '{0}' 的实例</value>
  </data>
  <data name="PossibleWriteToMe1" xml:space="preserve">
    <value>可能写入到 'Me'。</value>
  </data>
  <data name="MethodPropertyDelegateOrEventIsExpectedMessage" xml:space="preserve">
    <value>应为方法、属性、委托或事件</value>
  </data>
  <data name="PossibleWriteToMe" xml:space="preserve">
    <value>可能写入到 'Me'</value>
  </data>
  <data name="ImportClauseIsNotRequiredByTheCodeAndCanBeSafelyRemovedMessage" xml:space="preserve">
    <value>代码不需要 import 子句，可以安全地移除</value>
  </data>
  <data name="ArrayLowerBoundSpecificationIsRedundant" xml:space="preserve">
    <value>数组下限规范冗余</value>
  </data>
  <data name="DefaultMemberIsNotAPropertyMessage" xml:space="preserve">
    <value>默认成员 '{0}' 不是属性</value>
  </data>
  <data name="RedundantMyBaseQualifier" xml:space="preserve">
    <value>冗余的 'MyBase.' 限定符</value>
  </data>
  <data name="FieldOrPropertyNameExpectedButNameFoundMessage" xml:space="preserve">
    <value>应为字段或属性名称，但实际为{0}名称</value>
  </data>
  <data name="NamespaceNameExpectedMessage" xml:space="preserve">
    <value>应为命名空间名称</value>
  </data>
  <data name="QualifierIsRedundantMessage" xml:space="preserve">
    <value>限定符冗余</value>
  </data>
  <data name="OperatorTypeOfIsCanBeUsedMessage" xml:space="preserve">
    <value>可以使用 'TypeOf ... Is ...' 运算符</value>
  </data>
  <data name="ObjectReferenceEqualsIsAlwaysFalseBecauseItIsCalledWithValueTypeMessage" xml:space="preserve">
    <value>'Object.ReferenceEquals' 始终为 false，因为它使用值类型进行调用</value>
  </data>
  <data name="WinRTTypeCannotBeNestedMessage" xml:space="preserve">
    <value>WinRT 类型不能嵌套</value>
  </data>
  <data name="TryCatchAndTryFinallyStatementsCanBeMergedMessage" xml:space="preserve">
    <value>可以合并 try-catch 和 try-finally 语句</value>
  </data>
  <data name="ArrayModifiersCannotBeSpecifiedOnBothAVariableAndItsTypeMessage" xml:space="preserve">
    <value>不能同时对变量及其类型指定数组修饰符</value>
  </data>
  <data name="TypeDoesntFollowTheAwaitPatternMessage" xml:space="preserve">
    <value>类型 '{0}' 不遵循等待模式</value>
  </data>
  <data name="IsAlreadyImplementedInThisClassMessage" xml:space="preserve">
    <value>{0} '{1}' 已在此类中实现</value>
  </data>
  <data name="EqualityComparisonOfFloatingPointNumbersMessage" xml:space="preserve">
    <value>浮点数的相等比较。{0}</value>
  </data>
  <data name="CallToMyBaseEqualsIsReferenceEqualityMessage" xml:space="preserve">
    <value>对 'MyBase.Equals(...)' 的调用是引用相等</value>
  </data>
  <data name="CircularDependencyInvolvingAndMessage" xml:space="preserve">
    <value>涉及 '{1}' 和 '{2}' 的循环{0}依赖项</value>
  </data>
</root>
