<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="InstantiationCannotBeTransformedInto_Collection_Text" xml:space="preserve">
    <value>{0, 实例化}无法转换为工厂方法: 无法提取集合初始值设定项</value>
  </data>
  <data name="_ExtractMethod_Text" xml:space="preserve">
    <value>提取方法(&amp;E)</value>
  </data>
  <data name="IntroduceVariableForSubstring_Text" xml:space="preserve">
    <value>为子字符串引入变量</value>
  </data>
  <data name="UsageOf_InConstantContextWillBecome_Text" xml:space="preserve">
    <value>常量上下文中的 '{0}' 用法将失效</value>
  </data>
  <data name="UseDefaultParameterValue__Text" xml:space="preserve">
    <value>使用默认形参值({0})</value>
  </data>
  <data name="UsingDeclarationConflict_Text" xml:space="preserve">
    <value>变量是 'using' 声明的一部分，内联可能会导致资源泄漏</value>
  </data>
  <data name="_HasUnresolvedTypeOfParametersMethod_Text" xml:space="preserve">
    <value>{0}具有未解析的形参类型。方法不会被转换。</value>
  </data>
  <data name="SelectNone_Text" xml:space="preserve">
    <value>不选择(_O)</value>
  </data>
  <data name="DeterminingImportScopes_Text" xml:space="preserve">
    <value>正在确定导入作用域</value>
  </data>
  <data name="Field_AccessWillBecomePolymorphic_Text" xml:space="preserve">
    <value>字段{0}访问将变为多态</value>
  </data>
  <data name="__MightBeImpliclyUsedByTheCompilerGenerated_Text" xml:space="preserve">
    <value>{0} '{{0}}' 可能由 '{1}' 记录类型的编译器生成 'Equals'/'GetHashCode'/'PrintMembers' 方法隐式使用</value>
  </data>
  <data name="UsageOf_MayBeBrokenMethodCallOver_Can_Text" xml:space="preserve">
    <value>{0}的用法可能会被破坏: 对{0}的方法调用可能会改变结构，因为它被归类为变量。属性在每次访问时返回临时结构副本，因此不会观察到突变的结果。</value>
  </data>
  <data name="ChangeNullability_Text" xml:space="preserve">
    <value>更改为 null 性</value>
  </data>
  <data name="VariableHasUnsupportedUsageKind_Text" xml:space="preserve">
    <value>变量具有不受支持的用法类型</value>
  </data>
  <data name="UsageOf_MayBeBrokenIfStructTypeWill_MutateVariable_Text" xml:space="preserve">
    <value>如果结构类型将被替换为不受约束的泛型类型形参，则{0}的用法可能会被破坏: 对{0}的方法调用可能会改变结构，因为它被归类为可变变量</value>
  </data>
  <data name="SignatureChangeConflictsWithSignature_Text" xml:space="preserve">
    <value>签名更改与{0,委托}的签名冲突</value>
  </data>
  <data name="ConvertToGlobalUsing_Text" xml:space="preserve">
    <value>转换为 global using</value>
  </data>
  <data name="CannotRenameIndexers_Text" xml:space="preserve">
    <value>无法重命名索引器</value>
  </data>
  <data name="ReturnedValueOf0CallIsNotUsed_Text" xml:space="preserve">
    <value>{0,调用}的返回值未使用</value>
  </data>
  <data name="ConvertToGlobalUsing_RemoveUsingDirective_X_Of_N_Text" xml:space="preserve">
    <value>正在移除 using 指令({0:N0}/{1:N0})</value>
  </data>
  <data name="AssignedValueHasNoReachableUsages_Text" xml:space="preserve">
    <value>所赋的值没有可以访问的用法</value>
  </data>
  <data name="DeconstructInto_TextPrefix" xml:space="preserve">
    <value>析构到 </value>
  </data>
  <data name="ConvertToGlobalUsing_CheckingConflicts_Text" xml:space="preserve">
    <value>正在检查冲突</value>
  </data>
  <data name="ApplyNullabilityChange_Text" xml:space="preserve">
    <value>应用为 null 性更改…</value>
  </data>
  <data name="RemovingGlobalUsingDirectives_Text" xml:space="preserve">
    <value>正在移除 global using 指令…</value>
  </data>
  <data name="DeterminingSearchDomainFor__Text" xml:space="preserve">
    <value>正在确定 '{0}' 的搜索域</value>
  </data>
  <data name="ExtractProperty_Text" xml:space="preserve">
    <value>提取属性</value>
  </data>
  <data name="_FileName_Text" xml:space="preserve">
    <value>文件名(_F):</value>
  </data>
  <data name="AmbiguousDeclarationsFor_ReferenceWere_Text" xml:space="preserve">
    <value>发现 '{0}' 引用的不明确声明，将不会移除 using 指令</value>
  </data>
  <data name="ConvertToLogMethod_ExistingMethodLogLevelConstant_ConflictText" xml:space="preserve">
    <value>现有方法 '{0}' 应接受 LogLevel 作为形参，但它却具有 {1}</value>
  </data>
  <data name="StoringReferences_Text" xml:space="preserve">
    <value>正在存储引用…</value>
  </data>
  <data name="TransformParameters_Conflict_CannotCreateVariable_Text" xml:space="preserve">
    <value>无法在调用点为形参 '{0}' 声明变量</value>
  </data>
  <data name="NewAccessorIntroductionIsNotAllowedInExplicitImplementation_Text" xml:space="preserve">
    <value>{0}显式实现中不允许引入新的访问器</value>
  </data>
  <data name="ConvertToGeneratedMethod_MemberOfSourceType_Text" xml:space="preserve">
    <value>在调用的同一个类中创建方法</value>
  </data>
  <data name="InitOnlyPropertyWillBecomeMutableTo_Text" xml:space="preserve">
    <value>仅初始化属性将变为可变以避免破坏 {0} 用法</value>
  </data>
  <data name="MemberHas1UsageInObjectInitializer_Text" xml:space="preserve">
    <value>{0,成员}在对象初始值设定项中具有{1,用法}</value>
  </data>
  <data name="Attribute0_OfTheFieldDeclarationWill_Text" xml:space="preserve">
    <value>字段声明的特性 {{0,[{0}]}} 将被应用于属性声明</value>
  </data>
  <data name="_IsAMethodGroup_Text" xml:space="preserve">
    <value>{0} 为方法组</value>
  </data>
  <data name="MaKeStatic_Text" xml:space="preserve">
    <value>设为 static(&amp;K)</value>
  </data>
  <data name="RefactoringWillChangeInitAccessorOf_Text" xml:space="preserve">
    <value>重构会将属性 '{0}' 的 'init' 访问器更改为 'set' 访问器，从而能够将对象初始值设定项提取到赋值中</value>
  </data>
  <data name="PasteDeclarationsTo__Of__Text" xml:space="preserve">
    <value>将声明粘贴到 {0}({1:N0} / {2:N0})…</value>
  </data>
  <data name="UnableToRemoveTheAccessorFrom_Positional_Text" xml:space="preserve">
    <value>无法从 {0} 位置属性中移除访问器</value>
  </data>
  <data name="Parameter_CreatedIn___Text" xml:space="preserve">
    <value>在{1} ’{2}’ 中创建的形参 ’{0}’</value>
  </data>
  <data name="_WillBeConvertedToARegularMethodAsIt_Text" xml:space="preserve">
    <value>{0} 将被转换为常规方法，因为它同时用于原始代码和提取的代码</value>
  </data>
  <data name="UsageOf_MayBeBrokenIfStructTypeWill_Text" xml:space="preserve">
    <value>如果结构类型将被替换为不受约束的泛型类型形参，则{0}的用法可能会被破坏: 对{0}的方法调用可能会改变结构，因为它被归类为变量。属性在每次访问时返回临时结构副本，因此不会观察到突变的结果。</value>
  </data>
  <data name="RemovingOutArgumentOf0UsageMayCause_Text" xml:space="preserve">
    <value>移除{0, 用法}的 'out' 实参可能会导致问题</value>
  </data>
  <data name="NoValidQualifierCanBeCreatedFor0Usage_Text" xml:space="preserve">
    <value>无法为{0, 用法}创建有效限定符</value>
  </data>
  <data name="AtTheEndOfTopLevelStatements_Text" xml:space="preserve">
    <value>在顶层语句的末尾</value>
  </data>
  <data name="FieldWillBeEncapsulated_Text" xml:space="preserve">
    <value>{0,字段}将被封装</value>
  </data>
  <data name="_IsNotDeclaredAbstractBodyWillBeRemoved_Text" xml:space="preserve">
    <value>{0}未被声明为 abstract。主体将被移除。</value>
  </data>
  <data name="ConvertToGlobalUsing_TopUsingsInProject_Text" xml:space="preserve">
    <value>项目 '{0}' 中排名前列的 using:</value>
  </data>
  <data name="_0_WillBeMadeUnsafeInOrderToInlineUnsafe_Text" xml:space="preserve">
    <value>{0} '{{0,{1}}}' 将变得不安全，以将不安全的代码内联到其中</value>
  </data>
  <data name="_WillBeReplacedWithBackingFieldProperty_Text" xml:space="preserve">
    <value>{0}将被替换为支持字段属性</value>
  </data>
  <data name="OperationOrderChangeInCallsiteConflict_Text" xml:space="preserve">
    <value>操作顺序将在调用站点更改</value>
  </data>
  <data name="NewField_CreatedInType__Text" xml:space="preserve">
    <value>在类型 '{1}' 中创建的新字段 '{0}'</value>
  </data>
  <data name="_HasBaseClassUsage_Text" xml:space="preserve">
    <value>{0}具有基类用法</value>
  </data>
  <data name="ConvertToLogMethod_ExistingMethodWithoutAttribute_ConflictText" xml:space="preserve">
    <value>现有方法 '{0}' 应具有特性 '{1}'</value>
  </data>
  <data name="Usages_Text" xml:space="preserve">
    <value>{0} 个用法</value>
  </data>
  <data name="ConvertToGlobalUsing_DirectiveColumn_Text" xml:space="preserve">
    <value>指令</value>
  </data>
  <data name="CanTUpdate0_EncapsulatedFieldWonTBe_Text" xml:space="preserve">
    <value>无法更新 {{0,{0}}}: 封装的字段将无法访问</value>
  </data>
  <data name="RecordTypeImplicitMemberCouldNotBeRenamed_Text" xml:space="preserve">
    <value>记录类型隐式成员无法重命名</value>
  </data>
  <data name="UnableToRemove0DeconstructionUsage_Text" xml:space="preserve">
    <value>无法移除{0, 析构用法}</value>
  </data>
  <data name="UsageRequiresAStatementWhichCannot_Text" xml:space="preserve">
    <value>{0, 用法}需要无法在调用点创建的语句</value>
  </data>
  <data name="CallerCannotBeNull_Text" xml:space="preserve">
    <value>{0, 调用方}不能为 null</value>
  </data>
  <data name="ThisUsage0CanTBeResolved_Text" xml:space="preserve">
    <value>不能解析此用法 {$0}。</value>
  </data>
  <data name="__CannotBeAssignedInTheExtractedCode_Text" xml:space="preserve">
    <value>{0} '{{0}}' 不能在提取的代码中被赋值</value>
  </data>
  <data name="ConvertToLogMethod_ExistingMethodLogLevelRequired_ConflictText" xml:space="preserve">
    <value>现有方法 '{0}' 应接受 LogLevel 作为形参</value>
  </data>
  <data name="ExtractChainedConstructor_Text" xml:space="preserve">
    <value>提取链式构造函数</value>
  </data>
  <data name="CreateLocalFunctionInsideTheCurrent_Text" xml:space="preserve">
    <value>在当前成员内部创建局部函数</value>
  </data>
  <data name="Member_HasNotEnoughAccess_Text" xml:space="preserve">
    <value>成员 {0} 没有足够的可访问性级别</value>
  </data>
  <data name="_CanTBeTransformedCorrectlyDueToLanguage_Text" xml:space="preserve">
    <value>由于语言特定的原因，不能正确转换{0}</value>
  </data>
  <data name="_CannotBeMadePublicThereIsAConflicting_Text" xml:space="preserve">
    <value>{0}不能设为 public。存在冲突的{1}。</value>
  </data>
  <data name="ExtractMethod_LocalFunctionSelector_EditorAdornment_NextButtonText" xml:space="preserve">
    <value>在此处提取…</value>
  </data>
  <data name="ReadWriteUsage_Text" xml:space="preserve">
    <value>读取/写入用法</value>
  </data>
  <data name="ConvertToLogMethod_ExistingMethodLogLevelMismatch_ConflictText" xml:space="preserve">
    <value>现有方法 '{0}' 应具有 LogLevel = {2}，但它却具有 {1}</value>
  </data>
  <data name="TypeOfOutVariable_CannotBeUsedAtThe_Text" xml:space="preserve">
    <value>不能在调用点使用 out 变量 {0} 的类型</value>
  </data>
  <data name="ExtractMethod_PositionSelectorInlayHint_Text" xml:space="preserve">
    <value>使用箭头键选择局部函数的位置</value>
  </data>
  <data name="AmbiguousReference_WillBeUpdated_Text" xml:space="preserve">
    <value>不明确的引用 {0} 将被更新</value>
  </data>
  <data name="WillBeMadeStatic_ConflictText" xml:space="preserve">
    <value>扩展将被设为 static</value>
  </data>
  <data name="ConvertToLogMethod_LoggerParameter_Text" xml:space="preserve">
    <value>记录器形参:</value>
  </data>
  <data name="DelegateViaOverloading_CSharp8_Text" xml:space="preserve">
    <value>按原样保留调用，重载 {0} 并将实现委托给创建的重载(要求 C# 8.0 或更高版本)(_O)</value>
  </data>
  <data name="TheExtractedCodeHasMultipleExits_Text" xml:space="preserve">
    <value>提取的代码有多个出口</value>
  </data>
  <data name="TaskReturnedFromTheAsync0CallWillNo_Text" xml:space="preserve">
    <value>从异步{0,调用}返回的任务将不再可用</value>
  </data>
  <data name="CannotIntroduceVariableFromTheSelected_Text" xml:space="preserve">
    <value>不能从字符串的所选部分引入变量</value>
  </data>
  <data name="GlobalUsingDirectivesComment_Text" xml:space="preserve">
    <value>global using 指令</value>
  </data>
  <data name="AddingImport_Text" xml:space="preserve">
    <value>正在添加 import</value>
  </data>
  <data name="MethodIsUsedFor0Unsubscribing_Text" xml:space="preserve">
    <value>方法用于{0,退订}。</value>
  </data>
  <data name="PropertyAccessorsCannotBeRenamed_Text" xml:space="preserve">
    <value>属性访问器无法重命名</value>
  </data>
  <data name="SearchInSolution_Text" xml:space="preserve">
    <value>在解决方案中</value>
  </data>
  <data name="MergingResults_Text" xml:space="preserve">
    <value>正在合并结果</value>
  </data>
  <data name="EnableImplicitUsings_Action_Text" xml:space="preserve">
    <value>启用隐式 using</value>
  </data>
  <data name="TypeSystemFuncIsNotAvailable_Text" xml:space="preserve">
    <value>类型 System.Func 不可用</value>
  </data>
  <data name="_WillBeMovedToTheExtractedCodeAlongside_Text" xml:space="preserve">
    <value>{0} 将连同其所有用法一起移至提取的代码</value>
  </data>
  <data name="_Visibility_Text" xml:space="preserve">
    <value>可见性(_V):</value>
  </data>
  <data name="IntroducePartOfAQueryExpression_Text" xml:space="preserve">
    <value>引入查询表达式的一部分</value>
  </data>
  <data name="PrimaryConstructorParameterHasMutationUsage_Text" xml:space="preserve">
    <value>主构造函数形参在闭包中具有{0,变异用法}。目标自动属性将使用形参值的副本进行初始化，并且不会反映可变主构造函数形参的变化。</value>
  </data>
  <data name="ThereIsAmbiguousConstructorReference_Text" xml:space="preserve">
    <value>存在不明确的构造函数引用。将创建所有版本的构造函数。</value>
  </data>
  <data name="UsageOf_WillBeBrokenAccessedExpression_Text" xml:space="preserve">
    <value>{0} 的用法将被破坏: 访问的表达式应被归类为变量。自动属性访问在每次访问时返回值的临时副本。</value>
  </data>
  <data name="Inlining__Text" xml:space="preserve">
    <value>正在内联 '{0}'</value>
  </data>
  <data name="TypeNameShouldnTBeEmpty_Text" xml:space="preserve">
    <value>类型名称不得为空</value>
  </data>
  <data name="FieldInitializerWillNotBeMovedFor__Text" xml:space="preserve">
    <value>不会为 {0} 移动字段初始值设定项</value>
  </data>
  <data name="ExtractMethod_MovedLocalFunctionHint" xml:space="preserve">
    <value>&lt;将被移动&gt;</value>
  </data>
  <data name="CCodeFilesShouldBeUnderAppCodeFolder_Text" xml:space="preserve">
    <value>C# 代码文件必须在网站的 AppCode 文件夹下</value>
  </data>
  <data name="VariableHasUnsupportedInitializer_Text" xml:space="preserve">
    <value>变量具有不受支持的初始值设定项</value>
  </data>
  <data name="ExtractMethod_LocalFunctionSelector_EditorAdornment_MoveUpButtonTooltip" xml:space="preserve">
    <value>上移局部函数</value>
  </data>
  <data name="_IsUsedWithUnpresentableType_Text" xml:space="preserve">
    <value>{0}与无法呈现的类型一起使用</value>
  </data>
  <data name="Unknown_Text" xml:space="preserve">
    <value>&lt;未知&gt;</value>
  </data>
  <data name="ConvertToGlobalUsingPageTitle_Text" xml:space="preserve">
    <value>检查 using 指令</value>
  </data>
  <data name="CannotInline0Usage_Text" xml:space="preserve">
    <value>无法内联{0, 用法}。</value>
  </data>
  <data name="Attribute0_OfTheFieldDeclarationCannot_Text" xml:space="preserve">
    <value>字段声明的特性 {{0,[{0}]}} 不能被应用于属性声明，将在新上下文中被编译器忽略</value>
  </data>
  <data name="TypeCannotBeResolved_Text" xml:space="preserve">
    <value>类型不能解析</value>
  </data>
  <data name="ConvertToLogMethod_ExistingMethodEventIdMismatch_ConflictText" xml:space="preserve">
    <value>现有方法 '{0}' 应具有 EventId = {1}，但它却具有 {2}</value>
  </data>
  <data name="SearchInClass_Text" xml:space="preserve">
    <value>在类中</value>
  </data>
  <data name="InitializerExpressionIsOverwritten_Text" xml:space="preserve">
    <value>{0,初始值设定项表达式}在所有构造函数中被覆盖并且将被移除</value>
  </data>
  <data name="CreateConstructorToDelegateInitialization_Text" xml:space="preserve">
    <value>创建要将初始化委托到的构造函数</value>
  </data>
  <data name="RemovingLastDeconstructionComponent_Text" xml:space="preserve">
    <value>移除最后一个析构组件将破坏所有{0, 析构}用法</value>
  </data>
  <data name="ExtractMethod_LocalFunctionSelector_EditorAdornment_Title" xml:space="preserve">
    <value>提取本地函数</value>
  </data>
  <data name="CannotIntroduceVariable_Text" xml:space="preserve">
    <value>不能引入变量</value>
  </data>
  <data name="Property_OverridingBaseClassProperty_Text" xml:space="preserve">
    <value>属性 {0} 重写基类属性</value>
  </data>
  <data name="VariableHasWriteUsages_Text" xml:space="preserve">
    <value>变量有写入用法</value>
  </data>
  <data name="ToConvert_PropertyShouldBeNamedItem_Text" xml:space="preserve">
    <value>要转换{0}，属性必须被命名为 'Item'</value>
  </data>
  <data name="CannotMove__Text" xml:space="preserve">
    <value>无法移动 {0}</value>
  </data>
  <data name="RemovingOutArgumentWillBreakUsagesOf_Text" xml:space="preserve">
    <value>移除 'out' 实参将破坏 'out' {0, 变量}的用法</value>
  </data>
  <data name="AutoPropertyWillAlsoOverride__Text" xml:space="preserve">
    <value>自动属性也将重写{0}</value>
  </data>
  <data name="ConvertToNonGlobalUsing_Action_Text" xml:space="preserve">
    <value>转换为非 global using…</value>
  </data>
  <data name="CannotReplaceNameofArgumentWithDefault_Text" xml:space="preserve">
    <value>无法将 'nameof()' 实参替换为默认形参值</value>
  </data>
  <data name="InvalidType_Text" xml:space="preserve">
    <value>类型无效</value>
  </data>
  <data name="BackingField_AccessWillBecomePolymorphic_Text" xml:space="preserve">
    <value>支持字段{0}访问将变为多态</value>
  </data>
  <data name="UnableToPartiallyEncapsulateField0Usage_Text" xml:space="preserve">
    <value>无法部分封装字段{0,用法}</value>
  </data>
  <data name="ConvertToGeneratedMethod_MoveToAnotherClass_Text" xml:space="preserve">
    <value>将创建的方法移动到特定类(_M):</value>
  </data>
  <data name="After__Text" xml:space="preserve">
    <value>在{0}之后</value>
  </data>
  <data name="AtTheBeginningOf__Text" xml:space="preserve">
    <value>在 {0} 的开头</value>
  </data>
  <data name="CannotInlineAsynchronousCodeInNonAsync_Text" xml:space="preserve">
    <value>无法在非异步函数中内联异步代码</value>
  </data>
  <data name="_CannotBeReferencedInSourceFunction_Text" xml:space="preserve">
    <value>重构后不能在源函数中引用 {0}</value>
  </data>
  <data name="CreateDeconstructingDeclaration_Text" xml:space="preserve">
    <value>创建析构声明</value>
  </data>
  <data name="ChooseWhereToPlaceTheNewLocalFunction_Text" xml:space="preserve">
    <value>选择放置新局部函数的位置</value>
  </data>
  <data name="ConvertToLogMethod_ExistingMethodEventIdWillChange_ConflictText" xml:space="preserve">
    <value>现有方法 '{0}' 声明 EventId = {1}，与原始 EventId = {2} 不同</value>
  </data>
  <data name="Field0InitializerWillBeReplacedWith_Text" xml:space="preserve">
    <value>字段{0,初始值设定项}将被替换为构造函数中的多态赋值</value>
  </data>
  <data name="Existing0AutoPropertyWillBeBroken_Text" xml:space="preserve">
    <value>现有{0, 自动属性}将被破坏</value>
  </data>
  <data name="CreateNewMethodDeclarationBelowTheCurrent_Text" xml:space="preserve">
    <value>在当前成员下方创建新的方法声明</value>
  </data>
  <data name="MemberCanTHaveTheSameNameAsEnclosing_Text" xml:space="preserve">
    <value>成员不能与其封闭类型 {0} 同名</value>
  </data>
  <data name="ConvertToLogMethod_ExistingMethodMessageMismatch_ConflictText" xml:space="preserve">
    <value>现有方法 '{0}' 应具有 Message = {1}，但它却具有 {2}</value>
  </data>
  <data name="RemovingDeconstructionComponentWillBreakPattern_Text" xml:space="preserve">
    <value>移除析构组件将破坏模式{0, 变量}的用法</value>
  </data>
  <data name="NodeBecameInvalid_Text" xml:space="preserve">
    <value>节点失效</value>
  </data>
  <data name="ConvertToGlobalUsing_Action_Text" xml:space="preserve">
    <value>转换为 global using…</value>
  </data>
  <data name="ParameterWillBeReplacedWithLocalVariable_Text" xml:space="preserve">
    <value>形参将被替换为局部变量以保留用法</value>
  </data>
  <data name="CannotRunControlFlowAnalysisFromThis_Text" xml:space="preserve">
    <value>无法从此位置运行控制流分析</value>
  </data>
  <data name="ConflictingAliasUsingDirective_WasFound_Text" xml:space="preserve">
    <value>找到冲突的别名 using 指令 '{{0}}'，别名将被重命名为 '{0}'</value>
  </data>
  <data name="ExtractMethod_LocalFunctionSelector_EditorAdornment_Text" xml:space="preserve">
    <value>使用**箭头键**选择位置
使用 **Enter** 键确认，使用 **Esc** 键取消</value>
  </data>
  <data name="BecauseThe0CallIsNotAwaitedTheInlined_Text" xml:space="preserve">
    <value>因为{0,调用}未被等待，内联的代码将不再并发执行</value>
  </data>
  <data name="CannonMakeClass_StaticInstanceConstructor_Text" xml:space="preserve">
    <value>无法将类 '{0}' 设为 static: {{0, 使用}}了实例构造函数</value>
  </data>
  <data name="ConvertToLogMethod_ExistingMethodEventIdRequired_ConflictText" xml:space="preserve">
    <value>现有方法 '{0}' 应具有 EventId = {1}，但未指定</value>
  </data>
  <data name="MakeV_irtual_Text" xml:space="preserve">
    <value>设为 virtual(_I)</value>
  </data>
  <data name="ConditionalInvocationOfExtensionMethod_Text" xml:space="preserve">
    <value>扩展方法的{0,条件调用}无法重写为 static 方法调用</value>
  </data>
  <data name="CannotReplaceNameofArgumentWithArgument_Text" xml:space="preserve">
    <value>无法将 'nameof()' 实参替换为实参表达式</value>
  </data>
  <data name="CannotInlineUsageUnder0NameofOperator_Text" xml:space="preserve">
    <value>无法在 {0, nameof} 运算符下内联用法</value>
  </data>
  <data name="SourceFunctionCannotReference__Text" xml:space="preserve">
    <value>源函数不能引用 {0}</value>
  </data>
  <data name="TransformParameters_Conflict_CannotCreateVariableOfType_Text" xml:space="preserve">
    <value>无法在调用点为形参 '{1}' 声明 '{0}' 类型的变量</value>
  </data>
  <data name="SetterWillBeAddedFor___Text" xml:space="preserve">
    <value>将为{0} '{{0}}' 添加 setter</value>
  </data>
  <data name="ConvertToGeneratedMethod_CreateClassPart_Text" xml:space="preserve">
    <value>将创建的方法移动到 '{0}' 文件中的单独部分</value>
  </data>
  <data name="CannotAccessParameterType_InInstance_Text" xml:space="preserve">
    <value>无法访问实例类型中的形参类型 {0}</value>
  </data>
  <data name="Name_Column_Text" xml:space="preserve">
    <value>名称</value>
  </data>
  <data name="UsagesOfLocalFunction0_WillBecomeInvalid_Text" xml:space="preserve">
    <value>局部函数 '{{0, {0}}}' 的用法将失效，因为它的作用域将在调用点被更改</value>
  </data>
  <data name="_CannotBePlacedInTheInterface_Text" xml:space="preserve">
    <value>{0}不能被置于接口中</value>
  </data>
  <data name="Before__Text" xml:space="preserve">
    <value>在{0}之前</value>
  </data>
  <data name="ExtractedCodeCannotReference_ForRecursive_Text" xml:space="preserve">
    <value>提取的代码不能为递归调用引用 {0}</value>
  </data>
  <data name="NewFileWillBeCreated_Text" xml:space="preserve">
    <value>将创建新文件</value>
  </data>
  <data name="TheNameWillBeCoercedDueToAConflictWith_Text" xml:space="preserve">
    <value>名称将被强制转换，因为与另一个元素冲突</value>
  </data>
  <data name="DefaultParameterValueIsUsed__Text" xml:space="preserve">
    <value>使用了默认形参值({0})</value>
  </data>
  <data name="ConvertToGlobalUsing_RemovingUsingDirectives_Text" xml:space="preserve">
    <value>正在移除 using 指令</value>
  </data>
  <data name="AfterTopLevelStatements_Text" xml:space="preserve">
    <value>在顶层语句之后</value>
  </data>
  <data name="None_Text" xml:space="preserve">
    <value>&lt;无&gt;</value>
  </data>
  <data name="TheExtractedCodeCannotReference__Text" xml:space="preserve">
    <value>提取的代码不能引用 {0}</value>
  </data>
  <data name="RefactorGlobalUsingsGroup_Text" xml:space="preserve">
    <value>global using</value>
  </data>
  <data name="RemovingDeconstructionComponentWillBreakComponent_Text" xml:space="preserve">
    <value>移除析构组件将破坏组件{0, 变量}的用法</value>
  </data>
  <data name="ProcessTupleTypeComponent_Text" xml:space="preserve">
    <value>处理元组类型组件</value>
  </data>
  <data name="ExtractMethod_PositionSelectorTooltip" xml:space="preserve">
    <value>使用**箭头键**或 **Home**/**End** 选择位置
使用 **Enter** 键确认
使用 **Esc** 键取消</value>
  </data>
  <data name="ConvertToLogMethod_ExistingLoggerPart_Text" xml:space="preserve">
    <value>正在搜索现有记录器方法的目标类型</value>
  </data>
  <data name="ConvertToGlobalUsings_Text" xml:space="preserve">
    <value>将 using 转换为 global</value>
  </data>
  <data name="ConvertToGlobalUsing_SelectedUsings_Text" xml:space="preserve">
    <value>所选 using:</value>
  </data>
  <data name="MakeNullable_Text" xml:space="preserve">
    <value>设为可以为 null</value>
  </data>
  <data name="CreateParameter_InPrimaryConstructor___Text" xml:space="preserve">
    <value>在{1} '{2}' 的主构造函数中创建形参 '{0}'</value>
  </data>
  <data name="CutDeclarations_Of__Text" xml:space="preserve">
    <value>剪切声明({0:N0}/{1:N0})…</value>
  </data>
  <data name="ConvertToLogMethod_Calls_Text" xml:space="preserve">
    <value>转换为日志方法</value>
  </data>
  <data name="ReadUsage_Text" xml:space="preserve">
    <value>读取用法</value>
  </data>
  <data name="PropertyWithFieldKeywordWillBeTransformed_Text" xml:space="preserve">
    <value>带 'field' 关键字的{0, 属性}将被转换为带支持字段的属性</value>
  </data>
  <data name="WriteUsage_Text" xml:space="preserve">
    <value>写入用法</value>
  </data>
  <data name="ConvertToLogMethod_TargetTypeFile_Text" xml:space="preserve">
    <value>目标文件:</value>
  </data>
  <data name="VariableDoesnTHaveInitializer_Text" xml:space="preserve">
    <value>变量没有初始值设定项</value>
  </data>
  <data name="CanTUpdate0_EncapsulatedFieldWillBe_Text" xml:space="preserve">
    <value>无法更新 {{0,{0}}}: 封装的字段将被移除</value>
  </data>
  <data name="Optional__Text" xml:space="preserve">
    <value>&lt;可选&gt; {0}</value>
  </data>
  <data name="UsageWillBeTransformedButTransformation_Text" xml:space="preserve">
    <value>{0, 用法}将被转换，但转换可能会破坏表达式语义</value>
  </data>
  <data name="ConvertToLogMethod_UseLoggerField_Text" xml:space="preserve">
    <value>&lt;使用记录器字段&gt;</value>
  </data>
  <data name="ConvertToGlobalUsingPageDescription_Text" xml:space="preserve">
    <value>并指定新文件名或现有文件名以将 global using 置于</value>
  </data>
  <data name="TheExtractedCodeCannotReferenceName_Text" xml:space="preserve">
    <value>提取的代码不能引用 {0} 的名称</value>
  </data>
  <data name="CannotConstructDelegateParameterTypes_Text" xml:space="preserve">
    <value>无法为{0,用法}构造委托形参类型</value>
  </data>
  <data name="CannotIntroduceVariableForReturnValue_Text" xml:space="preserve">
    <value>不能为返回值引入变量，因为它的类型不能在调用点显式使用</value>
  </data>
  <data name="NewTargetTypePartWillBeCreated_Text" xml:space="preserve">
    <value>将创建目标类的新部分</value>
  </data>
  <data name="MemberRemovalWillIntroduceImplicitProperty_Text" xml:space="preserve">
    <value>成员移除将为派生记录类型的位置形参 {0} 引入隐式属性</value>
  </data>
  <data name="MemberNameInFileName_Text" xml:space="preserve">
    <value>{1} 中的 {0}</value>
  </data>
  <data name="RemovalOfExplicitlyImplemented_Will_Text" xml:space="preserve">
    <value>移除显式实现的{0}将改为引入隐式成员</value>
  </data>
  <data name="Usage_Text" xml:space="preserve">
    <value>用法</value>
  </data>
  <data name="CannotUseThrowExpressionInTarget0Context_Text" xml:space="preserve">
    <value>无法在目标{0, 上下文}中使用 throw 表达式</value>
  </data>
  <data name="SelectScope_Text" xml:space="preserve">
    <value>选择作用域 </value>
  </data>
  <data name="ConvertToGlobalUsing_FindingUsingDirectivesToRemove_Text" xml:space="preserve">
    <value>正在查找要移除的 using 指令</value>
  </data>
  <data name="ChangeNullabilityActionText" xml:space="preserve">
    <value>更改为 null 性</value>
  </data>
  <data name="ProcessTupleComponent_Text" xml:space="preserve">
    <value>处理元组组件</value>
  </data>
  <data name="AmbiguousReference_WasFoundWhichCan_Text" xml:space="preserve">
    <value>找到不明确的引用 {0}，不能更新</value>
  </data>
  <data name="ConvertToGlobalUsing_AliasConflict_Text" xml:space="preserve">
    <value>与现有 using 别名 '{0}' 冲突</value>
  </data>
  <data name="Invalid_Text" xml:space="preserve">
    <value>无效</value>
  </data>
  <data name="UnsafeCodeIsNotAllowedInAsyncFunctions_Text" xml:space="preserve">
    <value>异步函数中不允许使用不安全的代码</value>
  </data>
  <data name="CreateDefaultParameter_In___Text" xml:space="preserve">
    <value>在{1} ’{2}’ 中创建默认形参 ’{0}’</value>
  </data>
  <data name="CannotReplaceDeclarationExpressionVariable_Text" xml:space="preserve">
    <value>不能将声明表达式变量 '{0}' 替换为常规变量，因为它的类型不能在调用点显式使用</value>
  </data>
  <data name="Make_static_Text" xml:space="preserve">
    <value>设为 static(_S)</value>
  </data>
  <data name="AtTheBeginningOfTopLevelStatements_Text" xml:space="preserve">
    <value>在顶层语句的开头</value>
  </data>
  <data name="ThereExistsSourceClassObjectCreation_Text" xml:space="preserve">
    <value>在源类之外有一个源类对象创建。不能执行重构。</value>
  </data>
  <data name="SelectAll_Text" xml:space="preserve">
    <value>全选(_A)</value>
  </data>
  <data name="ConvertToLogMethod_Text" xml:space="preserve">
    <value>转换为日志方法</value>
  </data>
  <data name="ExtractMethod_LocalFunctionSelector_EditorAdornment_MoveDownButtonTooltip" xml:space="preserve">
    <value>下移局部函数</value>
  </data>
  <data name="NewAccessorIntroductionInVirtual_Can_Text" xml:space="preserve">
    <value>virtual {0}中的新访问器引入可能会破坏继承者</value>
  </data>
  <data name="Property_HasNotEnoughAccess_Text" xml:space="preserve">
    <value>属性 {0} 没有足够的可访问性级别</value>
  </data>
  <data name="CreatePropertyDeclarationBelowTheCurrent_Text" xml:space="preserve">
    <value>在当前成员下方创建属性声明</value>
  </data>
  <data name="__MightBeImplicitlyUsedByTheDefault_Text" xml:space="preserve">
    <value>{0} '{{0}}' 可能由 'Equals' 和 'GetHashCode' 方法的默认运行时提供的实现隐式使用</value>
  </data>
  <data name="TheExtractedCodeCannotHaveAnyRefOut_Text" xml:space="preserve">
    <value>提取的代码不能有任何 ref/out 形参</value>
  </data>
  <data name="InvalidValue_Text" xml:space="preserve">
    <value>无效值</value>
  </data>
  <data name="NameUsage_Text" xml:space="preserve">
    <value>名称用法</value>
  </data>
  <data name="ConvertToGlobalUsing_StatisticsColumn_Text" xml:space="preserve">
    <value>用法</value>
  </data>
  <data name="SearchInProject_Text" xml:space="preserve">
    <value>在项目中</value>
  </data>
  <data name="ConvertToNonGlobalUsing_Text" xml:space="preserve">
    <value>转换为非 global using</value>
  </data>
  <data name="InstantiationValueIsIgnoredCodeWould_Text" xml:space="preserve">
    <value>{0, 实例化}值被忽略: 替换为实例访问后代码将无法编译</value>
  </data>
  <data name="ExtractMethod_LocalFunctionSelector_EditorAdornment_CancelButtonTooltip" xml:space="preserve">
    <value>取消</value>
  </data>
  <data name="SearchingForUsages_Text" xml:space="preserve">
    <value>正在搜索用法…</value>
  </data>
  <data name="AtTheEndOf__Text" xml:space="preserve">
    <value>在 {0} 的末尾</value>
  </data>
  <data name="ConvertToLogMethod_ArgumentCountMismatchInLogMessage_ConflictText" xml:space="preserve">
    <value>实参数量与此调用的日志消息格式不匹配</value>
  </data>
  <data name="UsageOf_MayBeBrokenMethodCallOver_Can_MutateVariable_Text" xml:space="preserve">
    <value>{0}的用法可能会被破坏: 对{0}的方法调用可能会改变结构，因为它被归类为可变变量</value>
  </data>
  <data name="ExtractMethod_Text" xml:space="preserve">
    <value>提取方法</value>
  </data>
  <data name="ConfigureAwait0CallWillNotBeTransferred_Text" xml:space="preserve">
    <value>'ConfigureAwait()' {0,调用}不会被转移到内联的 await 表达式，它的效果将会丢失</value>
  </data>
  <data name="CreateField_InType__Text" xml:space="preserve">
    <value>在类型 '{1}' 中创建字段 '{0}'</value>
  </data>
  <data name="SearchingScope_Text" xml:space="preserve">
    <value>搜索作用域(_S):</value>
  </data>
  <data name="UsageOf_MayBeBrokenIfStructTypeWill_Text2" xml:space="preserve">
    <value>如果结构类型将被替换为不受约束的泛型类型形参，则{0}的用法可能会被破坏: 访问的表达式应被归类为变量。自动属性访问在每次访问时返回值的临时副本。</value>
  </data>
  <data name="The_ConstantWillBeConvertedToARegular_Text" xml:space="preserve">
    <value>'{0}' 常量将被转换为常规变量</value>
  </data>
  <data name="ConvertToLogMethod_SearchingLogMethodCalls_Text" xml:space="preserve">
    <value>正在搜索记录器方法调用</value>
  </data>
  <data name="CanTOverridePropertyWithAutoProperty_Text" xml:space="preserve">
    <value>由于 private {0}，无法使用自动属性重写属性</value>
  </data>
  <data name="DisableImplicitUsings_Action_Text" xml:space="preserve">
    <value>禁用隐式 using</value>
  </data>
  <data name="NewAccessorIntroductionIsNotAllowed_Text" xml:space="preserve">
    <value>{0}重写中不允许引入新的访问器</value>
  </data>
  <data name="Optional_Text" xml:space="preserve">
    <value>&lt;可选&gt;</value>
  </data>
  <data name="ConvertToLogMethod_Action_Text" xml:space="preserve">
    <value>将记录器扩展方法调用转换为日志方法</value>
  </data>
  <data name="NullPassedAsInstanceParameter_Text" xml:space="preserve">
    <value>{0,Null} 作为实例形参传递</value>
  </data>
  <data name="SearchingGlobalUsingDirectives_Text" xml:space="preserve">
    <value>正在搜索 global using 指令…</value>
  </data>
  <data name="IntroduceSingleVariable__Text" xml:space="preserve">
    <value>引入单个变量({0})</value>
  </data>
  <data name="ConvertingMethodCalls_Text" xml:space="preserve">
    <value>正在转换方法调用</value>
  </data>
  <data name="VariableDoesnTHaveDeclarationsInSource_Text" xml:space="preserve">
    <value>变量在源代码中没有声明</value>
  </data>
  <data name="ReplacementOfTheFieldWithAPropertyWould_Text" xml:space="preserve">
    <value>将字段替换为属性会在 {0} 处引入结构复制</value>
  </data>
  <data name="_NeedsWiderAccess_Text" xml:space="preserve">
    <value>{0}需要更广泛的访问权限</value>
  </data>
  <data name="UnsafeCodeIsNotAllowedInIterators_Text" xml:space="preserve">
    <value>迭代器中不允许使用不安全的代码</value>
  </data>
  <data name="FixCannotBeCreated_Text" xml:space="preserve">
    <value>不能创建修正</value>
  </data>
  <data name="ExtractMethodObject_Text" xml:space="preserve">
    <value>提取方法对象</value>
  </data>
  <data name="TargetFieldNameWasNotSpecified_Text" xml:space="preserve">
    <value>未指定目标字段名称</value>
  </data>
  <data name="ConvertToGeneratedMethod_LocationColumn_Text" xml:space="preserve">
    <value>位置</value>
  </data>
  <data name="ReplaceInitialExpressionOnly_Text" xml:space="preserve">
    <value>仅替换初始表达式</value>
  </data>
  <data name="ConvertToGlobalUsing_StatisticsTooltip_Text" xml:space="preserve">
    <value>在 {0:N0}/{1:N0} 个文件中已导入</value>
  </data>
  <data name="GenericParametersCannotBeUsedIn0Method_Text" xml:space="preserve">
    <value>{0,方法}中不能使用泛型形参</value>
  </data>
  <data name="RemovalOfExplicitPositionalMemberFor_Introduce_Text" xml:space="preserve">
    <value>移除形参 {0} 的显式位置成员将改为引入隐式属性</value>
  </data>
  <data name="OnlyAbstractDeclarationsCanBeMovedTo_Text" xml:space="preserve">
    <value>只能将 abstract 声明移至 {0}</value>
  </data>
  <data name="IntroducedRefTempVariableWillRequire_Text" xml:space="preserve">
    <value>引入的 ref temp 变量将需要初始值设定项</value>
  </data>
  <data name="InstantiationOfTargetClass_WillBeBroken_Text" xml:space="preserve">
    <value>目标类的实例化: {0}将被破坏，因为它将被设为 abstract</value>
  </data>
  <data name="InstantiationCannotBeTransformedInto_Text" xml:space="preserve">
    <value>{{0, 实例化}}无法转换为工厂方法: 无法将属性 '{0}' 的 'init' 访问器更改为 'set' 访问器</value>
  </data>
  <data name="ForLocalFunctionPlacement_Text" xml:space="preserve">
    <value> 用于局部函数放置</value>
  </data>
  <data name="ConvertToGlobalUsing_AddingGlobalUsingDirective_Text" xml:space="preserve">
    <value>正在添加 global using 指令</value>
  </data>
  <data name="BeforeTopLevelStatements_Text" xml:space="preserve">
    <value>在顶层语句之前</value>
  </data>
  <data name="ConvertToGlobalUsings_Action_Text" xml:space="preserve">
    <value>将 using 转换为 global…</value>
  </data>
  <data name="InvalidFieldName_Text" xml:space="preserve">
    <value>fieldName 无效</value>
  </data>
  <data name="Modifier_Column_Text" xml:space="preserve">
    <value>修饰符</value>
  </data>
  <data name="UnableToAddSetAccessorTo__Text" xml:space="preserve">
    <value>无法将 'set' 访问器添加到 {0}</value>
  </data>
  <data name="BackingFieldIsUsedFromThe1Structure_Text" xml:space="preserve">
    <value>{0, 支持字段}从{1,结构构造函数}使用。将添加对默认构造函数的调用。</value>
  </data>
  <data name="UnableToRemovePrimaryConstructorOf__Text" xml:space="preserve">
    <value>无法移除{0}的主构造函数</value>
  </data>
  <data name="UpdatingReferences_Text" xml:space="preserve">
    <value>正在更新引用…</value>
  </data>
  <data name="ParameterOfMethodCanTHaveOutModifier_Text" xml:space="preserve">
    <value>{0,方法的形参}不能有 [out] 修饰符</value>
  </data>
  <data name="ConvertToLogMethod_ChooseLogMethodCalls_Text" xml:space="preserve">
    <value>选择要转换的记录器方法调用:</value>
  </data>
  <data name="ConvertToLogMethod_PageTitle" xml:space="preserve">
    <value>选择要替换为 [LoggerMessage] 生成的方法调用的记录器方法调用</value>
  </data>
  <data name="UnableToAddGetAccessorTo__Text" xml:space="preserve">
    <value>无法将 'get' 访问器添加到 {0}</value>
  </data>
  <data name="CapturedField_NameWillBeReplacedWith_Text" xml:space="preserve">
    <value>捕获的字段{0}名称将被替换为属性名称</value>
  </data>
  <data name="InstantiationCannotBeTransformedInto_Object_Text" xml:space="preserve">
    <value>{0, 实例化}无法转换为工厂方法: 无法提取对象初始值设定项</value>
  </data>
  <data name="TheExtractedCodeWillReferenceNewElement_Text" xml:space="preserve">
    <value>提取的代码将引用新元素而不是 {0}</value>
  </data>
  <data name="ConflictingDeclaration_WasFoundAlias_Text" xml:space="preserve">
    <value>找到冲突的声明 '{{0}}'，别名将被重命名为 '{0}'</value>
  </data>
  <data name="ConvertToGeneratedMethod_InvocationColumn_Text" xml:space="preserve">
    <value>新方法名称</value>
  </data>
  <data name="ParameterOfMethodCanTHaveRefOrOutModifiers_Text" xml:space="preserve">
    <value>{0,方法的形参}不能有 [ref] 或 [out] 修饰符</value>
  </data>
  <data name="InvalidMethodName_Text" xml:space="preserve">
    <value>方法名称无效</value>
  </data>
  <data name="RemovalOfExplicitPositionalMemberFor_Rebind_Text" xml:space="preserve">
    <value>移除形参 {0} 的显式位置成员会将其重新绑定到基类型的成员</value>
  </data>
  <data name="ExtractLocalFunction_Text" xml:space="preserve">
    <value>提取局部函数</value>
  </data>
  <data name="InitOnlyProperty_WillBecomeMutable_Text" xml:space="preserve">
    <value>仅初始化属性 {0} 将变为可变</value>
  </data>
  <data name="_WillBeMovedToTargetScopeAsItIsUsed_Text" xml:space="preserve">
    <value>{0} 将被移至目标作用域，因为它同时用于原始代码和提取的代码</value>
  </data>
  <data name="MemberNameExists_Text" xml:space="preserve">
    <value>将使用现有成员</value>
  </data>
</root>
