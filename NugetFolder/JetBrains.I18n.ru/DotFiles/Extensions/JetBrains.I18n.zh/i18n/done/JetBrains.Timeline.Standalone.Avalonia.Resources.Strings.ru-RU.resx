<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="HelpToolTipGcType" xml:space="preserve">
    <value>
此筛选器显示应用程序执行特定类型的垃圾回收(GC)的时间间隔:
* **阻塞**&lt;br&gt;执行阻塞垃圾回收的时间间隔。除触发回收的线程外，所有其他线程都被挂起。
* **后台**&lt;br&gt;执行后台垃圾回收的时间间隔。此事件只能发生在**垃圾回收**线程上。
* **后台期间阻塞**&lt;br&gt;在后台垃圾回收期间执行阻塞垃圾回收的时间间隔。通常，这意味着阻塞垃圾回收由后台**垃圾回收**线程触发。

&lt;p&gt;如果您看到了明显的阻塞垃圾回收时间，最好将**事件**筛选器切换为 **.NET 内存分配**，并确定分配的内存量最多的线程。它们很可能就是触发垃圾回收的线程。
        </value>
  </data>
  <data name="HelpToolTipFileIoName" xml:space="preserve">
    <value>
此筛选器显示特定文件之间的文件 I/O 操作时间分布。
&lt;p&gt;在您选择一个文件后，筛选器将仅保留线程处理所选文件的时间间隔。
        </value>
  </data>
  <data name="HelpToolTipExceptionMessage" xml:space="preserve">
    <value>
此筛选器显示所引发异常的消息。
&lt;p&gt;在您选择一条消息后，筛选器将仅保留引发具有所选消息的异常的点事件。
        </value>
  </data>
  <data name="HelpToolTipIntervalFilters" xml:space="preserve">
    <value>
这是一组表示特定间隔事件的单独的筛选器 – 可能在线程内重叠的事件。如果应用两个或多个具有重叠间隔的筛选器，产生的时间间隔将是其交集。
* **UI 冻结**&lt;br&gt;用户界面未响应的时间间隔。更具体地说，它们是窗口消息的泵送时间不超过 200 ms，或处理特定消息的时间超过 200 ms 的时间间隔。此事件只能发生在 UI 线程上。
* **传入 HTTP 请求**&lt;br&gt;从 Web 服务器接收 HTTP 请求到发送响应的时间间隔。该筛选器仅应用于服务器端，尤其是对于传入 HTTP 请求。
* **任务**&lt;br&gt;执行通过任务 API (例如，Task.StartNew 或 Task.ContinueWith)启动的任务的时间间隔。如果使用 async/await 运行任务，筛选器将仅保留 'Task execution' 节点后面的代码: async 方法本身(包括继续码)不在筛选器的作用域内。
        </value>
  </data>
  <data name="HelpToolTipCpuCore" xml:space="preserve">
    <value>
此筛选器显示逻辑 CPU 之间的工作分布。
&lt;p&gt;在您选择一个 CPU 后，筛选器将仅保留在所选逻辑 CPU 上运行线程的时间间隔。
        </value>
  </data>
  <data name="HelpToolTipComparison" xml:space="preserve">
    <value>
此模式可以让您比较两个不同的快照，例如，代码优化“前”和优化“后”的快照。dotTrace 显示第一个快照和第二个快照之间的函数执行时间差异。负值(性能改进)以**%{color:{1}}绿色%**显示。正值(性能下降)以**%{color:{2}}红色%**显示。
&lt;p&gt;如果某个函数在第一个快照中存在，但在第二个快照中不存在，其整个执行时间显示为负值(**%{color:{1}}绿色%**)。如果某个函数在第一个快照中不存在，但出现在第二个快照中，其时间显示为正值(**%{color:{2}}红色%**)。
&lt;p&gt;如果您在其中一个快照中的作用域是特定调用树节点，请对第二个快照执行相同的操作。否则，生成的比较数据将很难理解。
        </value>
  </data>
  <data name="HelpToolTipGcDepth" xml:space="preserve">
    <value>
此筛选器显示应用程序执行特定生成的垃圾回收(GC)的时间间隔。
        </value>
  </data>
  <data name="HelpToolTipGcReason" xml:space="preserve">
    <value>
此筛选器按切换垃圾回收的原因显示垃圾回收的分布。
&lt;p&gt;在您选择一个原因后，筛选器将仅保留由于所选原因切换垃圾回收的时间间隔。
        </value>
  </data>
  <data name="HelpToolTipWaitingActivatingThread" xml:space="preserve">
    <value>
此筛选器显示解锁了所选线程的线程或进程。
&lt;p&gt;在您选择一个激活线程或进程后，筛选器将仅保留线程在被所选激活线程或进程解锁之前等待的时间间隔。
&lt;p&gt;此筛选器用于确定哪个线程阻塞了某个线程。
        </value>
  </data>
  <data name="HelpToolTipThreadStates" xml:space="preserve">
    <value>
筛选器会显示所选线程在某种状态下所花费的时间间隔:
* **正在运行**&lt;br&gt;线程正在 CPU 上执行。
* **等待**&lt;br&gt;线程未执行，因为它正在等待从另一个线程发送的资源或通知。

&lt;p&gt;例如，要在线程等待其他线程时分析时间间隔，在**线程**图表中选择该线程，在**线程状态**筛选器中选择**等待**状态。
        </value>
  </data>
  <data name="HelpToolTipThreads" xml:space="preserve">
    <value>
**线程**图表能够直观显示线程活动。对于每个线程，图表显示了线程状态时间线以及以下信息:
* **ID**&lt;br&gt;线程 ID。
* **名称**&lt;br&gt;线程名称或线程类型(如果线程没有名称)。
* **ms/MB/事件**&lt;br&gt;筛选的时间/分配的内存/事件编号。例如，如果选择了**时间**主题并且未应用其他筛选器，它将是整个线程生命周期。例如，如果在**线程状态**筛选器中选择了**等待**，此时间将为所有**等待**时间间隔的总和。
* **%**&lt;br&gt;筛选的时间/分配的内存/事件编号相对于所有选择的时间间隔/分配事件/异常事件的百分比。

&lt;p&gt;使用图表:
* *点击线程* - 按线程应用筛选器。例如，在选择线程后，**调用树**将仅显示指定线程的调用执行路径。&lt;br&gt;使用**可见线程**按钮可按名称或类型显示/隐藏线程。
* *按住鼠标左键在线程上拖动鼠标* - 选择时间范围和线程。这将按所选时间范围和线程自动应用筛选器。
* ***Ctrl*** *+ 鼠标滚轮或* ***Ctrl*** * + 拖动鼠标* - 放大/缩小图表。这也将按可见时间范围自动应用筛选器。
* *按住鼠标右键拖动鼠标* - 平移图表。
* *右键点击线程名称* - 打开上下文菜单。使用菜单按特定条件选择/隐藏线程。
* *右键点击线程* - 打开上下文菜单。使用菜单缩放所选时间间隔或清除时间选择。

&lt;p&gt;此图表用于选择有兴趣分析的线程和时间间隔。
        </value>
  </data>
  <data name="HelpToolTipTopMethods" xml:space="preserve">
    <value>
**热点**显示在筛选的时间间隔内执行的方法列表。当未在**事件**筛选器中选择任何事件时，方法可以按自己的时间(不包括子调用)或按总时间(包括子调用)排序。当打开工具栏上的**隐藏系统函数**选项时，每个系统调用的自身时间会加入到最近的调用用户方法的自身时间中。
&lt;p&gt;将**热点**与其他筛选器结合使用时，可以确定某个条件下的“顶层”方法。例如，要查看执行文件操作的方法，在**事件**筛选器中选择**文件操作**。
&lt;p&gt;使用**热点**:

* *双击某个方法或在某个方法上按 * ***Enter*** *键* - 在源代码中导航到该方法。
* ***Ctrl+Enter*** - 合并并打开**调用树**中的所有方法匹配项。该方法成为包含所有实例的调用子树的根节点。它还会根据方法实例及其子树应用筛选器。
* *右键点击方法* - 打开上下文菜单。该菜单包含上面列出的操作。
        </value>
  </data>
  <data name="HelpToolTipDebugOutputString" xml:space="preserve">
    <value>
此筛选器显示发送给调试输出的字符串消息。
&lt;p&gt;在您选择一个字符串后，筛选器将仅保留发送具有所选内容的消息的时间间隔。
        </value>
  </data>
  <data name="HelpToolTipProcessOverview" xml:space="preserve">
    <value>
**进程概览**图表能够直观显示应用程序活动和事件:
* **CPU 利用率**&lt;br&gt;CPU 负载百分比。y 轴表示系统中逻辑 CPU 核心数。
* **阻塞垃圾回收**&lt;br&gt;发生阻塞垃圾回收的时间间隔。
* **UI 冻结**&lt;br&gt;用户界面未响应的时间间隔。更具体地说，它们是窗口消息的泵送时间不超过 200 ms，或处理特定消息的时间超过 200 ms 的时间间隔。此事件只能发生在 UI 线程上。

&lt;p&gt;使用图表:
* *按住鼠标左键拖动鼠标* - 选择时间范围。这将按所选时间范围自动应用筛选器。。例如，在选择时间范围后，**调用堆栈**窗口将仅显示在此间隔内进行的调用。
* *鼠标滚轮或* ***Ctrl*** *+ 拖动鼠标* - 放大/缩小图表。这也将按可见时间范围自动应用筛选器。
* *点击 UI 冻结* - 选择发生 UI 冻结的时间范围。这将按所选时间范围和 UI 线程自动应用筛选器。
* *按住鼠标右键拖动鼠标* - 平移图表。
* *右键点击图表* - 打开上下文菜单。使用菜单缩放到所选时间间隔或清除时间选择。

&lt;p&gt;此图表用于确定和选择有兴趣分析的线程和时间间隔。
        </value>
  </data>
  <data name="HelpToolTipBlockingGc" xml:space="preserve">
    <value>
此筛选器显示所选线程被或未被垃圾回收(GC)阻塞的总时间。
**阻塞垃圾回收**&lt;br&gt;执行阻塞垃圾回收。除触发回收的线程外，所有其他线程都被挂起。
**排除阻塞垃圾回收**&lt;br&gt;不执行阻塞垃圾回收。应用程序正在运行。
**未选择**&lt;br&gt;未应用筛选器。

&lt;p&gt;在您选择某个值后，筛选器将仅保留执行或未执行垃圾回收的时间间隔。
&lt;p&gt;此筛选器用于分析垃圾回收。例如，如果您看到了明显的阻塞垃圾回收时间，最好将**分析主体**筛选器切换为 **.NET 内存分配**，并确定分配的内存量最多的线程。它们很可能就是触发垃圾回收的线程。
        </value>
  </data>
  <data name="HelpToolTipSubsystems" xml:space="preserve">
    <value>
这是一组补充筛选器，可以让您快速评估所选间隔内的时间在各个组件中如何分布:
* **用户代码**&lt;br&gt;仅执行用户代码的时间间隔。这包括用户方法和从用户方法中调用的系统方法。不包含用户代码的调用堆栈会被排除在外。
* **系统/原生代码**&lt;br&gt;仅执行系统/原生代码的时间间隔。
* **正在等待 CPU**&lt;br&gt;所选线程准备在下一个可用 CPU 核心上运行的时间间隔。等待 CPU 的间隔较长意味着线程饥饿和 CPU 过载。
* **锁争用**&lt;br&gt;所选线程等待对某个对象进行独占式访问的时间间隔。这仅包括 Monitor.Enter 方法或 lock 语句锁定的对象。
* **垃圾回收等待**&lt;br&gt;所选线程等待阻塞垃圾回收完成的时间间隔。
* **文件 I/O**&lt;br&gt;应用程序执行文件操作的时间间隔。这包括 ETW 文件操作事件以及从 System.IO 和其他系统文件 I/O 命名空间进行的所有方法调用。
* **WPF、WinForms、Wait、Sleep、Linq 等**&lt;br&gt;这些子系统汇总了在某个命名空间或程序集中进行的所有调用的时间。
        </value>
  </data>
  <data name="HelpToolTipHttpRequestVerb" xml:space="preserve">
    <value>
此筛选器显示使用特定 HTTP 方法的请求之间的时间分布。
&lt;p&gt;在您选择一个方法后，筛选器将仅保留处理使用所选方法的 HTTP 请求的时间间隔。
        </value>
  </data>
  <data name="HelpToolTipSqlCommandText" xml:space="preserve">
    <value>
此筛选器显示所选线程与 SQL Server 通信的总时间: 打开和关闭连接，或等待特定 SQL 查询结果。
&lt;p&gt;在您选择一个命令后，筛选器将仅保留执行所选命令的时间间隔。
        </value>
  </data>
  <data name="HelpToolTipCallTree" xml:space="preserve">
    <value>
**调用树**显示方法执行路径。树中的每个方法节点表示由某个线程执行的顶层方法。方法节点会列出它调用的方法以及底层调用子树的执行时间。
&lt;br&gt;如果**调用树**专注于特定方法，您可以将视图切换到**反向跟踪**。在这种模式下，调用树会反转，您可以跟踪执行路径，直至堆栈中的第一个方法。
&lt;p&gt;使用**调用树**:

* *双击某个方法或在某个方法上按* ***Enter*** *键* - 在源代码中导航到该方法。
* *在某个方法上按 ***Ctrl + Enter 键*** - 作用域为**调用树**中的当前方法实例。该方法成为根节点。它还会根据此实例及其子树应用筛选器。
* *在某个方法上按 ***Ctrl + Shift + Enter 键*** - 在**调用树**中合并并显示所有方法匹配项。该方法成为包含所有实例的调用子树的根节点。它还会根据方法实例及其子树应用筛选器。
* *右键点击方法* - 打开上下文菜单。该菜单包含上面列出的所有操作。

&lt;p&gt;图例:
&lt;p&gt;![VectorImage](Xaml/Assets/Svg/Fold{0}.svg) 可以在一个节点中折叠的系统调用链。
&lt;p&gt;![VectorImage](Xaml/Assets/Svg/Unfold{0}.svg) 折叠的系统调用链。
        </value>
  </data>
  <data name="HelpToolTipExceptionType" xml:space="preserve">
    <value>
此筛选器显示引发的异常类型。
&lt;p&gt;在您选择一个类型后，筛选器将仅保留引发所选类型的异常的点事件。例如，**调用堆栈**窗口中的**方法**将显示引发此类型异常的方法列表。
        </value>
  </data>
  <data name="HelpToolTipTopMethodsUsingParagraph" xml:space="preserve">
    <value>
使用**方法**:
        </value>
  </data>
  <data name="HelpToolTipHttpRequestUrl" xml:space="preserve">
    <value>
此筛选器显示特定 URL 的 HTTP 请求之间的时间分布。
&lt;p&gt;在您选择一个 URL 后，筛选器将仅保留处理所选 URL 的 HTTP 请求的时间间隔。
        </value>
  </data>
  <data name="HelpToolTipSqlConnectionString" xml:space="preserve">
    <value>
此筛选器显示具有特定连接形参的 SQL 会话的总时间。
&lt;p&gt;在您选择一个连接字符串后，筛选器将仅保留发生相应 SQL 会话的时间间隔。
        </value>
  </data>
  <data name="HelpToolTipAllocationType" xml:space="preserve">
    <value>
此筛选器显示分配的内存在某一类型的对象之间的分布。
&lt;p&gt;请注意，显示的分布为近似值，可能与实际值不同: 仅在分配的内存总大小超过 100 KB 后，才会触发 ETW 分配事件。这意味着，列表会显示最后一个在 100 KB 块中的对象(导致超过 100 KB 阈值的对象)的类型。
        </value>
  </data>
  <data name="HelpToolTipAllocationHeap" xml:space="preserve">
    <value>
此筛选器显示分配的内存在小对象堆和大对象堆(SOH 与 LOH)之间的分布。&lt;br&gt;
例如，如果要确定在 LOH 中分配内存的方法，请在**事件**筛选器中选择 **.NET 内存分配**，在 **.NET 内存分配: 堆**中选择**大对象堆**。这些方法将显示在**调用堆栈**窗口的**热点**中。
        </value>
  </data>
  <data name="HelpToolTipWaitingReason" xml:space="preserve">
    <value>此筛选器显示阻止所选线程的原因。
&lt;p&gt;在您选择一个原因后，筛选器将仅保留线程由于所选原因而等待的时间间隔。
&lt;p&gt;最好将**等待: 原因**子筛选器与**等待: 激活线程**一起使用，因为这会让您可以确定“Thread#X”阻塞“Thread#Y”的原因。例如，**UserRequest** 原因意味着线程由于锁定争用而被阻塞。
        </value>
  </data>
  <data name="HelpToolTipBlockingGcReason" xml:space="preserve">
    <value>
此筛选器按切换垃圾回收的原因显示阻塞垃圾回收时间的分布。
&lt;p&gt;在您选择一个原因后，筛选器将仅保留由于所选原因切换垃圾回收的时间间隔。
        </value>
  </data>
  <data name="HelpToolTipFileIoDirection" xml:space="preserve">
    <value>
此筛选器显示读取和写入操作的时间分布。
&lt;p&gt;在您选择一个文件后，筛选器将仅保留线程执行所选文件操作的时间间隔。
        </value>
  </data>
  <data name="HelpToolTipAnalysisSubject" xml:space="preserve">
    <value>
这是一组表示特定应用程序事件的单独的筛选器:
* **未选择**&lt;br&gt;所有收集的时间线数据。请使用其他筛选器来缩小分析范围。
* **.NET 内存分配**&lt;br&gt;应用程序将内存分配给托管堆的点事件。&lt;br&gt;请注意，只有在分配的总内存大小超过 100 KB 时才会引发分配点事件。例如，如果线程在分析期间分配五个 50 KB 内存块，dotTrace 将仅检测两个 100 KB 的分配。
* **原生分配**&lt;br&gt;应用程序将内存分配给原生(非托管)堆的点事件。与托管分配不同，无论分配的内存大小如何，每次进行分配时都会引发原生内存分配事件。&lt;br&gt;请注意，dotTrace 目前仅显示在获取快照时未取消分配的原生对象分配。
* **异常**&lt;br&gt;应用程序引发异常的点事件。
* **调试输出**&lt;br&gt;应用程序写入调试输出的点事件。
* **垃圾回收**&lt;br&gt;进行垃圾回收的时间间隔。例如，用于确定过度垃圾回收的原因。
* **JIT 编译**&lt;br&gt;进行即时编译的时间间隔。例如，用于评估 JIT 编译时间。
* **文件操作**&lt;br&gt;进行文件输入/输出操作的时间间隔。这包括使用物理磁盘或系统缓存进行的读写操作。例如，用于确定导致文件过度输入/输出的方法。
* **SQL 查询**&lt;br&gt;与 SQL Server 进行通信的时间间隔。请注意，所有测量均在客户端进行 – dotTrace 会测量客户端发送请求与接收响应所间隔的时间。例如，用于确定最慢的 SQL 查询。
        </value>
  </data>
</root>
