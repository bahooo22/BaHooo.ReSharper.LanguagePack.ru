<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
<data name="AccessRightsFor0MemberWillBeExtended_Text" xml:space="preserve">
  <value>Права доступа для {0,члена} будут расширены</value>
</data>
<data name="MethodDeclarationHasEventSpecification_Text" xml:space="preserve">
  <value>Объявление {0,метода} содержит спецификацию события, которая будет удалена.</value>
</data>
<data name="VariableHasUnsupportedUsageKind_Text" xml:space="preserve">
  <value>Переменная имеет неподдерживаемый тип использования</value>
</data>
<data name="UsageOf_WillBeBrokenStructAccessShould_Text" xml:space="preserve">
  <value>Использование {0} будет прервано, доступ к структуре должен быть классифицирован как переменная для изменения поля структуры или установки свойства</value>
</data>
<data name="SignatureChangeConflictsWithSignature_Text" xml:space="preserve">
  <value>Изменение сигнатуры конфликтует с сигнатурой {0,делегата}</value>
</data>
<data name="ReturnedValueOf0CallIsNotUsed_Text" xml:space="preserve">
  <value>Возвращаемое значение {0,вызова} не используется</value>
</data>
<data name="AssignedValueHasNoReachableUsages_Text" xml:space="preserve">
  <value>Присвоенное значение не имеет достижимых использований</value>
</data>
<data name="AllParametersOf_ShouldHaveByValModifier_Text" xml:space="preserve">
  <value>Все параметры {0} должны иметь модификатор ByVal</value>
</data>
<data name="Attribute_OfTheFieldDeclarationWill_Text" xml:space="preserve">
  <value>Атрибут [{0}] объявления поля будет применен к автоматическому свойству</value>
</data>
<data name="MaKeShared_Text" xml:space="preserve">
  <value>Сделать общим (&amp;K)</value>
</data>
<data name="_IsAMethodGroup_Text" xml:space="preserve">
  <value>{0} является группой методов</value>
</data>
<data name="MaKeMethodNonShared_Text" xml:space="preserve">
  <value>Сделать метод необщим (&amp;K)</value>
</data>
<data name="IntroDuceVariableForSubstring_Text" xml:space="preserve">
  <value>Ввести переменную для подстроки (&amp;D)</value>
</data>
<data name="FieldWillBeEncapsulated_Text" xml:space="preserve">
  <value>{0,поле} будет инкапсулировано</value>
</data>
<data name="_IsNotDeclaredAbstractBodyWillBeRemoved_Text" xml:space="preserve">
  <value>{0} не объявлен как abstract. Тело будет удалено.</value>
</data>
<data name="_HasBaseClassUsage_Text" xml:space="preserve">
  <value>{0} имеет использование базового класса</value>
</data>
<data name="BackingField_AccessBecamePolymorphic_Text" xml:space="preserve">
  <value>Доступ к резервному полю {0} стал полиморфным</value>
</data>
<data name="CallerCannotBeNull_Text" xml:space="preserve">
  <value>{0, вызывающий} не может быть null</value>
</data>
<data name="Member_HasNotEnoughAccess_Text" xml:space="preserve">
  <value>Член {0} имеет недостаточный уровень доступа</value>
</data>
<data name="CannotChangeSignatureOf__Text" xml:space="preserve">
  <value>Не удается изменить сигнатуру {0}</value>
</data>
<data name="CannotIntroduceVariableFromTheSelected_Text" xml:space="preserve">
  <value>Не удается ввести переменную из выбранной части строки</value>
</data>
<data name="SystemRuntimeCompilerServicesExtension_Text" xml:space="preserve">
  <value>Атрибут System.Runtime.CompilerServices.Extension не указан.</value>
</data>
<data name="TypeSystemFuncIsNotAvailable_Text" xml:space="preserve">
  <value>Тип 'System.Func' недоступен</value>
</data>
<data name="ThereIsAmbiguousConstructorReference_Text" xml:space="preserve">
  <value>Существует неоднозначная ссылка на конструктор. Будет создана каждая версия конструктора.</value>
</data>
<data name="FieldInitializerWillNotBeMovedFor__Text" xml:space="preserve">
  <value>Инициализатор поля не будет перемещен для {0}</value>
</data>
<data name="_IsUsedWithUnpresentableType_Text" xml:space="preserve">
  <value>{0} используется с непредставимым типом</value>
</data>
<data name="Property_OverridingBaseClassProperty_Text" xml:space="preserve">
  <value>Свойство {0} переопределяет свойство базового класса</value>
</data>
<data name="VariableHasWriteUsages_Text" xml:space="preserve">
  <value>Переменная имеет использования на запись</value>
</data>
<data name="Project_HasDefaultNamespace_WhichDoes_Text" xml:space="preserve">
  <value>Проект {0} имеет пространство имен по умолчанию '{1}', которое не соответствует новому имени пространства имен</value>
</data>
<data name="_HasHandlesClause_Text" xml:space="preserve">
  <value>{0} имеет предложение Handles</value>
</data>
<data name="ConflictWithModifiersListFoundIn__Text" xml:space="preserve">
  <value>Обнаружен конфликт со списком модификаторов в {0}</value>
</data>
<data name="CannotRunControlFlowAnalysisFromThis_Text" xml:space="preserve">
  <value>Не удается выполнить анализ потока управления из этого места</value>
</data>
<data name="OperationOrderMayChange_Text" xml:space="preserve">
  <value>Порядок операций может измениться в {0}</value>
</data>
<data name="CannotAccessParameterType_InInstance_Text" xml:space="preserve">
  <value>Не удается получить доступ к типу параметра {0} в типе экземпляра</value>
</data>
<data name="OverridingOfEvent_IsNotAllowedVB_Text" xml:space="preserve">
  <value>Переопределение события {0} не допускается в Visual Basic</value>
</data>
<data name="UnableToAddWriteAccessorTo__Text" xml:space="preserve">
  <value>Не удается добавить метод доступа на запись к {0}</value>
</data>
<data name="VariableDoesnTHaveInitializer_Text" xml:space="preserve">
  <value>Переменная не имеет инициализатора</value>
</data>
<data name="CannotChangeWriteabilityOfPolymorphic_Text" xml:space="preserve">
  <value>Не удается изменить возможность записи полиморфного {0}</value>
</data>
<data name="ReadonlyModifierOfProperty_WillBeRemoved_Text" xml:space="preserve">
  <value>Модификатор readonly свойства '{0}' будет удален</value>
</data>
<data name="UnableToUpdateCustomAsyncDeclaration_Text" xml:space="preserve">
  <value>Не удается обновить асинхронный метод с типом возвращаемого значения, не являющимся задачей</value>
</data>
<data name="ThereExistsSourceClassObjectCreation_Text" xml:space="preserve">
  <value>Существует создание объекта исходного класса вне исходного класса. Невозможно выполнить рефакторинг.</value>
</data>
<data name="Property_HasNotEnoughAccess_Text" xml:space="preserve">
  <value>Свойство '{0}' имеет недостаточный уровень доступа</value>
</data>
<data name="LastArgumentOfMethod_ShouldnTBeOptional_Text" xml:space="preserve">
  <value>Для преобразования в свойство записи последний аргумент метода {0} не должен быть необязательным</value>
</data>
<data name="NullPassedAsInstanceParameter_Text" xml:space="preserve">
  <value>{0, Null} передан в качестве параметра экземпляра</value>
</data>
<data name="VariableDoesnTHaveDeclarationsInSource_Text" xml:space="preserve">
  <value>Переменная не имеет объявлений в исходном коде</value>
</data>
<data name="_NeedsWiderAccess_Text" xml:space="preserve">
  <value>{0} требует более широкого доступа</value>
</data>
<data name="OnlyAbstractDeclarationsCanBeMovedTo_Text" xml:space="preserve">
  <value>Только abstract объявления могут быть перемещены в {0}</value>
</data>
<data name="InstantiationOfTargetClass_WillBeBroken_Text" xml:space="preserve">
  <value>Создание экземпляра целевого класса: {0} будет нарушено, так как он будет сделан abstract</value>
</data>
<data name="InstantiationCannotBeTransformedInto_Text" xml:space="preserve">
  <value>{0, создание экземпляра} не может быть преобразовано в фабричный метод: не удается извлечь преобразующий инициализатор</value>
</data>
<data name="BackingFieldIsUsedFromThe1Structure_Text" xml:space="preserve">
  <value>{0, резервное поле} используется из {1, конструктора структуры}. Будет добавлен вызов конструктора по умолчанию.</value>
</data>
<data name="UsageCannotBeProcessedBecauseNotAll_Text" xml:space="preserve">
  <value>{0, использование} не может быть обработано, так как переданы не все аргументы</value>
</data>
<data name="ConditionalAccessWillBeDiscarded_Text" xml:space="preserve">
  <value>Условный доступ будет отброшен</value>
</data>
<data name="ConvertDefaultPropertyToMethodS_Text" xml:space="preserve">
  <value>Преобразовать свойство по умолчанию в метод</value>
</data>
</root>
