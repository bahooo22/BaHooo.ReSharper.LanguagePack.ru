import os
import xml.etree.ElementTree as ET
import argostranslate.translate as tr
from tqdm import tqdm
import argparse
from concurrent.futures import ProcessPoolExecutor
import datetime

# Глобальный кэш переводов
cache = {}

def cached_translate(translator, text):
    """Перевод строки с кэшированием."""
    if text in cache:
        return cache[text]
    result = translator.translate(text)
    cache[text] = result
    return result

def translate_file(src_path, en_path, ru_new_path, log_mode, zh_en, en_ru, resume, log_file):
    if resume and os.path.exists(ru_new_path):
        msg = f"[SKIP] {os.path.basename(src_path)} уже обработан"
        print(msg)
        if log_file: log_file.write(msg + "\n")
        return

    # Один раз парсим XML
    tree = ET.parse(src_path)
    root = tree.getroot()
    values = root.findall("data")

    logs = []  # собираем логи для одного файла

    # zh→en + en→ru в одном проходе
    for idx, data in enumerate(tqdm(values, desc=f"{os.path.basename(src_path)} zh→en→ru", unit="строка"), start=1):
        value = data.find("value")
        if value is not None and value.text:
            raw = value.text
            mid = cached_translate(zh_en, raw)
            final = cached_translate(en_ru, mid)
            value.text = final

            if log_mode == "full":
                logs.append(f"[{idx}] zh: {raw} | en: {mid} | ru: {final}")
            elif log_mode == "first5" and idx <= 5:
                logs.append(f"[{idx}] zh: {raw} | en: {mid} | ru: {final}")
            elif log_mode == "every10" and idx % 10 == 0:
                logs.append(f"[{idx}] zh: {raw} | en: {mid} | ru: {final}")

    # Записываем финальный файл
    tree.write(ru_new_path, encoding="utf-8", xml_declaration=True)

    # Лог minimal
    if log_mode == "minimal" and values:
        first_val = values[0].find("value").text
        last_val = values[-1].find("value").text
        logs.append(f"Файл {os.path.basename(src_path)} обработан")
        logs.append(f"Первая фраза: {first_val}")
        logs.append(f"Последняя фраза: {last_val}")

    # Выводим лог блоком (чтобы при параллельности не перемешивалось)
    if logs:
        block = "\n".join(logs)
        print(block)
        if log_file:
            log_file.write(block + "\n")


def main():
    parser = argparse.ArgumentParser(
        description="Translation of .resx files: zh→en→ru with caching, single XML parse, grouped logging, parallel workers, resume, dry-run.",
        formatter_class=argparse.RawTextHelpFormatter,
        epilog="""
Примеры запуска:

1. Все файлы (минимальный лог):
   python translate_resx.py --original C:\\src --intermediate C:\\en --final C:\\ru

2. Один файл для отладки:
   python translate_resx.py --original C:\\src --intermediate C:\\en --final C:\\ru --single MyPlugin.Strings.ru-RU.resx

3. Полный лог:
   python translate_resx.py --original C:\\src --intermediate C:\\en --final C:\\ru --log full

4. Первые 5 фраз:
   python translate_resx.py --original C:\\src --intermediate C:\\en --final C:\\ru --log first5

5. Каждая 10-я фраза:
   python translate_resx.py --original C:\\src --intermediate C:\\en --final C:\\ru --log every10

6. Параллельная обработка 4 файлов:
   python translate_resx.py --original C:\\src --intermediate C:\\en --final C:\\ru --workers 4

7. Продолжение обработки:
   python translate_resx.py --original C:\\src --intermediate C:\\en --final C:\\ru --resume

8. Комбинация: один файл, полный лог, resume:
   python translate_resx.py --original C:\\src --intermediate C:\\en --final C:\\ru --single MyPlugin.Strings.ru-RU.resx --log full --resume

9. Все файлы, каждая 10-я фраза, 2 воркера:
   python translate_resx.py --original C:\\src --intermediate C:\\en --final C:\\ru --log every10 --workers 2

10. Проверка списка файлов без перевода:
   python translate_resx.py --original C:\\src --intermediate C:\\en --final C:\\ru --dry-run

11. Сохранение лога в файл:
   python translate_resx.py --original C:\\src --intermediate C:\\en --final C:\\ru --log full --workers 2 --resume --logfile C:\\logs\\translate.log
"""
    )
    parser.add_argument("--original", required=True, help="Папка с оригинальными .resx файлами (китайский текст).")
    parser.add_argument("--intermediate", required=True, help="Папка для промежуточных файлов (английский перевод).")
    parser.add_argument("--final", required=True, help="Папка для финальных файлов (русский перевод).")
    parser.add_argument("--single", default=None, help="Имя одного файла для отладки.")
    parser.add_argument("--log", choices=["full", "first5", "every10", "minimal"], default="minimal",
                        help="Уровень логирования.")
    parser.add_argument("--workers", type=int, default=1,
                        help="Количество параллельных процессов для обработки файлов.")
    parser.add_argument("--resume", action="store_true",
                        help="Пропускать уже обработанные файлы (если финальный .resx.new существует).")
    parser.add_argument("--dry-run", action="store_true",
                        help="Только показать список файлов, которые будут обработаны, без перевода.")
    parser.add_argument("--logfile", default=None,
                        help="Путь к файлу для сохранения лога (например, C:\\logs\\translate.log).")
    args = parser.parse_args()

    langs = tr.get_installed_languages()
    zh = next(l for l in langs if l.code == "zh")
    en = next(l for l in langs if l.code == "en")
    ru = next(l for l in langs if l.code == "ru")
    zh_en = zh.get_translation(en)
    en_ru = en.get_translation(ru)

    if args.single:
        files = [args.single]
    else:
        files = [f for f in os.listdir(args.original) if f.endswith(".Strings.ru-RU.resx")]

    total = len(files)
    print(f"Найдено файлов: {total}")

    if args.dry_run:
        print("Dry-run: будут обработаны следующие файлы:")
        for f in files:
            print(" -", f)
        return

    log_file = None
    if args.logfile:
        os.makedirs(os.path.dirname(args.logfile), exist_ok=True)
        log_file = open(args.logfile, "a", encoding="utf-8")
        log_file.write(f"\n=== Запуск {datetime.datetime.now()} ===\n")

    def task(file):
        src_path = os.path.join(args.original, file)
        en_path = os.path.join(args.intermediate, file.replace(".ru-RU.resx", ".en-US.resx"))
        ru_new_path = os.path.join(args.final, file.replace(".ru-RU.resx", ".ru-RU.resx.new"))

        if args.resume and os.path.exists(ru_new_path):
            msg = f"[SKIP] {file} уже обработан"
            print(msg)
            if log_file: log_file.write(msg + "\n")
            return

        msg = f"Обработка файла: {file}"
        print(msg)
        if log_file: log_file.write(msg + "\n")
        translate_file(src_path, en_path, ru_new_path, args.log, zh_en, en_ru, args.resume, log_file)

    if args.workers > 1:
        with ProcessPoolExecutor(max_workers=args.workers) as executor:
            executor.map(task, files)
    else:
        for file in files:
            task(file)

    if log_file:
        log_file.write(f"=== Завершение {datetime.datetime.now()} ===\n")
        log_file.close()


if __name__ == "__main__":
    main()
